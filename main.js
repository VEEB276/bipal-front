import {
  MatListItem,
  MatListItemIcon,
  MatListItemTitle,
  MatListModule,
  MatNavList
} from "./chunk-AULEXFFY.js";
import {
  DateAdapter,
  HttpGetLoadingService,
  LoadingComponent,
  MAT_DATE_FORMATS,
  MAT_DATE_LOCALE,
  MatAccordion,
  MatError,
  MatExpansionModule,
  MatExpansionPanel,
  MatExpansionPanelContent,
  MatExpansionPanelDescription,
  MatExpansionPanelHeader,
  MatExpansionPanelTitle,
  MatFormField,
  MatFormFieldModule,
  MatInput,
  MatInputModule,
  MatLabel,
  MatPrefix,
  MatSuffix,
  NativeDateAdapter,
  TopGetLoadingBarComponent,
  _MatInternalFormField
} from "./chunk-K7O4JYQB.js";
import {
  CheckboxRequiredValidator,
  DefaultValueAccessor,
  FormBuilder,
  FormControl,
  FormControlDirective,
  FormControlName,
  FormGroupDirective,
  FormsModule,
  MatDivider,
  MatDividerModule,
  MaxLengthValidator,
  NG_VALIDATORS,
  NG_VALUE_ACCESSOR,
  NgControlStatus,
  NgControlStatusGroup,
  ReactiveFormsModule,
  Validators,
  ɵNgNoValidate
} from "./chunk-TRD36DVC.js";
import {
  MatCard,
  MatCardActions,
  MatCardContent,
  MatCardHeader,
  MatCardModule,
  MatCardTitle
} from "./chunk-BYQETCUD.js";
import {
  ActionsSubject,
  AuthService,
  CdkScrollable,
  CdkScrollableModule,
  ComponentPortal,
  ConfirmDialogService,
  FEATURE_STATE_PROVIDER,
  INIT,
  INITIAL_STATE,
  InformacionPersonalService,
  LoadingService,
  NotificationService,
  Overlay,
  OverlayModule,
  ROOT_STORE_PROVIDER,
  ReducerManagerDispatcher,
  ReducerObservable,
  ScannedActionsSubject,
  ScrollDispatcher,
  StateObservable,
  Store,
  StoreFeatureModule,
  StoreRootModule,
  UPDATE,
  ViewportRuler,
  createAction,
  environment,
  provideStore,
  toSignal
} from "./chunk-FGT3NZXF.js";
import "./chunk-EGGHZP6O.js";
import {
  A11yModule,
  ANIMATION_MODULE_TYPE,
  ActivatedRoute,
  AriaDescriber,
  BreakpointObserver,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  CommonModule,
  Component,
  ContentChild,
  ContentChildren,
  DOCUMENT,
  Directionality,
  Directive,
  EMPTY,
  ESCAPE,
  ElementRef,
  ErrorHandler,
  EventEmitter,
  FocusMonitor,
  FocusTrapFactory,
  HostAttributeToken,
  HttpClient,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  InteractivityChecker,
  MatButton,
  MatButtonModule,
  MatCommonModule,
  MatIcon,
  MatIconButton,
  MatIconModule,
  MatIconRegistry,
  MatRipple,
  NgClass,
  NgForOf,
  NgIf,
  NgModule,
  NgZone,
  Observable,
  Optional,
  Output,
  Pipe,
  Platform,
  QueryList,
  Renderer2,
  ReplaySubject,
  Router,
  RouterLink,
  RouterModule,
  RouterOutlet,
  Subject,
  ViewChild,
  ViewContainerRef,
  ViewEncapsulation,
  _CdkPrivateStyleLoader,
  _IdGenerator,
  _StructuralStylesLoader,
  afterNextRender,
  booleanAttribute,
  bootstrapApplication,
  catchError,
  coerceBooleanProperty,
  coerceNumberProperty,
  computed,
  concat,
  concatMap,
  debounceTime,
  defer,
  dematerialize,
  exhaustMap,
  filter,
  finalize,
  firstValueFrom,
  forkJoin,
  forwardRef,
  fromEvent,
  groupBy,
  hasModifierKey,
  ignoreElements,
  importProvidersFrom,
  inject,
  input,
  isObservable,
  makeEnvironmentProviders,
  map,
  mapTo,
  materialize,
  merge,
  mergeMap,
  normalizePassiveListenerOptions,
  numberAttribute,
  observeOn,
  of,
  provideEnvironmentInitializer,
  provideHttpClient,
  provideRouter,
  provideZoneChangeDetection,
  queueScheduler,
  scan,
  setClassMetadata,
  share,
  shareReplay,
  signal,
  skip,
  startWith,
  switchMap,
  take,
  takeUntil,
  timeout,
  withInterceptors,
  withLatestFrom,
  ɵsetClassDebugInfo,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassProp,
  ɵɵconditional,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵhostProperty,
  ɵɵinject,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceHTML,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵrepeater,
  ɵɵrepeaterCreate,
  ɵɵrepeaterTrackByIndex,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeUrl,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵviewQuery
} from "./chunk-IXVPDR65.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-UGR6JUJC.js";

// node_modules/.pnpm/@ngrx+effects@20.0.1_@angular+core@19.2.14_rxjs@7.8.2_zone.js@0.15.1__@ngrx+store@20.0._5bd980bb72d7256ff412fd8935e9d963/node_modules/@ngrx/effects/fesm2022/ngrx-effects.mjs
var CREATE_EFFECT_METADATA_KEY = "__@ngrx/effects_create__";
function getCreateEffectMetadata(instance) {
  const propertyNames = Object.getOwnPropertyNames(instance);
  const metadata = propertyNames.filter((propertyName) => {
    if (instance[propertyName] && instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)) {
      const property = instance[propertyName];
      return property[CREATE_EFFECT_METADATA_KEY].hasOwnProperty("dispatch");
    }
    return false;
  }).map((propertyName) => {
    const metaData = instance[propertyName][CREATE_EFFECT_METADATA_KEY];
    return __spreadValues({
      propertyName
    }, metaData);
  });
  return metadata;
}
function getSourceMetadata(instance) {
  return getCreateEffectMetadata(instance);
}
function getSourceForInstance(instance) {
  return Object.getPrototypeOf(instance);
}
function isClassInstance(obj) {
  return !!obj.constructor && obj.constructor.name !== "Object" && obj.constructor.name !== "Function";
}
function isClass(classOrRecord) {
  return typeof classOrRecord === "function";
}
function getClasses(classesAndRecords) {
  return classesAndRecords.filter(isClass);
}
function isToken(tokenOrRecord) {
  return tokenOrRecord instanceof InjectionToken || isClass(tokenOrRecord);
}
function mergeEffects(sourceInstance, globalErrorHandler, effectsErrorHandler) {
  const source = getSourceForInstance(sourceInstance);
  const isClassBasedEffect = !!source && source.constructor.name !== "Object";
  const sourceName = isClassBasedEffect ? source.constructor.name : null;
  const observables$ = getSourceMetadata(sourceInstance).map(({
    propertyName,
    dispatch,
    useEffectsErrorHandler
  }) => {
    const observable$ = typeof sourceInstance[propertyName] === "function" ? sourceInstance[propertyName]() : sourceInstance[propertyName];
    const effectAction$ = useEffectsErrorHandler ? effectsErrorHandler(observable$, globalErrorHandler) : observable$;
    if (dispatch === false) {
      return effectAction$.pipe(ignoreElements());
    }
    const materialized$ = effectAction$.pipe(materialize());
    return materialized$.pipe(map((notification) => ({
      effect: sourceInstance[propertyName],
      notification,
      propertyName,
      sourceName,
      sourceInstance
    })));
  });
  return merge(...observables$);
}
var MAX_NUMBER_OF_RETRY_ATTEMPTS = 10;
function defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft = MAX_NUMBER_OF_RETRY_ATTEMPTS) {
  return observable$.pipe(catchError((error) => {
    if (errorHandler) errorHandler.handleError(error);
    if (retryAttemptLeft <= 1) {
      return observable$;
    }
    return defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft - 1);
  }));
}
var Actions = class _Actions extends Observable {
  constructor(source) {
    super();
    if (source) {
      this.source = source;
    }
  }
  lift(operator) {
    const observable = new _Actions();
    observable.source = this;
    observable.operator = operator;
    return observable;
  }
  static {
    this.\u0275fac = function Actions_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _Actions)(\u0275\u0275inject(ScannedActionsSubject));
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _Actions,
      factory: _Actions.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Actions, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Observable,
    decorators: [{
      type: Inject,
      args: [ScannedActionsSubject]
    }]
  }], null);
})();
var _ROOT_EFFECTS_GUARD = new InjectionToken("@ngrx/effects Internal Root Guard");
var USER_PROVIDED_EFFECTS = new InjectionToken("@ngrx/effects User Provided Effects");
var _ROOT_EFFECTS = new InjectionToken("@ngrx/effects Internal Root Effects");
var _ROOT_EFFECTS_INSTANCES = new InjectionToken("@ngrx/effects Internal Root Effects Instances");
var _FEATURE_EFFECTS = new InjectionToken("@ngrx/effects Internal Feature Effects");
var _FEATURE_EFFECTS_INSTANCE_GROUPS = new InjectionToken("@ngrx/effects Internal Feature Effects Instance Groups");
var EFFECTS_ERROR_HANDLER = new InjectionToken("@ngrx/effects Effects Error Handler", {
  providedIn: "root",
  factory: () => defaultEffectsErrorHandler
});
var ROOT_EFFECTS_INIT = "@ngrx/effects/init";
var rootEffectsInit = createAction(ROOT_EFFECTS_INIT);
function reportInvalidActions(output, reporter) {
  if (output.notification.kind === "N") {
    const action = output.notification.value;
    const isInvalidAction = !isAction(action);
    if (isInvalidAction) {
      reporter.handleError(new Error(`Effect ${getEffectName(output)} dispatched an invalid action: ${stringify(action)}`));
    }
  }
}
function isAction(action) {
  return typeof action !== "function" && action && action.type && typeof action.type === "string";
}
function getEffectName({
  propertyName,
  sourceInstance,
  sourceName
}) {
  const isMethod = typeof sourceInstance[propertyName] === "function";
  const isClassBasedEffect = !!sourceName;
  return isClassBasedEffect ? `"${sourceName}.${String(propertyName)}${isMethod ? "()" : ""}"` : `"${String(propertyName)}()"`;
}
function stringify(action) {
  try {
    return JSON.stringify(action);
  } catch {
    return action;
  }
}
var onIdentifyEffectsKey = "ngrxOnIdentifyEffects";
function isOnIdentifyEffects(instance) {
  return isFunction(instance, onIdentifyEffectsKey);
}
var onRunEffectsKey = "ngrxOnRunEffects";
function isOnRunEffects(instance) {
  return isFunction(instance, onRunEffectsKey);
}
var onInitEffects = "ngrxOnInitEffects";
function isOnInitEffects(instance) {
  return isFunction(instance, onInitEffects);
}
function isFunction(instance, functionName) {
  return instance && functionName in instance && typeof instance[functionName] === "function";
}
var EffectSources = class _EffectSources extends Subject {
  constructor(errorHandler, effectsErrorHandler) {
    super();
    this.errorHandler = errorHandler;
    this.effectsErrorHandler = effectsErrorHandler;
  }
  addEffects(effectSourceInstance) {
    this.next(effectSourceInstance);
  }
  /**
   * @internal
   */
  toActions() {
    return this.pipe(groupBy((effectsInstance2) => isClassInstance(effectsInstance2) ? getSourceForInstance(effectsInstance2) : effectsInstance2), mergeMap((source$) => {
      return source$.pipe(groupBy(effectsInstance));
    }), mergeMap((source$) => {
      const effect$ = source$.pipe(exhaustMap((sourceInstance) => {
        return resolveEffectSource(this.errorHandler, this.effectsErrorHandler)(sourceInstance);
      }), map((output) => {
        reportInvalidActions(output, this.errorHandler);
        return output.notification;
      }), filter((notification) => notification.kind === "N" && notification.value != null), dematerialize());
      const init$ = source$.pipe(take(1), filter(isOnInitEffects), map((instance) => instance.ngrxOnInitEffects()));
      return merge(effect$, init$);
    }));
  }
  static {
    this.\u0275fac = function EffectSources_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _EffectSources)(\u0275\u0275inject(ErrorHandler), \u0275\u0275inject(EFFECTS_ERROR_HANDLER));
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _EffectSources,
      factory: _EffectSources.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EffectSources, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: ErrorHandler
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [EFFECTS_ERROR_HANDLER]
    }]
  }], null);
})();
function effectsInstance(sourceInstance) {
  if (isOnIdentifyEffects(sourceInstance)) {
    return sourceInstance.ngrxOnIdentifyEffects();
  }
  return "";
}
function resolveEffectSource(errorHandler, effectsErrorHandler) {
  return (sourceInstance) => {
    const mergedEffects$ = mergeEffects(sourceInstance, errorHandler, effectsErrorHandler);
    if (isOnRunEffects(sourceInstance)) {
      return sourceInstance.ngrxOnRunEffects(mergedEffects$);
    }
    return mergedEffects$;
  };
}
var EffectsRunner = class _EffectsRunner {
  get isStarted() {
    return !!this.effectsSubscription;
  }
  constructor(effectSources, store) {
    this.effectSources = effectSources;
    this.store = store;
    this.effectsSubscription = null;
  }
  start() {
    if (!this.effectsSubscription) {
      this.effectsSubscription = this.effectSources.toActions().subscribe(this.store);
    }
  }
  ngOnDestroy() {
    if (this.effectsSubscription) {
      this.effectsSubscription.unsubscribe();
      this.effectsSubscription = null;
    }
  }
  static {
    this.\u0275fac = function EffectsRunner_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _EffectsRunner)(\u0275\u0275inject(EffectSources), \u0275\u0275inject(Store));
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _EffectsRunner,
      factory: _EffectsRunner.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EffectsRunner, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: EffectSources
  }, {
    type: Store
  }], null);
})();
var EffectsRootModule = class _EffectsRootModule {
  constructor(sources, runner, store, rootEffectsInstances, storeRootModule, storeFeatureModule, guard) {
    this.sources = sources;
    runner.start();
    for (const effectsInstance2 of rootEffectsInstances) {
      sources.addEffects(effectsInstance2);
    }
    store.dispatch({
      type: ROOT_EFFECTS_INIT
    });
  }
  addEffects(effectsInstance2) {
    this.sources.addEffects(effectsInstance2);
  }
  static {
    this.\u0275fac = function EffectsRootModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _EffectsRootModule)(\u0275\u0275inject(EffectSources), \u0275\u0275inject(EffectsRunner), \u0275\u0275inject(Store), \u0275\u0275inject(_ROOT_EFFECTS_INSTANCES), \u0275\u0275inject(StoreRootModule, 8), \u0275\u0275inject(StoreFeatureModule, 8), \u0275\u0275inject(_ROOT_EFFECTS_GUARD, 8));
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _EffectsRootModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EffectsRootModule, [{
    type: NgModule,
    args: [{}]
  }], () => [{
    type: EffectSources
  }, {
    type: EffectsRunner
  }, {
    type: Store
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [_ROOT_EFFECTS_INSTANCES]
    }]
  }, {
    type: StoreRootModule,
    decorators: [{
      type: Optional
    }]
  }, {
    type: StoreFeatureModule,
    decorators: [{
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [_ROOT_EFFECTS_GUARD]
    }]
  }], null);
})();
var EffectsFeatureModule = class _EffectsFeatureModule {
  constructor(effectsRootModule, effectsInstanceGroups, storeRootModule, storeFeatureModule) {
    const effectsInstances = effectsInstanceGroups.flat();
    for (const effectsInstance2 of effectsInstances) {
      effectsRootModule.addEffects(effectsInstance2);
    }
  }
  static {
    this.\u0275fac = function EffectsFeatureModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _EffectsFeatureModule)(\u0275\u0275inject(EffectsRootModule), \u0275\u0275inject(_FEATURE_EFFECTS_INSTANCE_GROUPS), \u0275\u0275inject(StoreRootModule, 8), \u0275\u0275inject(StoreFeatureModule, 8));
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _EffectsFeatureModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EffectsFeatureModule, [{
    type: NgModule,
    args: [{}]
  }], () => [{
    type: EffectsRootModule
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [_FEATURE_EFFECTS_INSTANCE_GROUPS]
    }]
  }, {
    type: StoreRootModule,
    decorators: [{
      type: Optional
    }]
  }, {
    type: StoreFeatureModule,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var EffectsModule = class _EffectsModule {
  static forFeature(...featureEffects) {
    const effects = featureEffects.flat();
    const effectsClasses = getClasses(effects);
    return {
      ngModule: EffectsFeatureModule,
      providers: [effectsClasses, {
        provide: _FEATURE_EFFECTS,
        multi: true,
        useValue: effects
      }, {
        provide: USER_PROVIDED_EFFECTS,
        multi: true,
        useValue: []
      }, {
        provide: _FEATURE_EFFECTS_INSTANCE_GROUPS,
        multi: true,
        useFactory: createEffectsInstances,
        deps: [_FEATURE_EFFECTS, USER_PROVIDED_EFFECTS]
      }]
    };
  }
  static forRoot(...rootEffects) {
    const effects = rootEffects.flat();
    const effectsClasses = getClasses(effects);
    return {
      ngModule: EffectsRootModule,
      providers: [effectsClasses, {
        provide: _ROOT_EFFECTS,
        useValue: [effects]
      }, {
        provide: _ROOT_EFFECTS_GUARD,
        useFactory: _provideForRootGuard
      }, {
        provide: USER_PROVIDED_EFFECTS,
        multi: true,
        useValue: []
      }, {
        provide: _ROOT_EFFECTS_INSTANCES,
        useFactory: createEffectsInstances,
        deps: [_ROOT_EFFECTS, USER_PROVIDED_EFFECTS]
      }]
    };
  }
  static {
    this.\u0275fac = function EffectsModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _EffectsModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _EffectsModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EffectsModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
function createEffectsInstances(effectsGroups, userProvidedEffectsGroups) {
  const effects = [];
  for (const effectsGroup of effectsGroups) {
    effects.push(...effectsGroup);
  }
  for (const userProvidedEffectsGroup of userProvidedEffectsGroups) {
    effects.push(...userProvidedEffectsGroup);
  }
  return effects.map((effectsTokenOrRecord) => isToken(effectsTokenOrRecord) ? inject(effectsTokenOrRecord) : effectsTokenOrRecord);
}
function _provideForRootGuard() {
  const runner = inject(EffectsRunner, {
    optional: true,
    skipSelf: true
  });
  const rootEffects = inject(_ROOT_EFFECTS, {
    self: true
  });
  const hasEffects = !(rootEffects.length === 1 && rootEffects[0].length === 0);
  if (hasEffects && runner) {
    throw new TypeError(`EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`);
  }
  return "guarded";
}
function provideEffects(...effects) {
  const effectsClassesAndRecords = effects.flat();
  const effectsClasses = getClasses(effectsClassesAndRecords);
  return makeEnvironmentProviders([effectsClasses, provideEnvironmentInitializer(() => {
    inject(ROOT_STORE_PROVIDER);
    inject(FEATURE_STATE_PROVIDER, {
      optional: true
    });
    const effectsRunner = inject(EffectsRunner);
    const effectSources = inject(EffectSources);
    const shouldInitEffects = !effectsRunner.isStarted;
    if (shouldInitEffects) {
      effectsRunner.start();
    }
    for (const effectsClassOrRecord of effectsClassesAndRecords) {
      const effectsInstance2 = isClass(effectsClassOrRecord) ? inject(effectsClassOrRecord) : effectsClassOrRecord;
      effectSources.addEffects(effectsInstance2);
    }
    if (shouldInitEffects) {
      const store = inject(Store);
      store.dispatch(rootEffectsInit());
    }
  })]);
}

// node_modules/.pnpm/@ngrx+store-devtools@20.0.1_@angular+core@19.2.14_rxjs@7.8.2_zone.js@0.15.1__@ngrx+stor_2dab6fc7f49ac78e99b9bf709156c53c/node_modules/@ngrx/store-devtools/fesm2022/ngrx-store-devtools.mjs
var PERFORM_ACTION = "PERFORM_ACTION";
var REFRESH = "REFRESH";
var RESET = "RESET";
var ROLLBACK = "ROLLBACK";
var COMMIT = "COMMIT";
var SWEEP = "SWEEP";
var TOGGLE_ACTION = "TOGGLE_ACTION";
var SET_ACTIONS_ACTIVE = "SET_ACTIONS_ACTIVE";
var JUMP_TO_STATE = "JUMP_TO_STATE";
var JUMP_TO_ACTION = "JUMP_TO_ACTION";
var IMPORT_STATE = "IMPORT_STATE";
var LOCK_CHANGES = "LOCK_CHANGES";
var PAUSE_RECORDING = "PAUSE_RECORDING";
var PerformAction = class {
  constructor(action, timestamp) {
    this.action = action;
    this.timestamp = timestamp;
    this.type = PERFORM_ACTION;
    if (typeof action.type === "undefined") {
      throw new Error('Actions may not have an undefined "type" property. Have you misspelled a constant?');
    }
  }
};
var Refresh = class {
  constructor() {
    this.type = REFRESH;
  }
};
var Reset = class {
  constructor(timestamp) {
    this.timestamp = timestamp;
    this.type = RESET;
  }
};
var Rollback = class {
  constructor(timestamp) {
    this.timestamp = timestamp;
    this.type = ROLLBACK;
  }
};
var Commit = class {
  constructor(timestamp) {
    this.timestamp = timestamp;
    this.type = COMMIT;
  }
};
var Sweep = class {
  constructor() {
    this.type = SWEEP;
  }
};
var ToggleAction = class {
  constructor(id) {
    this.id = id;
    this.type = TOGGLE_ACTION;
  }
};
var JumpToState = class {
  constructor(index) {
    this.index = index;
    this.type = JUMP_TO_STATE;
  }
};
var JumpToAction = class {
  constructor(actionId) {
    this.actionId = actionId;
    this.type = JUMP_TO_ACTION;
  }
};
var ImportState = class {
  constructor(nextLiftedState) {
    this.nextLiftedState = nextLiftedState;
    this.type = IMPORT_STATE;
  }
};
var LockChanges = class {
  constructor(status) {
    this.status = status;
    this.type = LOCK_CHANGES;
  }
};
var PauseRecording = class {
  constructor(status) {
    this.status = status;
    this.type = PAUSE_RECORDING;
  }
};
var StoreDevtoolsConfig = class {
  constructor() {
    this.maxAge = false;
  }
};
var STORE_DEVTOOLS_CONFIG = new InjectionToken("@ngrx/store-devtools Options");
var INITIAL_OPTIONS = new InjectionToken("@ngrx/store-devtools Initial Config");
function noMonitor() {
  return null;
}
var DEFAULT_NAME = "NgRx Store DevTools";
function createConfig(optionsInput) {
  const DEFAULT_OPTIONS = {
    maxAge: false,
    monitor: noMonitor,
    actionSanitizer: void 0,
    stateSanitizer: void 0,
    name: DEFAULT_NAME,
    serialize: false,
    logOnly: false,
    autoPause: false,
    trace: false,
    traceLimit: 75,
    // Add all features explicitly. This prevent buggy behavior for
    // options like "lock" which might otherwise not show up.
    features: {
      pause: true,
      // Start/pause recording of dispatched actions
      lock: true,
      // Lock/unlock dispatching actions and side effects
      persist: true,
      // Persist states on page reloading
      export: true,
      // Export history of actions in a file
      import: "custom",
      // Import history of actions from a file
      jump: true,
      // Jump back and forth (time travelling)
      skip: true,
      // Skip (cancel) actions
      reorder: true,
      // Drag and drop actions in the history list
      dispatch: true,
      // Dispatch custom actions or action creators
      test: true
      // Generate tests for the selected actions
    },
    connectInZone: false
  };
  const options = typeof optionsInput === "function" ? optionsInput() : optionsInput;
  const logOnly = options.logOnly ? {
    pause: true,
    export: true,
    test: true
  } : false;
  const features = options.features || logOnly || DEFAULT_OPTIONS.features;
  if (features.import === true) {
    features.import = "custom";
  }
  const config = Object.assign({}, DEFAULT_OPTIONS, {
    features
  }, options);
  if (config.maxAge && config.maxAge < 2) {
    throw new Error(`Devtools 'maxAge' cannot be less than 2, got ${config.maxAge}`);
  }
  return config;
}
function difference(first, second) {
  return first.filter((item) => second.indexOf(item) < 0);
}
function unliftState(liftedState) {
  const {
    computedStates,
    currentStateIndex
  } = liftedState;
  if (currentStateIndex >= computedStates.length) {
    const {
      state: state2
    } = computedStates[computedStates.length - 1];
    return state2;
  }
  const {
    state
  } = computedStates[currentStateIndex];
  return state;
}
function liftAction(action) {
  return new PerformAction(action, +Date.now());
}
function sanitizeActions(actionSanitizer, actions) {
  return Object.keys(actions).reduce((sanitizedActions, actionIdx) => {
    const idx = Number(actionIdx);
    sanitizedActions[idx] = sanitizeAction(actionSanitizer, actions[idx], idx);
    return sanitizedActions;
  }, {});
}
function sanitizeAction(actionSanitizer, action, actionIdx) {
  return __spreadProps(__spreadValues({}, action), {
    action: actionSanitizer(action.action, actionIdx)
  });
}
function sanitizeStates(stateSanitizer, states) {
  return states.map((computedState, idx) => ({
    state: sanitizeState(stateSanitizer, computedState.state, idx),
    error: computedState.error
  }));
}
function sanitizeState(stateSanitizer, state, stateIdx) {
  return stateSanitizer(state, stateIdx);
}
function shouldFilterActions(config) {
  return config.predicate || config.actionsSafelist || config.actionsBlocklist;
}
function filterLiftedState(liftedState, predicate, safelist, blocklist) {
  const filteredStagedActionIds = [];
  const filteredActionsById = {};
  const filteredComputedStates = [];
  liftedState.stagedActionIds.forEach((id, idx) => {
    const liftedAction = liftedState.actionsById[id];
    if (!liftedAction) return;
    if (idx && isActionFiltered(liftedState.computedStates[idx], liftedAction, predicate, safelist, blocklist)) {
      return;
    }
    filteredActionsById[id] = liftedAction;
    filteredStagedActionIds.push(id);
    filteredComputedStates.push(liftedState.computedStates[idx]);
  });
  return __spreadProps(__spreadValues({}, liftedState), {
    stagedActionIds: filteredStagedActionIds,
    actionsById: filteredActionsById,
    computedStates: filteredComputedStates
  });
}
function isActionFiltered(state, action, predicate, safelist, blockedlist) {
  const predicateMatch = predicate && !predicate(state, action.action);
  const safelistMatch = safelist && !action.action.type.match(safelist.map((s) => escapeRegExp(s)).join("|"));
  const blocklistMatch = blockedlist && action.action.type.match(blockedlist.map((s) => escapeRegExp(s)).join("|"));
  return predicateMatch || safelistMatch || blocklistMatch;
}
function escapeRegExp(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function injectZoneConfig(connectInZone) {
  const ngZone = connectInZone ? inject(NgZone) : null;
  return {
    ngZone,
    connectInZone
  };
}
var DevtoolsDispatcher = class _DevtoolsDispatcher extends ActionsSubject {
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275DevtoolsDispatcher_BaseFactory;
      return function DevtoolsDispatcher_Factory(__ngFactoryType__) {
        return (\u0275DevtoolsDispatcher_BaseFactory || (\u0275DevtoolsDispatcher_BaseFactory = \u0275\u0275getInheritedFactory(_DevtoolsDispatcher)))(__ngFactoryType__ || _DevtoolsDispatcher);
      };
    })();
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _DevtoolsDispatcher,
      factory: _DevtoolsDispatcher.\u0275fac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DevtoolsDispatcher, [{
    type: Injectable
  }], null, null);
})();
var ExtensionActionTypes = {
  START: "START",
  DISPATCH: "DISPATCH",
  STOP: "STOP",
  ACTION: "ACTION"
};
var REDUX_DEVTOOLS_EXTENSION = new InjectionToken("@ngrx/store-devtools Redux Devtools Extension");
var DevtoolsExtension = class _DevtoolsExtension {
  constructor(devtoolsExtension, config, dispatcher) {
    this.config = config;
    this.dispatcher = dispatcher;
    this.zoneConfig = injectZoneConfig(this.config.connectInZone);
    this.devtoolsExtension = devtoolsExtension;
    this.createActionStreams();
  }
  notify(action, state) {
    if (!this.devtoolsExtension) {
      return;
    }
    if (action.type === PERFORM_ACTION) {
      if (state.isLocked || state.isPaused) {
        return;
      }
      const currentState = unliftState(state);
      if (shouldFilterActions(this.config) && isActionFiltered(currentState, action, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) {
        return;
      }
      const sanitizedState = this.config.stateSanitizer ? sanitizeState(this.config.stateSanitizer, currentState, state.currentStateIndex) : currentState;
      const sanitizedAction = this.config.actionSanitizer ? sanitizeAction(this.config.actionSanitizer, action, state.nextActionId) : action;
      this.sendToReduxDevtools(() => this.extensionConnection.send(sanitizedAction, sanitizedState));
    } else {
      const sanitizedLiftedState = __spreadProps(__spreadValues({}, state), {
        stagedActionIds: state.stagedActionIds,
        actionsById: this.config.actionSanitizer ? sanitizeActions(this.config.actionSanitizer, state.actionsById) : state.actionsById,
        computedStates: this.config.stateSanitizer ? sanitizeStates(this.config.stateSanitizer, state.computedStates) : state.computedStates
      });
      this.sendToReduxDevtools(() => this.devtoolsExtension.send(null, sanitizedLiftedState, this.getExtensionConfig(this.config)));
    }
  }
  createChangesObservable() {
    if (!this.devtoolsExtension) {
      return EMPTY;
    }
    return new Observable((subscriber) => {
      const connection = this.zoneConfig.connectInZone ? (
        // To reduce change detection cycles, we need to run the `connect` method
        // outside of the Angular zone. The `connect` method adds a `message`
        // event listener to communicate with an extension using `window.postMessage`
        // and handle message events.
        this.zoneConfig.ngZone.runOutsideAngular(() => this.devtoolsExtension.connect(this.getExtensionConfig(this.config)))
      ) : this.devtoolsExtension.connect(this.getExtensionConfig(this.config));
      this.extensionConnection = connection;
      connection.init();
      connection.subscribe((change) => subscriber.next(change));
      return connection.unsubscribe;
    });
  }
  createActionStreams() {
    const changes$ = this.createChangesObservable().pipe(share());
    const start$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.START));
    const stop$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.STOP));
    const liftedActions$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.DISPATCH), map((change) => this.unwrapAction(change.payload)), concatMap((action) => {
      if (action.type === IMPORT_STATE) {
        return this.dispatcher.pipe(filter((action2) => action2.type === UPDATE), timeout(1e3), debounceTime(1e3), map(() => action), catchError(() => of(action)), take(1));
      } else {
        return of(action);
      }
    }));
    const actions$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.ACTION), map((change) => this.unwrapAction(change.payload)));
    const actionsUntilStop$ = actions$.pipe(takeUntil(stop$));
    const liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));
    this.start$ = start$.pipe(takeUntil(stop$));
    this.actions$ = this.start$.pipe(switchMap(() => actionsUntilStop$));
    this.liftedActions$ = this.start$.pipe(switchMap(() => liftedUntilStop$));
  }
  unwrapAction(action) {
    return typeof action === "string" ? (0, eval)(`(${action})`) : action;
  }
  getExtensionConfig(config) {
    const extensionOptions = {
      name: config.name,
      features: config.features,
      serialize: config.serialize,
      autoPause: config.autoPause ?? false,
      trace: config.trace ?? false,
      traceLimit: config.traceLimit ?? 75
      // The action/state sanitizers are not added to the config
      // because sanitation is done in this class already.
      // It is done before sending it to the devtools extension for consistency:
      // - If we call extensionConnection.send(...),
      //   the extension would call the sanitizers.
      // - If we call devtoolsExtension.send(...) (aka full state update),
      //   the extension would NOT call the sanitizers, so we have to do it ourselves.
    };
    if (config.maxAge !== false) {
      extensionOptions.maxAge = config.maxAge;
    }
    return extensionOptions;
  }
  sendToReduxDevtools(send) {
    try {
      send();
    } catch (err) {
      console.warn("@ngrx/store-devtools: something went wrong inside the redux devtools", err);
    }
  }
  static {
    this.\u0275fac = function DevtoolsExtension_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DevtoolsExtension)(\u0275\u0275inject(REDUX_DEVTOOLS_EXTENSION), \u0275\u0275inject(STORE_DEVTOOLS_CONFIG), \u0275\u0275inject(DevtoolsDispatcher));
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _DevtoolsExtension,
      factory: _DevtoolsExtension.\u0275fac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DevtoolsExtension, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [REDUX_DEVTOOLS_EXTENSION]
    }]
  }, {
    type: StoreDevtoolsConfig,
    decorators: [{
      type: Inject,
      args: [STORE_DEVTOOLS_CONFIG]
    }]
  }, {
    type: DevtoolsDispatcher
  }], null);
})();
var INIT_ACTION = {
  type: INIT
};
var RECOMPUTE = "@ngrx/store-devtools/recompute";
var RECOMPUTE_ACTION = {
  type: RECOMPUTE
};
function computeNextEntry(reducer, action, state, error, errorHandler) {
  if (error) {
    return {
      state,
      error: "Interrupted by an error up the chain"
    };
  }
  let nextState = state;
  let nextError;
  try {
    nextState = reducer(state, action);
  } catch (err) {
    nextError = err.toString();
    errorHandler.handleError(err);
  }
  return {
    state: nextState,
    error: nextError
  };
}
function recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused) {
  if (minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {
    return computedStates;
  }
  const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);
  const lastIncludedActionId = stagedActionIds.length - (isPaused ? 1 : 0);
  for (let i = minInvalidatedStateIndex; i < lastIncludedActionId; i++) {
    const actionId = stagedActionIds[i];
    const action = actionsById[actionId].action;
    const previousEntry = nextComputedStates[i - 1];
    const previousState = previousEntry ? previousEntry.state : committedState;
    const previousError = previousEntry ? previousEntry.error : void 0;
    const shouldSkip = skippedActionIds.indexOf(actionId) > -1;
    const entry = shouldSkip ? previousEntry : computeNextEntry(reducer, action, previousState, previousError, errorHandler);
    nextComputedStates.push(entry);
  }
  if (isPaused) {
    nextComputedStates.push(computedStates[computedStates.length - 1]);
  }
  return nextComputedStates;
}
function liftInitialState(initialCommittedState, monitorReducer) {
  return {
    monitorState: monitorReducer(void 0, {}),
    nextActionId: 1,
    actionsById: {
      0: liftAction(INIT_ACTION)
    },
    stagedActionIds: [0],
    skippedActionIds: [],
    committedState: initialCommittedState,
    currentStateIndex: 0,
    computedStates: [],
    isLocked: false,
    isPaused: false
  };
}
function liftReducerWith(initialCommittedState, initialLiftedState, errorHandler, monitorReducer, options = {}) {
  return (reducer) => (liftedState, liftedAction) => {
    let {
      monitorState,
      actionsById,
      nextActionId,
      stagedActionIds,
      skippedActionIds,
      committedState,
      currentStateIndex,
      computedStates,
      isLocked,
      isPaused
    } = liftedState || initialLiftedState;
    if (!liftedState) {
      actionsById = Object.create(actionsById);
    }
    function commitExcessActions(n) {
      let excess = n;
      let idsToDelete = stagedActionIds.slice(1, excess + 1);
      for (let i = 0; i < idsToDelete.length; i++) {
        if (computedStates[i + 1].error) {
          excess = i;
          idsToDelete = stagedActionIds.slice(1, excess + 1);
          break;
        } else {
          delete actionsById[idsToDelete[i]];
        }
      }
      skippedActionIds = skippedActionIds.filter((id) => idsToDelete.indexOf(id) === -1);
      stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];
      committedState = computedStates[excess].state;
      computedStates = computedStates.slice(excess);
      currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;
    }
    function commitChanges() {
      actionsById = {
        0: liftAction(INIT_ACTION)
      };
      nextActionId = 1;
      stagedActionIds = [0];
      skippedActionIds = [];
      committedState = computedStates[currentStateIndex].state;
      currentStateIndex = 0;
      computedStates = [];
    }
    let minInvalidatedStateIndex = 0;
    switch (liftedAction.type) {
      case LOCK_CHANGES: {
        isLocked = liftedAction.status;
        minInvalidatedStateIndex = Infinity;
        break;
      }
      case PAUSE_RECORDING: {
        isPaused = liftedAction.status;
        if (isPaused) {
          stagedActionIds = [...stagedActionIds, nextActionId];
          actionsById[nextActionId] = new PerformAction({
            type: "@ngrx/devtools/pause"
          }, +Date.now());
          nextActionId++;
          minInvalidatedStateIndex = stagedActionIds.length - 1;
          computedStates = computedStates.concat(computedStates[computedStates.length - 1]);
          if (currentStateIndex === stagedActionIds.length - 2) {
            currentStateIndex++;
          }
          minInvalidatedStateIndex = Infinity;
        } else {
          commitChanges();
        }
        break;
      }
      case RESET: {
        actionsById = {
          0: liftAction(INIT_ACTION)
        };
        nextActionId = 1;
        stagedActionIds = [0];
        skippedActionIds = [];
        committedState = initialCommittedState;
        currentStateIndex = 0;
        computedStates = [];
        break;
      }
      case COMMIT: {
        commitChanges();
        break;
      }
      case ROLLBACK: {
        actionsById = {
          0: liftAction(INIT_ACTION)
        };
        nextActionId = 1;
        stagedActionIds = [0];
        skippedActionIds = [];
        currentStateIndex = 0;
        computedStates = [];
        break;
      }
      case TOGGLE_ACTION: {
        const {
          id: actionId
        } = liftedAction;
        const index = skippedActionIds.indexOf(actionId);
        if (index === -1) {
          skippedActionIds = [actionId, ...skippedActionIds];
        } else {
          skippedActionIds = skippedActionIds.filter((id) => id !== actionId);
        }
        minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);
        break;
      }
      case SET_ACTIONS_ACTIVE: {
        const {
          start,
          end,
          active
        } = liftedAction;
        const actionIds = [];
        for (let i = start; i < end; i++) actionIds.push(i);
        if (active) {
          skippedActionIds = difference(skippedActionIds, actionIds);
        } else {
          skippedActionIds = [...skippedActionIds, ...actionIds];
        }
        minInvalidatedStateIndex = stagedActionIds.indexOf(start);
        break;
      }
      case JUMP_TO_STATE: {
        currentStateIndex = liftedAction.index;
        minInvalidatedStateIndex = Infinity;
        break;
      }
      case JUMP_TO_ACTION: {
        const index = stagedActionIds.indexOf(liftedAction.actionId);
        if (index !== -1) currentStateIndex = index;
        minInvalidatedStateIndex = Infinity;
        break;
      }
      case SWEEP: {
        stagedActionIds = difference(stagedActionIds, skippedActionIds);
        skippedActionIds = [];
        currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);
        break;
      }
      case PERFORM_ACTION: {
        if (isLocked) {
          return liftedState || initialLiftedState;
        }
        if (isPaused || liftedState && isActionFiltered(liftedState.computedStates[currentStateIndex], liftedAction, options.predicate, options.actionsSafelist, options.actionsBlocklist)) {
          const lastState = computedStates[computedStates.length - 1];
          computedStates = [...computedStates.slice(0, -1), computeNextEntry(reducer, liftedAction.action, lastState.state, lastState.error, errorHandler)];
          minInvalidatedStateIndex = Infinity;
          break;
        }
        if (options.maxAge && stagedActionIds.length === options.maxAge) {
          commitExcessActions(1);
        }
        if (currentStateIndex === stagedActionIds.length - 1) {
          currentStateIndex++;
        }
        const actionId = nextActionId++;
        actionsById[actionId] = liftedAction;
        stagedActionIds = [...stagedActionIds, actionId];
        minInvalidatedStateIndex = stagedActionIds.length - 1;
        break;
      }
      case IMPORT_STATE: {
        ({
          monitorState,
          actionsById,
          nextActionId,
          stagedActionIds,
          skippedActionIds,
          committedState,
          currentStateIndex,
          computedStates,
          isLocked,
          isPaused
        } = liftedAction.nextLiftedState);
        break;
      }
      case INIT: {
        minInvalidatedStateIndex = 0;
        if (options.maxAge && stagedActionIds.length > options.maxAge) {
          computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);
          commitExcessActions(stagedActionIds.length - options.maxAge);
          minInvalidatedStateIndex = Infinity;
        }
        break;
      }
      case UPDATE: {
        const stateHasErrors = computedStates.filter((state) => state.error).length > 0;
        if (stateHasErrors) {
          minInvalidatedStateIndex = 0;
          if (options.maxAge && stagedActionIds.length > options.maxAge) {
            computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);
            commitExcessActions(stagedActionIds.length - options.maxAge);
            minInvalidatedStateIndex = Infinity;
          }
        } else {
          if (!isPaused && !isLocked) {
            if (currentStateIndex === stagedActionIds.length - 1) {
              currentStateIndex++;
            }
            const actionId = nextActionId++;
            actionsById[actionId] = new PerformAction(liftedAction, +Date.now());
            stagedActionIds = [...stagedActionIds, actionId];
            minInvalidatedStateIndex = stagedActionIds.length - 1;
            computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);
          }
          computedStates = computedStates.map((cmp) => __spreadProps(__spreadValues({}, cmp), {
            state: reducer(cmp.state, RECOMPUTE_ACTION)
          }));
          currentStateIndex = stagedActionIds.length - 1;
          if (options.maxAge && stagedActionIds.length > options.maxAge) {
            commitExcessActions(stagedActionIds.length - options.maxAge);
          }
          minInvalidatedStateIndex = Infinity;
        }
        break;
      }
      default: {
        minInvalidatedStateIndex = Infinity;
        break;
      }
    }
    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);
    monitorState = monitorReducer(monitorState, liftedAction);
    return {
      monitorState,
      actionsById,
      nextActionId,
      stagedActionIds,
      skippedActionIds,
      committedState,
      currentStateIndex,
      computedStates,
      isLocked,
      isPaused
    };
  };
}
var StoreDevtools = class _StoreDevtools {
  constructor(dispatcher, actions$, reducers$, extension, scannedActions, errorHandler, initialState, config) {
    const liftedInitialState = liftInitialState(initialState, config.monitor);
    const liftReducer = liftReducerWith(initialState, liftedInitialState, errorHandler, config.monitor, config);
    const liftedAction$ = merge(merge(actions$.asObservable().pipe(skip(1)), extension.actions$).pipe(map(liftAction)), dispatcher, extension.liftedActions$).pipe(observeOn(queueScheduler));
    const liftedReducer$ = reducers$.pipe(map(liftReducer));
    const zoneConfig = injectZoneConfig(config.connectInZone);
    const liftedStateSubject = new ReplaySubject(1);
    this.liftedStateSubscription = liftedAction$.pipe(
      withLatestFrom(liftedReducer$),
      // The extension would post messages back outside of the Angular zone
      // because we call `connect()` wrapped with `runOutsideAngular`. We run change
      // detection only once at the end after all the required asynchronous tasks have
      // been processed (for instance, `setInterval` scheduled by the `timeout` operator).
      // We have to re-enter the Angular zone before the `scan` since it runs the reducer
      // which must be run within the Angular zone.
      emitInZone(zoneConfig),
      scan(({
        state: liftedState
      }, [action, reducer]) => {
        let reducedLiftedState = reducer(liftedState, action);
        if (action.type !== PERFORM_ACTION && shouldFilterActions(config)) {
          reducedLiftedState = filterLiftedState(reducedLiftedState, config.predicate, config.actionsSafelist, config.actionsBlocklist);
        }
        extension.notify(action, reducedLiftedState);
        return {
          state: reducedLiftedState,
          action
        };
      }, {
        state: liftedInitialState,
        action: null
      })
    ).subscribe(({
      state,
      action
    }) => {
      liftedStateSubject.next(state);
      if (action.type === PERFORM_ACTION) {
        const unliftedAction = action.action;
        scannedActions.next(unliftedAction);
      }
    });
    this.extensionStartSubscription = extension.start$.pipe(emitInZone(zoneConfig)).subscribe(() => {
      this.refresh();
    });
    const liftedState$ = liftedStateSubject.asObservable();
    const state$ = liftedState$.pipe(map(unliftState));
    Object.defineProperty(state$, "state", {
      value: toSignal(state$, {
        manualCleanup: true,
        requireSync: true
      })
    });
    this.dispatcher = dispatcher;
    this.liftedState = liftedState$;
    this.state = state$;
  }
  ngOnDestroy() {
    this.liftedStateSubscription.unsubscribe();
    this.extensionStartSubscription.unsubscribe();
  }
  dispatch(action) {
    this.dispatcher.next(action);
  }
  next(action) {
    this.dispatcher.next(action);
  }
  error(error) {
  }
  complete() {
  }
  performAction(action) {
    this.dispatch(new PerformAction(action, +Date.now()));
  }
  refresh() {
    this.dispatch(new Refresh());
  }
  reset() {
    this.dispatch(new Reset(+Date.now()));
  }
  rollback() {
    this.dispatch(new Rollback(+Date.now()));
  }
  commit() {
    this.dispatch(new Commit(+Date.now()));
  }
  sweep() {
    this.dispatch(new Sweep());
  }
  toggleAction(id) {
    this.dispatch(new ToggleAction(id));
  }
  jumpToAction(actionId) {
    this.dispatch(new JumpToAction(actionId));
  }
  jumpToState(index) {
    this.dispatch(new JumpToState(index));
  }
  importState(nextLiftedState) {
    this.dispatch(new ImportState(nextLiftedState));
  }
  lockChanges(status) {
    this.dispatch(new LockChanges(status));
  }
  pauseRecording(status) {
    this.dispatch(new PauseRecording(status));
  }
  static {
    this.\u0275fac = function StoreDevtools_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _StoreDevtools)(\u0275\u0275inject(DevtoolsDispatcher), \u0275\u0275inject(ActionsSubject), \u0275\u0275inject(ReducerObservable), \u0275\u0275inject(DevtoolsExtension), \u0275\u0275inject(ScannedActionsSubject), \u0275\u0275inject(ErrorHandler), \u0275\u0275inject(INITIAL_STATE), \u0275\u0275inject(STORE_DEVTOOLS_CONFIG));
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _StoreDevtools,
      factory: _StoreDevtools.\u0275fac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StoreDevtools, [{
    type: Injectable
  }], () => [{
    type: DevtoolsDispatcher
  }, {
    type: ActionsSubject
  }, {
    type: ReducerObservable
  }, {
    type: DevtoolsExtension
  }, {
    type: ScannedActionsSubject
  }, {
    type: ErrorHandler
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [INITIAL_STATE]
    }]
  }, {
    type: StoreDevtoolsConfig,
    decorators: [{
      type: Inject,
      args: [STORE_DEVTOOLS_CONFIG]
    }]
  }], null);
})();
function emitInZone({
  ngZone,
  connectInZone
}) {
  return (source) => connectInZone ? new Observable((subscriber) => source.subscribe({
    next: (value) => ngZone.run(() => subscriber.next(value)),
    error: (error) => ngZone.run(() => subscriber.error(error)),
    complete: () => ngZone.run(() => subscriber.complete())
  })) : source;
}
var IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken("@ngrx/store-devtools Is Devtools Extension or Monitor Present");
function createIsExtensionOrMonitorPresent(extension, config) {
  return Boolean(extension) || config.monitor !== noMonitor;
}
function createReduxDevtoolsExtension() {
  const extensionKey = "__REDUX_DEVTOOLS_EXTENSION__";
  if (typeof window === "object" && typeof window[extensionKey] !== "undefined") {
    return window[extensionKey];
  } else {
    return null;
  }
}
function createStateObservable(devtools) {
  return devtools.state;
}
function provideStoreDevtools(options = {}) {
  return makeEnvironmentProviders([DevtoolsExtension, DevtoolsDispatcher, StoreDevtools, {
    provide: INITIAL_OPTIONS,
    useValue: options
  }, {
    provide: IS_EXTENSION_OR_MONITOR_PRESENT,
    deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],
    useFactory: createIsExtensionOrMonitorPresent
  }, {
    provide: REDUX_DEVTOOLS_EXTENSION,
    useFactory: createReduxDevtoolsExtension
  }, {
    provide: STORE_DEVTOOLS_CONFIG,
    deps: [INITIAL_OPTIONS],
    useFactory: createConfig
  }, {
    provide: StateObservable,
    deps: [StoreDevtools],
    useFactory: createStateObservable
  }, {
    provide: ReducerManagerDispatcher,
    useExisting: DevtoolsDispatcher
  }]);
}
var StoreDevtoolsModule = class _StoreDevtoolsModule {
  static instrument(options = {}) {
    return {
      ngModule: _StoreDevtoolsModule,
      providers: [provideStoreDevtools(options)]
    };
  }
  static {
    this.\u0275fac = function StoreDevtoolsModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _StoreDevtoolsModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _StoreDevtoolsModule
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StoreDevtoolsModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();

// node_modules/.pnpm/@angular+material@19.2.18_@angular+cdk@19.2.19_@angular+common@19.2.14_@angular+core@19_102b8bfb5e382f9d0615b5538deb6474/node_modules/@angular/material/fesm2022/sidenav.mjs
var _c0 = ["*"];
var _c1 = ["content"];
var _c2 = [[["mat-drawer"]], [["mat-drawer-content"]], "*"];
var _c3 = ["mat-drawer", "mat-drawer-content", "*"];
function MatDrawerContainer_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275listener("click", function MatDrawerContainer_Conditional_0_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1._onBackdropClicked());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classProp("mat-drawer-shown", ctx_r1._isShowingBackdrop());
  }
}
function MatDrawerContainer_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-drawer-content");
    \u0275\u0275projection(1, 2);
    \u0275\u0275elementEnd();
  }
}
var _c4 = [[["mat-sidenav"]], [["mat-sidenav-content"]], "*"];
var _c5 = ["mat-sidenav", "mat-sidenav-content", "*"];
function MatSidenavContainer_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275listener("click", function MatSidenavContainer_Conditional_0_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1._onBackdropClicked());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classProp("mat-drawer-shown", ctx_r1._isShowingBackdrop());
  }
}
function MatSidenavContainer_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-sidenav-content");
    \u0275\u0275projection(1, 2);
    \u0275\u0275elementEnd();
  }
}
var _c6 = ".mat-drawer-container{position:relative;z-index:1;color:var(--mat-sidenav-content-text-color, var(--mat-sys-on-background));background-color:var(--mat-sidenav-content-background-color, var(--mat-sys-background));box-sizing:border-box;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible;background-color:var(--mat-sidenav-scrim-color, color-mix(in srgb, var(--mat-sys-neutral-variant20) 40%, transparent))}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}@media(forced-colors: active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-content.mat-drawer-content-hidden{opacity:0}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;color:var(--mat-sidenav-container-text-color, var(--mat-sys-on-surface-variant));box-shadow:var(--mat-sidenav-container-elevation-shadow, none);background-color:var(--mat-sidenav-container-background-color, var(--mat-sys-surface));border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));width:var(--mat-sidenav-container-width, 360px);display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}@media(forced-colors: active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media(forced-colors: active){[dir=rtl] .mat-drawer,.mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0);border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl] .mat-drawer{border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-left-radius:0;border-bottom-left-radius:0;left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-transition .mat-drawer{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating){visibility:hidden;box-shadow:none}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating) .mat-drawer-inner-container{display:none}.mat-drawer.mat-drawer-opened.mat-drawer-opened{transform:none}.mat-drawer-side{box-shadow:none;border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid}.mat-drawer-side.mat-drawer-end{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid;border-left:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto}.mat-sidenav-fixed{position:fixed}\n";
function throwMatDuplicatedDrawerError(position) {
  throw Error(`A drawer was already declared for 'position="${position}"'`);
}
var MAT_DRAWER_DEFAULT_AUTOSIZE = new InjectionToken("MAT_DRAWER_DEFAULT_AUTOSIZE", {
  providedIn: "root",
  factory: MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY
});
var MAT_DRAWER_CONTAINER = new InjectionToken("MAT_DRAWER_CONTAINER");
function MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY() {
  return false;
}
var MatDrawerContent = class _MatDrawerContent extends CdkScrollable {
  _platform = inject(Platform);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _container = inject(MatDrawerContainer);
  constructor() {
    const elementRef = inject(ElementRef);
    const scrollDispatcher = inject(ScrollDispatcher);
    const ngZone = inject(NgZone);
    super(elementRef, scrollDispatcher, ngZone);
  }
  ngAfterContentInit() {
    this._container._contentMarginChanges.subscribe(() => {
      this._changeDetectorRef.markForCheck();
    });
  }
  /** Determines whether the content element should be hidden from the user. */
  _shouldBeHidden() {
    if (this._platform.isBrowser) {
      return false;
    }
    const {
      start,
      end
    } = this._container;
    return start != null && start.mode !== "over" && start.opened || end != null && end.mode !== "over" && end.opened;
  }
  static \u0275fac = function MatDrawerContent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatDrawerContent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _MatDrawerContent,
    selectors: [["mat-drawer-content"]],
    hostAttrs: [1, "mat-drawer-content"],
    hostVars: 6,
    hostBindings: function MatDrawerContent_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275styleProp("margin-left", ctx._container._contentMargins.left, "px")("margin-right", ctx._container._contentMargins.right, "px");
        \u0275\u0275classProp("mat-drawer-content-hidden", ctx._shouldBeHidden());
      }
    },
    features: [\u0275\u0275ProvidersFeature([{
      provide: CdkScrollable,
      useExisting: _MatDrawerContent
    }]), \u0275\u0275InheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function MatDrawerContent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275projectionDef();
        \u0275\u0275projection(0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatDrawerContent, [{
    type: Component,
    args: [{
      selector: "mat-drawer-content",
      template: "<ng-content></ng-content>",
      host: {
        "class": "mat-drawer-content",
        "[style.margin-left.px]": "_container._contentMargins.left",
        "[style.margin-right.px]": "_container._contentMargins.right",
        "[class.mat-drawer-content-hidden]": "_shouldBeHidden()"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      providers: [{
        provide: CdkScrollable,
        useExisting: MatDrawerContent
      }]
    }]
  }], () => [], null);
})();
var MatDrawer = class _MatDrawer {
  _elementRef = inject(ElementRef);
  _focusTrapFactory = inject(FocusTrapFactory);
  _focusMonitor = inject(FocusMonitor);
  _platform = inject(Platform);
  _ngZone = inject(NgZone);
  _renderer = inject(Renderer2);
  _interactivityChecker = inject(InteractivityChecker);
  _doc = inject(DOCUMENT, {
    optional: true
  });
  _container = inject(MAT_DRAWER_CONTAINER, {
    optional: true
  });
  _focusTrap = null;
  _elementFocusedBeforeDrawerWasOpened = null;
  _eventCleanups;
  /** Whether the view of the component has been attached. */
  _isAttached;
  /** Anchor node used to restore the drawer to its initial position. */
  _anchor;
  /** The side that the drawer is attached to. */
  get position() {
    return this._position;
  }
  set position(value) {
    value = value === "end" ? "end" : "start";
    if (value !== this._position) {
      if (this._isAttached) {
        this._updatePositionInParent(value);
      }
      this._position = value;
      this.onPositionChanged.emit();
    }
  }
  _position = "start";
  /** Mode of the drawer; one of 'over', 'push' or 'side'. */
  get mode() {
    return this._mode;
  }
  set mode(value) {
    this._mode = value;
    this._updateFocusTrapState();
    this._modeChanged.next();
  }
  _mode = "over";
  /** Whether the drawer can be closed with the escape key or by clicking on the backdrop. */
  get disableClose() {
    return this._disableClose;
  }
  set disableClose(value) {
    this._disableClose = coerceBooleanProperty(value);
  }
  _disableClose = false;
  /**
   * Whether the drawer should focus the first focusable element automatically when opened.
   * Defaults to false in when `mode` is set to `side`, otherwise defaults to `true`. If explicitly
   * enabled, focus will be moved into the sidenav in `side` mode as well.
   * @breaking-change 14.0.0 Remove boolean option from autoFocus. Use string or AutoFocusTarget
   * instead.
   */
  get autoFocus() {
    const value = this._autoFocus;
    if (value == null) {
      if (this.mode === "side") {
        return "dialog";
      } else {
        return "first-tabbable";
      }
    }
    return value;
  }
  set autoFocus(value) {
    if (value === "true" || value === "false" || value == null) {
      value = coerceBooleanProperty(value);
    }
    this._autoFocus = value;
  }
  _autoFocus;
  /**
   * Whether the drawer is opened. We overload this because we trigger an event when it
   * starts or end.
   */
  get opened() {
    return this._opened;
  }
  set opened(value) {
    this.toggle(coerceBooleanProperty(value));
  }
  _opened = false;
  /** How the sidenav was opened (keypress, mouse click etc.) */
  _openedVia;
  /** Emits whenever the drawer has started animating. */
  _animationStarted = new Subject();
  /** Emits whenever the drawer is done animating. */
  _animationEnd = new Subject();
  /** Event emitted when the drawer open state is changed. */
  openedChange = (
    // Note this has to be async in order to avoid some issues with two-bindings (see #8872).
    new EventEmitter(
      /* isAsync */
      true
    )
  );
  /** Event emitted when the drawer has been opened. */
  _openedStream = this.openedChange.pipe(filter((o) => o), map(() => {
  }));
  /** Event emitted when the drawer has started opening. */
  openedStart = this._animationStarted.pipe(filter(() => this.opened), mapTo(void 0));
  /** Event emitted when the drawer has been closed. */
  _closedStream = this.openedChange.pipe(filter((o) => !o), map(() => {
  }));
  /** Event emitted when the drawer has started closing. */
  closedStart = this._animationStarted.pipe(filter(() => !this.opened), mapTo(void 0));
  /** Emits when the component is destroyed. */
  _destroyed = new Subject();
  /** Event emitted when the drawer's position changes. */
  // tslint:disable-next-line:no-output-on-prefix
  onPositionChanged = new EventEmitter();
  /** Reference to the inner element that contains all the content. */
  _content;
  /**
   * An observable that emits when the drawer mode changes. This is used by the drawer container to
   * to know when to when the mode changes so it can adapt the margins on the content.
   */
  _modeChanged = new Subject();
  _injector = inject(Injector);
  _changeDetectorRef = inject(ChangeDetectorRef);
  constructor() {
    this.openedChange.pipe(takeUntil(this._destroyed)).subscribe((opened) => {
      if (opened) {
        if (this._doc) {
          this._elementFocusedBeforeDrawerWasOpened = this._doc.activeElement;
        }
        this._takeFocus();
      } else if (this._isFocusWithinDrawer()) {
        this._restoreFocus(this._openedVia || "program");
      }
    });
    this._ngZone.runOutsideAngular(() => {
      const element = this._elementRef.nativeElement;
      fromEvent(element, "keydown").pipe(filter((event) => {
        return event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event);
      }), takeUntil(this._destroyed)).subscribe((event) => this._ngZone.run(() => {
        this.close();
        event.stopPropagation();
        event.preventDefault();
      }));
      this._eventCleanups = [this._renderer.listen(element, "transitionrun", this._handleTransitionEvent), this._renderer.listen(element, "transitionend", this._handleTransitionEvent), this._renderer.listen(element, "transitioncancel", this._handleTransitionEvent)];
    });
    this._animationEnd.subscribe(() => {
      this.openedChange.emit(this._opened);
    });
  }
  /**
   * Focuses the provided element. If the element is not focusable, it will add a tabIndex
   * attribute to forcefully focus it. The attribute is removed after focus is moved.
   * @param element The element to focus.
   */
  _forceFocus(element, options) {
    if (!this._interactivityChecker.isFocusable(element)) {
      element.tabIndex = -1;
      this._ngZone.runOutsideAngular(() => {
        const callback = () => {
          cleanupBlur();
          cleanupMousedown();
          element.removeAttribute("tabindex");
        };
        const cleanupBlur = this._renderer.listen(element, "blur", callback);
        const cleanupMousedown = this._renderer.listen(element, "mousedown", callback);
      });
    }
    element.focus(options);
  }
  /**
   * Focuses the first element that matches the given selector within the focus trap.
   * @param selector The CSS selector for the element to set focus to.
   */
  _focusByCssSelector(selector, options) {
    let elementToFocus = this._elementRef.nativeElement.querySelector(selector);
    if (elementToFocus) {
      this._forceFocus(elementToFocus, options);
    }
  }
  /**
   * Moves focus into the drawer. Note that this works even if
   * the focus trap is disabled in `side` mode.
   */
  _takeFocus() {
    if (!this._focusTrap) {
      return;
    }
    const element = this._elementRef.nativeElement;
    switch (this.autoFocus) {
      case false:
      case "dialog":
        return;
      case true:
      case "first-tabbable":
        afterNextRender(() => {
          const hasMovedFocus = this._focusTrap.focusInitialElement();
          if (!hasMovedFocus && typeof element.focus === "function") {
            element.focus();
          }
        }, {
          injector: this._injector
        });
        break;
      case "first-heading":
        this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role="heading"]');
        break;
      default:
        this._focusByCssSelector(this.autoFocus);
        break;
    }
  }
  /**
   * Restores focus to the element that was originally focused when the drawer opened.
   * If no element was focused at that time, the focus will be restored to the drawer.
   */
  _restoreFocus(focusOrigin) {
    if (this.autoFocus === "dialog") {
      return;
    }
    if (this._elementFocusedBeforeDrawerWasOpened) {
      this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, focusOrigin);
    } else {
      this._elementRef.nativeElement.blur();
    }
    this._elementFocusedBeforeDrawerWasOpened = null;
  }
  /** Whether focus is currently within the drawer. */
  _isFocusWithinDrawer() {
    const activeEl = this._doc.activeElement;
    return !!activeEl && this._elementRef.nativeElement.contains(activeEl);
  }
  ngAfterViewInit() {
    this._isAttached = true;
    if (this._position === "end") {
      this._updatePositionInParent("end");
    }
    if (this._platform.isBrowser) {
      this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);
      this._updateFocusTrapState();
    }
  }
  ngOnDestroy() {
    this._eventCleanups.forEach((cleanup) => cleanup());
    this._focusTrap?.destroy();
    this._anchor?.remove();
    this._anchor = null;
    this._animationStarted.complete();
    this._animationEnd.complete();
    this._modeChanged.complete();
    this._destroyed.next();
    this._destroyed.complete();
  }
  /**
   * Open the drawer.
   * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.
   * Used for focus management after the sidenav is closed.
   */
  open(openedVia) {
    return this.toggle(true, openedVia);
  }
  /** Close the drawer. */
  close() {
    return this.toggle(false);
  }
  /** Closes the drawer with context that the backdrop was clicked. */
  _closeViaBackdropClick() {
    return this._setOpen(
      /* isOpen */
      false,
      /* restoreFocus */
      true,
      "mouse"
    );
  }
  /**
   * Toggle this drawer.
   * @param isOpen Whether the drawer should be open.
   * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.
   * Used for focus management after the sidenav is closed.
   */
  toggle(isOpen = !this.opened, openedVia) {
    if (isOpen && openedVia) {
      this._openedVia = openedVia;
    }
    const result = this._setOpen(
      isOpen,
      /* restoreFocus */
      !isOpen && this._isFocusWithinDrawer(),
      this._openedVia || "program"
    );
    if (!isOpen) {
      this._openedVia = null;
    }
    return result;
  }
  /**
   * Toggles the opened state of the drawer.
   * @param isOpen Whether the drawer should open or close.
   * @param restoreFocus Whether focus should be restored on close.
   * @param focusOrigin Origin to use when restoring focus.
   */
  _setOpen(isOpen, restoreFocus, focusOrigin) {
    if (isOpen === this._opened) {
      return Promise.resolve(isOpen ? "open" : "close");
    }
    this._opened = isOpen;
    if (this._container?._transitionsEnabled) {
      this._setIsAnimating(true);
    } else {
      setTimeout(() => {
        this._animationStarted.next();
        this._animationEnd.next();
      });
    }
    this._elementRef.nativeElement.classList.toggle("mat-drawer-opened", isOpen);
    if (!isOpen && restoreFocus) {
      this._restoreFocus(focusOrigin);
    }
    this._changeDetectorRef.markForCheck();
    this._updateFocusTrapState();
    return new Promise((resolve) => {
      this.openedChange.pipe(take(1)).subscribe((open) => resolve(open ? "open" : "close"));
    });
  }
  /** Toggles whether the drawer is currently animating. */
  _setIsAnimating(isAnimating) {
    this._elementRef.nativeElement.classList.toggle("mat-drawer-animating", isAnimating);
  }
  _getWidth() {
    return this._elementRef.nativeElement.offsetWidth || 0;
  }
  /** Updates the enabled state of the focus trap. */
  _updateFocusTrapState() {
    if (this._focusTrap) {
      this._focusTrap.enabled = !!this._container?.hasBackdrop && this.opened;
    }
  }
  /**
   * Updates the position of the drawer in the DOM. We need to move the element around ourselves
   * when it's in the `end` position so that it comes after the content and the visual order
   * matches the tab order. We also need to be able to move it back to `start` if the sidenav
   * started off as `end` and was changed to `start`.
   */
  _updatePositionInParent(newPosition) {
    if (!this._platform.isBrowser) {
      return;
    }
    const element = this._elementRef.nativeElement;
    const parent = element.parentNode;
    if (newPosition === "end") {
      if (!this._anchor) {
        this._anchor = this._doc.createComment("mat-drawer-anchor");
        parent.insertBefore(this._anchor, element);
      }
      parent.appendChild(element);
    } else if (this._anchor) {
      this._anchor.parentNode.insertBefore(element, this._anchor);
    }
  }
  /** Event handler for animation events. */
  _handleTransitionEvent = (event) => {
    const element = this._elementRef.nativeElement;
    if (event.target === element) {
      this._ngZone.run(() => {
        if (event.type === "transitionrun") {
          this._animationStarted.next(event);
        } else {
          if (event.type === "transitionend") {
            this._setIsAnimating(false);
          }
          this._animationEnd.next(event);
        }
      });
    }
  };
  static \u0275fac = function MatDrawer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatDrawer)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _MatDrawer,
    selectors: [["mat-drawer"]],
    viewQuery: function MatDrawer_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c1, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx._content = _t.first);
      }
    },
    hostAttrs: [1, "mat-drawer"],
    hostVars: 12,
    hostBindings: function MatDrawer_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("align", null)("tabIndex", ctx.mode !== "side" ? "-1" : null);
        \u0275\u0275styleProp("visibility", !ctx._container && !ctx.opened ? "hidden" : null);
        \u0275\u0275classProp("mat-drawer-end", ctx.position === "end")("mat-drawer-over", ctx.mode === "over")("mat-drawer-push", ctx.mode === "push")("mat-drawer-side", ctx.mode === "side");
      }
    },
    inputs: {
      position: "position",
      mode: "mode",
      disableClose: "disableClose",
      autoFocus: "autoFocus",
      opened: "opened"
    },
    outputs: {
      openedChange: "openedChange",
      _openedStream: "opened",
      openedStart: "openedStart",
      _closedStream: "closed",
      closedStart: "closedStart",
      onPositionChanged: "positionChanged"
    },
    exportAs: ["matDrawer"],
    ngContentSelectors: _c0,
    decls: 3,
    vars: 0,
    consts: [["content", ""], ["cdkScrollable", "", 1, "mat-drawer-inner-container"]],
    template: function MatDrawer_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275projectionDef();
        \u0275\u0275elementStart(0, "div", 1, 0);
        \u0275\u0275projection(2);
        \u0275\u0275elementEnd();
      }
    },
    dependencies: [CdkScrollable],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatDrawer, [{
    type: Component,
    args: [{
      selector: "mat-drawer",
      exportAs: "matDrawer",
      host: {
        "class": "mat-drawer",
        // must prevent the browser from aligning text based on value
        "[attr.align]": "null",
        "[class.mat-drawer-end]": 'position === "end"',
        "[class.mat-drawer-over]": 'mode === "over"',
        "[class.mat-drawer-push]": 'mode === "push"',
        "[class.mat-drawer-side]": 'mode === "side"',
        // The styles that render the sidenav off-screen come from the drawer container. Prior to #30235
        // this was also done by the animations module which some internal tests seem to depend on.
        // Simulate it by toggling the `hidden` attribute instead.
        "[style.visibility]": '(!_container && !opened) ? "hidden" : null',
        // The sidenav container should not be focused on when used in side mode. See b/286459024 for
        // reference. Updates tabIndex of drawer/container to default to null if in side mode.
        "[attr.tabIndex]": '(mode !== "side") ? "-1" : null'
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      imports: [CdkScrollable],
      template: '<div class="mat-drawer-inner-container" cdkScrollable #content>\r\n  <ng-content></ng-content>\r\n</div>\r\n'
    }]
  }], () => [], {
    position: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    disableClose: [{
      type: Input
    }],
    autoFocus: [{
      type: Input
    }],
    opened: [{
      type: Input
    }],
    openedChange: [{
      type: Output
    }],
    _openedStream: [{
      type: Output,
      args: ["opened"]
    }],
    openedStart: [{
      type: Output
    }],
    _closedStream: [{
      type: Output,
      args: ["closed"]
    }],
    closedStart: [{
      type: Output
    }],
    onPositionChanged: [{
      type: Output,
      args: ["positionChanged"]
    }],
    _content: [{
      type: ViewChild,
      args: ["content"]
    }]
  });
})();
var MatDrawerContainer = class _MatDrawerContainer {
  _dir = inject(Directionality, {
    optional: true
  });
  _element = inject(ElementRef);
  _ngZone = inject(NgZone);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _animationMode = inject(ANIMATION_MODULE_TYPE, {
    optional: true
  });
  _transitionsEnabled = false;
  /** All drawers in the container. Includes drawers from inside nested containers. */
  _allDrawers;
  /** Drawers that belong to this container. */
  _drawers = new QueryList();
  _content;
  _userContent;
  /** The drawer child with the `start` position. */
  get start() {
    return this._start;
  }
  /** The drawer child with the `end` position. */
  get end() {
    return this._end;
  }
  /**
   * Whether to automatically resize the container whenever
   * the size of any of its drawers changes.
   *
   * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring
   * the drawers on every change detection cycle. Can be configured globally via the
   * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.
   */
  get autosize() {
    return this._autosize;
  }
  set autosize(value) {
    this._autosize = coerceBooleanProperty(value);
  }
  _autosize = inject(MAT_DRAWER_DEFAULT_AUTOSIZE);
  /**
   * Whether the drawer container should have a backdrop while one of the sidenavs is open.
   * If explicitly set to `true`, the backdrop will be enabled for drawers in the `side`
   * mode as well.
   */
  get hasBackdrop() {
    return this._drawerHasBackdrop(this._start) || this._drawerHasBackdrop(this._end);
  }
  set hasBackdrop(value) {
    this._backdropOverride = value == null ? null : coerceBooleanProperty(value);
  }
  _backdropOverride;
  /** Event emitted when the drawer backdrop is clicked. */
  backdropClick = new EventEmitter();
  /** The drawer at the start/end position, independent of direction. */
  _start;
  _end;
  /**
   * The drawer at the left/right. When direction changes, these will change as well.
   * They're used as aliases for the above to set the left/right style properly.
   * In LTR, _left == _start and _right == _end.
   * In RTL, _left == _end and _right == _start.
   */
  _left;
  _right;
  /** Emits when the component is destroyed. */
  _destroyed = new Subject();
  /** Emits on every ngDoCheck. Used for debouncing reflows. */
  _doCheckSubject = new Subject();
  /**
   * Margins to be applied to the content. These are used to push / shrink the drawer content when a
   * drawer is open. We use margin rather than transform even for push mode because transform breaks
   * fixed position elements inside of the transformed element.
   */
  _contentMargins = {
    left: null,
    right: null
  };
  _contentMarginChanges = new Subject();
  /** Reference to the CdkScrollable instance that wraps the scrollable content. */
  get scrollable() {
    return this._userContent || this._content;
  }
  _injector = inject(Injector);
  constructor() {
    const platform = inject(Platform);
    const viewportRuler = inject(ViewportRuler);
    this._dir?.change.pipe(takeUntil(this._destroyed)).subscribe(() => {
      this._validateDrawers();
      this.updateContentMargins();
    });
    viewportRuler.change().pipe(takeUntil(this._destroyed)).subscribe(() => this.updateContentMargins());
    if (this._animationMode !== "NoopAnimations" && platform.isBrowser) {
      this._ngZone.runOutsideAngular(() => {
        setTimeout(() => {
          this._element.nativeElement.classList.add("mat-drawer-transition");
          this._transitionsEnabled = true;
        }, 200);
      });
    }
  }
  ngAfterContentInit() {
    this._allDrawers.changes.pipe(startWith(this._allDrawers), takeUntil(this._destroyed)).subscribe((drawer) => {
      this._drawers.reset(drawer.filter((item) => !item._container || item._container === this));
      this._drawers.notifyOnChanges();
    });
    this._drawers.changes.pipe(startWith(null)).subscribe(() => {
      this._validateDrawers();
      this._drawers.forEach((drawer) => {
        this._watchDrawerToggle(drawer);
        this._watchDrawerPosition(drawer);
        this._watchDrawerMode(drawer);
      });
      if (!this._drawers.length || this._isDrawerOpen(this._start) || this._isDrawerOpen(this._end)) {
        this.updateContentMargins();
      }
      this._changeDetectorRef.markForCheck();
    });
    this._ngZone.runOutsideAngular(() => {
      this._doCheckSubject.pipe(
        debounceTime(10),
        // Arbitrary debounce time, less than a frame at 60fps
        takeUntil(this._destroyed)
      ).subscribe(() => this.updateContentMargins());
    });
  }
  ngOnDestroy() {
    this._contentMarginChanges.complete();
    this._doCheckSubject.complete();
    this._drawers.destroy();
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Calls `open` of both start and end drawers */
  open() {
    this._drawers.forEach((drawer) => drawer.open());
  }
  /** Calls `close` of both start and end drawers */
  close() {
    this._drawers.forEach((drawer) => drawer.close());
  }
  /**
   * Recalculates and updates the inline styles for the content. Note that this should be used
   * sparingly, because it causes a reflow.
   */
  updateContentMargins() {
    let left = 0;
    let right = 0;
    if (this._left && this._left.opened) {
      if (this._left.mode == "side") {
        left += this._left._getWidth();
      } else if (this._left.mode == "push") {
        const width = this._left._getWidth();
        left += width;
        right -= width;
      }
    }
    if (this._right && this._right.opened) {
      if (this._right.mode == "side") {
        right += this._right._getWidth();
      } else if (this._right.mode == "push") {
        const width = this._right._getWidth();
        right += width;
        left -= width;
      }
    }
    left = left || null;
    right = right || null;
    if (left !== this._contentMargins.left || right !== this._contentMargins.right) {
      this._contentMargins = {
        left,
        right
      };
      this._ngZone.run(() => this._contentMarginChanges.next(this._contentMargins));
    }
  }
  ngDoCheck() {
    if (this._autosize && this._isPushed()) {
      this._ngZone.runOutsideAngular(() => this._doCheckSubject.next());
    }
  }
  /**
   * Subscribes to drawer events in order to set a class on the main container element when the
   * drawer is open and the backdrop is visible. This ensures any overflow on the container element
   * is properly hidden.
   */
  _watchDrawerToggle(drawer) {
    drawer._animationStarted.pipe(takeUntil(this._drawers.changes)).subscribe(() => {
      this.updateContentMargins();
      this._changeDetectorRef.markForCheck();
    });
    if (drawer.mode !== "side") {
      drawer.openedChange.pipe(takeUntil(this._drawers.changes)).subscribe(() => this._setContainerClass(drawer.opened));
    }
  }
  /**
   * Subscribes to drawer onPositionChanged event in order to
   * re-validate drawers when the position changes.
   */
  _watchDrawerPosition(drawer) {
    drawer.onPositionChanged.pipe(takeUntil(this._drawers.changes)).subscribe(() => {
      afterNextRender({
        read: () => this._validateDrawers()
      }, {
        injector: this._injector
      });
    });
  }
  /** Subscribes to changes in drawer mode so we can run change detection. */
  _watchDrawerMode(drawer) {
    drawer._modeChanged.pipe(takeUntil(merge(this._drawers.changes, this._destroyed))).subscribe(() => {
      this.updateContentMargins();
      this._changeDetectorRef.markForCheck();
    });
  }
  /** Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element. */
  _setContainerClass(isAdd) {
    const classList = this._element.nativeElement.classList;
    const className = "mat-drawer-container-has-open";
    if (isAdd) {
      classList.add(className);
    } else {
      classList.remove(className);
    }
  }
  /** Validate the state of the drawer children components. */
  _validateDrawers() {
    this._start = this._end = null;
    this._drawers.forEach((drawer) => {
      if (drawer.position == "end") {
        if (this._end != null && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throwMatDuplicatedDrawerError("end");
        }
        this._end = drawer;
      } else {
        if (this._start != null && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throwMatDuplicatedDrawerError("start");
        }
        this._start = drawer;
      }
    });
    this._right = this._left = null;
    if (this._dir && this._dir.value === "rtl") {
      this._left = this._end;
      this._right = this._start;
    } else {
      this._left = this._start;
      this._right = this._end;
    }
  }
  /** Whether the container is being pushed to the side by one of the drawers. */
  _isPushed() {
    return this._isDrawerOpen(this._start) && this._start.mode != "over" || this._isDrawerOpen(this._end) && this._end.mode != "over";
  }
  _onBackdropClicked() {
    this.backdropClick.emit();
    this._closeModalDrawersViaBackdrop();
  }
  _closeModalDrawersViaBackdrop() {
    [this._start, this._end].filter((drawer) => drawer && !drawer.disableClose && this._drawerHasBackdrop(drawer)).forEach((drawer) => drawer._closeViaBackdropClick());
  }
  _isShowingBackdrop() {
    return this._isDrawerOpen(this._start) && this._drawerHasBackdrop(this._start) || this._isDrawerOpen(this._end) && this._drawerHasBackdrop(this._end);
  }
  _isDrawerOpen(drawer) {
    return drawer != null && drawer.opened;
  }
  // Whether argument drawer should have a backdrop when it opens
  _drawerHasBackdrop(drawer) {
    if (this._backdropOverride == null) {
      return !!drawer && drawer.mode !== "side";
    }
    return this._backdropOverride;
  }
  static \u0275fac = function MatDrawerContainer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatDrawerContainer)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _MatDrawerContainer,
    selectors: [["mat-drawer-container"]],
    contentQueries: function MatDrawerContainer_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, MatDrawerContent, 5);
        \u0275\u0275contentQuery(dirIndex, MatDrawer, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx._content = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx._allDrawers = _t);
      }
    },
    viewQuery: function MatDrawerContainer_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(MatDrawerContent, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx._userContent = _t.first);
      }
    },
    hostAttrs: [1, "mat-drawer-container"],
    hostVars: 2,
    hostBindings: function MatDrawerContainer_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("mat-drawer-container-explicit-backdrop", ctx._backdropOverride);
      }
    },
    inputs: {
      autosize: "autosize",
      hasBackdrop: "hasBackdrop"
    },
    outputs: {
      backdropClick: "backdropClick"
    },
    exportAs: ["matDrawerContainer"],
    features: [\u0275\u0275ProvidersFeature([{
      provide: MAT_DRAWER_CONTAINER,
      useExisting: _MatDrawerContainer
    }])],
    ngContentSelectors: _c3,
    decls: 4,
    vars: 2,
    consts: [[1, "mat-drawer-backdrop", 3, "mat-drawer-shown"], [1, "mat-drawer-backdrop", 3, "click"]],
    template: function MatDrawerContainer_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275projectionDef(_c2);
        \u0275\u0275template(0, MatDrawerContainer_Conditional_0_Template, 1, 2, "div", 0);
        \u0275\u0275projection(1);
        \u0275\u0275projection(2, 1);
        \u0275\u0275template(3, MatDrawerContainer_Conditional_3_Template, 2, 0, "mat-drawer-content");
      }
      if (rf & 2) {
        \u0275\u0275conditional(ctx.hasBackdrop ? 0 : -1);
        \u0275\u0275advance(3);
        \u0275\u0275conditional(!ctx._content ? 3 : -1);
      }
    },
    dependencies: [MatDrawerContent],
    styles: [".mat-drawer-container{position:relative;z-index:1;color:var(--mat-sidenav-content-text-color, var(--mat-sys-on-background));background-color:var(--mat-sidenav-content-background-color, var(--mat-sys-background));box-sizing:border-box;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible;background-color:var(--mat-sidenav-scrim-color, color-mix(in srgb, var(--mat-sys-neutral-variant20) 40%, transparent))}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}@media(forced-colors: active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-content.mat-drawer-content-hidden{opacity:0}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;color:var(--mat-sidenav-container-text-color, var(--mat-sys-on-surface-variant));box-shadow:var(--mat-sidenav-container-elevation-shadow, none);background-color:var(--mat-sidenav-container-background-color, var(--mat-sys-surface));border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));width:var(--mat-sidenav-container-width, 360px);display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}@media(forced-colors: active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media(forced-colors: active){[dir=rtl] .mat-drawer,.mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0);border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl] .mat-drawer{border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-left-radius:0;border-bottom-left-radius:0;left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-transition .mat-drawer{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating){visibility:hidden;box-shadow:none}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating) .mat-drawer-inner-container{display:none}.mat-drawer.mat-drawer-opened.mat-drawer-opened{transform:none}.mat-drawer-side{box-shadow:none;border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid}.mat-drawer-side.mat-drawer-end{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid;border-left:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto}.mat-sidenav-fixed{position:fixed}\n"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatDrawerContainer, [{
    type: Component,
    args: [{
      selector: "mat-drawer-container",
      exportAs: "matDrawerContainer",
      host: {
        "class": "mat-drawer-container",
        "[class.mat-drawer-container-explicit-backdrop]": "_backdropOverride"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      providers: [{
        provide: MAT_DRAWER_CONTAINER,
        useExisting: MatDrawerContainer
      }],
      imports: [MatDrawerContent],
      template: '@if (hasBackdrop) {\n  <div class="mat-drawer-backdrop" (click)="_onBackdropClicked()"\n       [class.mat-drawer-shown]="_isShowingBackdrop()"></div>\n}\n\n<ng-content select="mat-drawer"></ng-content>\n\n<ng-content select="mat-drawer-content">\n</ng-content>\n\n@if (!_content) {\n  <mat-drawer-content>\n    <ng-content></ng-content>\n  </mat-drawer-content>\n}\n',
      styles: [".mat-drawer-container{position:relative;z-index:1;color:var(--mat-sidenav-content-text-color, var(--mat-sys-on-background));background-color:var(--mat-sidenav-content-background-color, var(--mat-sys-background));box-sizing:border-box;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible;background-color:var(--mat-sidenav-scrim-color, color-mix(in srgb, var(--mat-sys-neutral-variant20) 40%, transparent))}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}@media(forced-colors: active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-content.mat-drawer-content-hidden{opacity:0}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;color:var(--mat-sidenav-container-text-color, var(--mat-sys-on-surface-variant));box-shadow:var(--mat-sidenav-container-elevation-shadow, none);background-color:var(--mat-sidenav-container-background-color, var(--mat-sys-surface));border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));width:var(--mat-sidenav-container-width, 360px);display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}@media(forced-colors: active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media(forced-colors: active){[dir=rtl] .mat-drawer,.mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0);border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl] .mat-drawer{border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-left-radius:0;border-bottom-left-radius:0;left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-transition .mat-drawer{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating){visibility:hidden;box-shadow:none}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating) .mat-drawer-inner-container{display:none}.mat-drawer.mat-drawer-opened.mat-drawer-opened{transform:none}.mat-drawer-side{box-shadow:none;border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid}.mat-drawer-side.mat-drawer-end{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid;border-left:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto}.mat-sidenav-fixed{position:fixed}\n"]
    }]
  }], () => [], {
    _allDrawers: [{
      type: ContentChildren,
      args: [MatDrawer, {
        // We need to use `descendants: true`, because Ivy will no longer match
        // indirect descendants if it's left as false.
        descendants: true
      }]
    }],
    _content: [{
      type: ContentChild,
      args: [MatDrawerContent]
    }],
    _userContent: [{
      type: ViewChild,
      args: [MatDrawerContent]
    }],
    autosize: [{
      type: Input
    }],
    hasBackdrop: [{
      type: Input
    }],
    backdropClick: [{
      type: Output
    }]
  });
})();
var MatSidenavContent = class _MatSidenavContent extends MatDrawerContent {
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275MatSidenavContent_BaseFactory;
    return function MatSidenavContent_Factory(__ngFactoryType__) {
      return (\u0275MatSidenavContent_BaseFactory || (\u0275MatSidenavContent_BaseFactory = \u0275\u0275getInheritedFactory(_MatSidenavContent)))(__ngFactoryType__ || _MatSidenavContent);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _MatSidenavContent,
    selectors: [["mat-sidenav-content"]],
    hostAttrs: [1, "mat-drawer-content", "mat-sidenav-content"],
    features: [\u0275\u0275ProvidersFeature([{
      provide: CdkScrollable,
      useExisting: _MatSidenavContent
    }]), \u0275\u0275InheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function MatSidenavContent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275projectionDef();
        \u0275\u0275projection(0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSidenavContent, [{
    type: Component,
    args: [{
      selector: "mat-sidenav-content",
      template: "<ng-content></ng-content>",
      host: {
        "class": "mat-drawer-content mat-sidenav-content"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      providers: [{
        provide: CdkScrollable,
        useExisting: MatSidenavContent
      }]
    }]
  }], null, null);
})();
var MatSidenav = class _MatSidenav extends MatDrawer {
  /** Whether the sidenav is fixed in the viewport. */
  get fixedInViewport() {
    return this._fixedInViewport;
  }
  set fixedInViewport(value) {
    this._fixedInViewport = coerceBooleanProperty(value);
  }
  _fixedInViewport = false;
  /**
   * The gap between the top of the sidenav and the top of the viewport when the sidenav is in fixed
   * mode.
   */
  get fixedTopGap() {
    return this._fixedTopGap;
  }
  set fixedTopGap(value) {
    this._fixedTopGap = coerceNumberProperty(value);
  }
  _fixedTopGap = 0;
  /**
   * The gap between the bottom of the sidenav and the bottom of the viewport when the sidenav is in
   * fixed mode.
   */
  get fixedBottomGap() {
    return this._fixedBottomGap;
  }
  set fixedBottomGap(value) {
    this._fixedBottomGap = coerceNumberProperty(value);
  }
  _fixedBottomGap = 0;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275MatSidenav_BaseFactory;
    return function MatSidenav_Factory(__ngFactoryType__) {
      return (\u0275MatSidenav_BaseFactory || (\u0275MatSidenav_BaseFactory = \u0275\u0275getInheritedFactory(_MatSidenav)))(__ngFactoryType__ || _MatSidenav);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _MatSidenav,
    selectors: [["mat-sidenav"]],
    hostAttrs: [1, "mat-drawer", "mat-sidenav"],
    hostVars: 16,
    hostBindings: function MatSidenav_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("tabIndex", ctx.mode !== "side" ? "-1" : null)("align", null);
        \u0275\u0275styleProp("top", ctx.fixedInViewport ? ctx.fixedTopGap : null, "px")("bottom", ctx.fixedInViewport ? ctx.fixedBottomGap : null, "px");
        \u0275\u0275classProp("mat-drawer-end", ctx.position === "end")("mat-drawer-over", ctx.mode === "over")("mat-drawer-push", ctx.mode === "push")("mat-drawer-side", ctx.mode === "side")("mat-sidenav-fixed", ctx.fixedInViewport);
      }
    },
    inputs: {
      fixedInViewport: "fixedInViewport",
      fixedTopGap: "fixedTopGap",
      fixedBottomGap: "fixedBottomGap"
    },
    exportAs: ["matSidenav"],
    features: [\u0275\u0275ProvidersFeature([{
      provide: MatDrawer,
      useExisting: _MatSidenav
    }]), \u0275\u0275InheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 3,
    vars: 0,
    consts: [["content", ""], ["cdkScrollable", "", 1, "mat-drawer-inner-container"]],
    template: function MatSidenav_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275projectionDef();
        \u0275\u0275elementStart(0, "div", 1, 0);
        \u0275\u0275projection(2);
        \u0275\u0275elementEnd();
      }
    },
    dependencies: [CdkScrollable],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSidenav, [{
    type: Component,
    args: [{
      selector: "mat-sidenav",
      exportAs: "matSidenav",
      host: {
        "class": "mat-drawer mat-sidenav",
        // The sidenav container should not be focused on when used in side mode. See b/286459024 for
        // reference. Updates tabIndex of drawer/container to default to null if in side mode.
        "[attr.tabIndex]": '(mode !== "side") ? "-1" : null',
        // must prevent the browser from aligning text based on value
        "[attr.align]": "null",
        "[class.mat-drawer-end]": 'position === "end"',
        "[class.mat-drawer-over]": 'mode === "over"',
        "[class.mat-drawer-push]": 'mode === "push"',
        "[class.mat-drawer-side]": 'mode === "side"',
        "[class.mat-sidenav-fixed]": "fixedInViewport",
        "[style.top.px]": "fixedInViewport ? fixedTopGap : null",
        "[style.bottom.px]": "fixedInViewport ? fixedBottomGap : null"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      imports: [CdkScrollable],
      providers: [{
        provide: MatDrawer,
        useExisting: MatSidenav
      }],
      template: '<div class="mat-drawer-inner-container" cdkScrollable #content>\r\n  <ng-content></ng-content>\r\n</div>\r\n'
    }]
  }], null, {
    fixedInViewport: [{
      type: Input
    }],
    fixedTopGap: [{
      type: Input
    }],
    fixedBottomGap: [{
      type: Input
    }]
  });
})();
var MatSidenavContainer = class _MatSidenavContainer extends MatDrawerContainer {
  _allDrawers = void 0;
  // We need an initializer here to avoid a TS error.
  _content = void 0;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275MatSidenavContainer_BaseFactory;
    return function MatSidenavContainer_Factory(__ngFactoryType__) {
      return (\u0275MatSidenavContainer_BaseFactory || (\u0275MatSidenavContainer_BaseFactory = \u0275\u0275getInheritedFactory(_MatSidenavContainer)))(__ngFactoryType__ || _MatSidenavContainer);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _MatSidenavContainer,
    selectors: [["mat-sidenav-container"]],
    contentQueries: function MatSidenavContainer_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, MatSidenavContent, 5);
        \u0275\u0275contentQuery(dirIndex, MatSidenav, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx._content = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx._allDrawers = _t);
      }
    },
    hostAttrs: [1, "mat-drawer-container", "mat-sidenav-container"],
    hostVars: 2,
    hostBindings: function MatSidenavContainer_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("mat-drawer-container-explicit-backdrop", ctx._backdropOverride);
      }
    },
    exportAs: ["matSidenavContainer"],
    features: [\u0275\u0275ProvidersFeature([{
      provide: MAT_DRAWER_CONTAINER,
      useExisting: _MatSidenavContainer
    }, {
      provide: MatDrawerContainer,
      useExisting: _MatSidenavContainer
    }]), \u0275\u0275InheritDefinitionFeature],
    ngContentSelectors: _c5,
    decls: 4,
    vars: 2,
    consts: [[1, "mat-drawer-backdrop", 3, "mat-drawer-shown"], [1, "mat-drawer-backdrop", 3, "click"]],
    template: function MatSidenavContainer_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275projectionDef(_c4);
        \u0275\u0275template(0, MatSidenavContainer_Conditional_0_Template, 1, 2, "div", 0);
        \u0275\u0275projection(1);
        \u0275\u0275projection(2, 1);
        \u0275\u0275template(3, MatSidenavContainer_Conditional_3_Template, 2, 0, "mat-sidenav-content");
      }
      if (rf & 2) {
        \u0275\u0275conditional(ctx.hasBackdrop ? 0 : -1);
        \u0275\u0275advance(3);
        \u0275\u0275conditional(!ctx._content ? 3 : -1);
      }
    },
    dependencies: [MatSidenavContent],
    styles: [_c6],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSidenavContainer, [{
    type: Component,
    args: [{
      selector: "mat-sidenav-container",
      exportAs: "matSidenavContainer",
      host: {
        "class": "mat-drawer-container mat-sidenav-container",
        "[class.mat-drawer-container-explicit-backdrop]": "_backdropOverride"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      providers: [{
        provide: MAT_DRAWER_CONTAINER,
        useExisting: MatSidenavContainer
      }, {
        provide: MatDrawerContainer,
        useExisting: MatSidenavContainer
      }],
      imports: [MatSidenavContent],
      template: '@if (hasBackdrop) {\n  <div class="mat-drawer-backdrop" (click)="_onBackdropClicked()"\n       [class.mat-drawer-shown]="_isShowingBackdrop()"></div>\n}\n\n<ng-content select="mat-sidenav"></ng-content>\n\n<ng-content select="mat-sidenav-content">\n</ng-content>\n\n@if (!_content) {\n  <mat-sidenav-content>\n    <ng-content></ng-content>\n  </mat-sidenav-content>\n}\n',
      styles: [".mat-drawer-container{position:relative;z-index:1;color:var(--mat-sidenav-content-text-color, var(--mat-sys-on-background));background-color:var(--mat-sidenav-content-background-color, var(--mat-sys-background));box-sizing:border-box;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible;background-color:var(--mat-sidenav-scrim-color, color-mix(in srgb, var(--mat-sys-neutral-variant20) 40%, transparent))}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}@media(forced-colors: active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-content.mat-drawer-content-hidden{opacity:0}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;color:var(--mat-sidenav-container-text-color, var(--mat-sys-on-surface-variant));box-shadow:var(--mat-sidenav-container-elevation-shadow, none);background-color:var(--mat-sidenav-container-background-color, var(--mat-sys-surface));border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));width:var(--mat-sidenav-container-width, 360px);display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}@media(forced-colors: active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media(forced-colors: active){[dir=rtl] .mat-drawer,.mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0);border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl] .mat-drawer{border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-left-radius:0;border-bottom-left-radius:0;left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-transition .mat-drawer{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating){visibility:hidden;box-shadow:none}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating) .mat-drawer-inner-container{display:none}.mat-drawer.mat-drawer-opened.mat-drawer-opened{transform:none}.mat-drawer-side{box-shadow:none;border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid}.mat-drawer-side.mat-drawer-end{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid;border-left:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto}.mat-sidenav-fixed{position:fixed}\n"]
    }]
  }], null, {
    _allDrawers: [{
      type: ContentChildren,
      args: [MatSidenav, {
        // We need to use `descendants: true`, because Ivy will no longer match
        // indirect descendants if it's left as false.
        descendants: true
      }]
    }],
    _content: [{
      type: ContentChild,
      args: [MatSidenavContent]
    }]
  });
})();
var MatSidenavModule = class _MatSidenavModule {
  static \u0275fac = function MatSidenavModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatSidenavModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _MatSidenavModule,
    imports: [MatCommonModule, CdkScrollableModule, MatDrawer, MatDrawerContainer, MatDrawerContent, MatSidenav, MatSidenavContainer, MatSidenavContent],
    exports: [CdkScrollableModule, MatCommonModule, MatDrawer, MatDrawerContainer, MatDrawerContent, MatSidenav, MatSidenavContainer, MatSidenavContent]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [MatCommonModule, CdkScrollableModule, CdkScrollableModule, MatCommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSidenavModule, [{
    type: NgModule,
    args: [{
      imports: [MatCommonModule, CdkScrollableModule, MatDrawer, MatDrawerContainer, MatDrawerContent, MatSidenav, MatSidenavContainer, MatSidenavContent],
      exports: [CdkScrollableModule, MatCommonModule, MatDrawer, MatDrawerContainer, MatDrawerContent, MatSidenav, MatSidenavContainer, MatSidenavContent]
    }]
  }], null, null);
})();

// node_modules/.pnpm/@angular+material@19.2.18_@angular+cdk@19.2.19_@angular+common@19.2.14_@angular+core@19_102b8bfb5e382f9d0615b5538deb6474/node_modules/@angular/material/fesm2022/toolbar.mjs
var _c02 = ["*", [["mat-toolbar-row"]]];
var _c12 = ["*", "mat-toolbar-row"];
var MatToolbarRow = class _MatToolbarRow {
  static \u0275fac = function MatToolbarRow_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatToolbarRow)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _MatToolbarRow,
    selectors: [["mat-toolbar-row"]],
    hostAttrs: [1, "mat-toolbar-row"],
    exportAs: ["matToolbarRow"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatToolbarRow, [{
    type: Directive,
    args: [{
      selector: "mat-toolbar-row",
      exportAs: "matToolbarRow",
      host: {
        "class": "mat-toolbar-row"
      }
    }]
  }], null, null);
})();
var MatToolbar = class _MatToolbar {
  _elementRef = inject(ElementRef);
  _platform = inject(Platform);
  _document = inject(DOCUMENT);
  // TODO: should be typed as `ThemePalette` but internal apps pass in arbitrary strings.
  /**
   * Theme color of the toolbar. This API is supported in M2 themes only, it has
   * no effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/toolbar/styling.
   *
   * For information on applying color variants in M3, see
   * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants
   */
  color;
  /** Reference to all toolbar row elements that have been projected. */
  _toolbarRows;
  constructor() {
  }
  ngAfterViewInit() {
    if (this._platform.isBrowser) {
      this._checkToolbarMixedModes();
      this._toolbarRows.changes.subscribe(() => this._checkToolbarMixedModes());
    }
  }
  /**
   * Throws an exception when developers are attempting to combine the different toolbar row modes.
   */
  _checkToolbarMixedModes() {
    if (this._toolbarRows.length && (typeof ngDevMode === "undefined" || ngDevMode)) {
      const isCombinedUsage = Array.from(this._elementRef.nativeElement.childNodes).filter((node) => !(node.classList && node.classList.contains("mat-toolbar-row"))).filter((node) => node.nodeType !== (this._document ? this._document.COMMENT_NODE : 8)).some((node) => !!(node.textContent && node.textContent.trim()));
      if (isCombinedUsage) {
        throwToolbarMixedModesError();
      }
    }
  }
  static \u0275fac = function MatToolbar_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatToolbar)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _MatToolbar,
    selectors: [["mat-toolbar"]],
    contentQueries: function MatToolbar_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, MatToolbarRow, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx._toolbarRows = _t);
      }
    },
    hostAttrs: [1, "mat-toolbar"],
    hostVars: 6,
    hostBindings: function MatToolbar_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classMap(ctx.color ? "mat-" + ctx.color : "");
        \u0275\u0275classProp("mat-toolbar-multiple-rows", ctx._toolbarRows.length > 0)("mat-toolbar-single-row", ctx._toolbarRows.length === 0);
      }
    },
    inputs: {
      color: "color"
    },
    exportAs: ["matToolbar"],
    ngContentSelectors: _c12,
    decls: 2,
    vars: 0,
    template: function MatToolbar_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275projectionDef(_c02);
        \u0275\u0275projection(0);
        \u0275\u0275projection(1, 1);
      }
    },
    styles: [".mat-toolbar{background:var(--mat-toolbar-container-background-color, var(--mat-sys-surface));color:var(--mat-toolbar-container-text-color, var(--mat-sys-on-surface))}.mat-toolbar,.mat-toolbar h1,.mat-toolbar h2,.mat-toolbar h3,.mat-toolbar h4,.mat-toolbar h5,.mat-toolbar h6{font-family:var(--mat-toolbar-title-text-font, var(--mat-sys-title-large-font));font-size:var(--mat-toolbar-title-text-size, var(--mat-sys-title-large-size));line-height:var(--mat-toolbar-title-text-line-height, var(--mat-sys-title-large-line-height));font-weight:var(--mat-toolbar-title-text-weight, var(--mat-sys-title-large-weight));letter-spacing:var(--mat-toolbar-title-text-tracking, var(--mat-sys-title-large-tracking));margin:0}@media(forced-colors: active){.mat-toolbar{outline:solid 1px}}.mat-toolbar .mat-form-field-underline,.mat-toolbar .mat-form-field-ripple,.mat-toolbar .mat-focused .mat-form-field-ripple{background-color:currentColor}.mat-toolbar .mat-form-field-label,.mat-toolbar .mat-focused .mat-form-field-label,.mat-toolbar .mat-select-value,.mat-toolbar .mat-select-arrow,.mat-toolbar .mat-form-field.mat-focused .mat-select-arrow{color:inherit}.mat-toolbar .mat-input-element{caret-color:currentColor}.mat-toolbar .mat-mdc-button-base.mat-mdc-button-base.mat-unthemed{--mdc-text-button-label-text-color:var(--mat-toolbar-container-text-color, var(--mat-sys-on-surface));--mdc-outlined-button-label-text-color:var(--mat-toolbar-container-text-color, var(--mat-sys-on-surface))}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap;height:var(--mat-toolbar-standard-height, 64px)}@media(max-width: 599px){.mat-toolbar-row,.mat-toolbar-single-row{height:var(--mat-toolbar-mobile-height, 56px)}}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%;min-height:var(--mat-toolbar-standard-height, 64px)}@media(max-width: 599px){.mat-toolbar-multiple-rows{min-height:var(--mat-toolbar-mobile-height, 56px)}}\n"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatToolbar, [{
    type: Component,
    args: [{
      selector: "mat-toolbar",
      exportAs: "matToolbar",
      host: {
        "class": "mat-toolbar",
        "[class]": 'color ? "mat-" + color : ""',
        "[class.mat-toolbar-multiple-rows]": "_toolbarRows.length > 0",
        "[class.mat-toolbar-single-row]": "_toolbarRows.length === 0"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      template: '<ng-content></ng-content>\n<ng-content select="mat-toolbar-row"></ng-content>\n',
      styles: [".mat-toolbar{background:var(--mat-toolbar-container-background-color, var(--mat-sys-surface));color:var(--mat-toolbar-container-text-color, var(--mat-sys-on-surface))}.mat-toolbar,.mat-toolbar h1,.mat-toolbar h2,.mat-toolbar h3,.mat-toolbar h4,.mat-toolbar h5,.mat-toolbar h6{font-family:var(--mat-toolbar-title-text-font, var(--mat-sys-title-large-font));font-size:var(--mat-toolbar-title-text-size, var(--mat-sys-title-large-size));line-height:var(--mat-toolbar-title-text-line-height, var(--mat-sys-title-large-line-height));font-weight:var(--mat-toolbar-title-text-weight, var(--mat-sys-title-large-weight));letter-spacing:var(--mat-toolbar-title-text-tracking, var(--mat-sys-title-large-tracking));margin:0}@media(forced-colors: active){.mat-toolbar{outline:solid 1px}}.mat-toolbar .mat-form-field-underline,.mat-toolbar .mat-form-field-ripple,.mat-toolbar .mat-focused .mat-form-field-ripple{background-color:currentColor}.mat-toolbar .mat-form-field-label,.mat-toolbar .mat-focused .mat-form-field-label,.mat-toolbar .mat-select-value,.mat-toolbar .mat-select-arrow,.mat-toolbar .mat-form-field.mat-focused .mat-select-arrow{color:inherit}.mat-toolbar .mat-input-element{caret-color:currentColor}.mat-toolbar .mat-mdc-button-base.mat-mdc-button-base.mat-unthemed{--mdc-text-button-label-text-color:var(--mat-toolbar-container-text-color, var(--mat-sys-on-surface));--mdc-outlined-button-label-text-color:var(--mat-toolbar-container-text-color, var(--mat-sys-on-surface))}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap;height:var(--mat-toolbar-standard-height, 64px)}@media(max-width: 599px){.mat-toolbar-row,.mat-toolbar-single-row{height:var(--mat-toolbar-mobile-height, 56px)}}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%;min-height:var(--mat-toolbar-standard-height, 64px)}@media(max-width: 599px){.mat-toolbar-multiple-rows{min-height:var(--mat-toolbar-mobile-height, 56px)}}\n"]
    }]
  }], () => [], {
    color: [{
      type: Input
    }],
    _toolbarRows: [{
      type: ContentChildren,
      args: [MatToolbarRow, {
        descendants: true
      }]
    }]
  });
})();
function throwToolbarMixedModesError() {
  throw Error("MatToolbar: Attempting to combine different toolbar modes. Either specify multiple `<mat-toolbar-row>` elements explicitly or just place content inside of a `<mat-toolbar>` for a single row.");
}
var MatToolbarModule = class _MatToolbarModule {
  static \u0275fac = function MatToolbarModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatToolbarModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _MatToolbarModule,
    imports: [MatCommonModule, MatToolbar, MatToolbarRow],
    exports: [MatToolbar, MatToolbarRow, MatCommonModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [MatCommonModule, MatCommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatToolbarModule, [{
    type: NgModule,
    args: [{
      imports: [MatCommonModule, MatToolbar, MatToolbarRow],
      exports: [MatToolbar, MatToolbarRow, MatCommonModule]
    }]
  }], null, null);
})();

// node_modules/.pnpm/@angular+material@19.2.18_@angular+cdk@19.2.19_@angular+common@19.2.14_@angular+core@19_102b8bfb5e382f9d0615b5538deb6474/node_modules/@angular/material/fesm2022/module-C9K6ZqpI.mjs
var _c03 = ["tooltip"];
var SCROLL_THROTTLE_MS = 20;
function getMatTooltipInvalidPositionError(position) {
  return Error(`Tooltip position "${position}" is invalid.`);
}
var MAT_TOOLTIP_SCROLL_STRATEGY = new InjectionToken("mat-tooltip-scroll-strategy", {
  providedIn: "root",
  factory: () => {
    const overlay = inject(Overlay);
    return () => overlay.scrollStrategies.reposition({
      scrollThrottle: SCROLL_THROTTLE_MS
    });
  }
});
function MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY(overlay) {
  return () => overlay.scrollStrategies.reposition({
    scrollThrottle: SCROLL_THROTTLE_MS
  });
}
var MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER = {
  provide: MAT_TOOLTIP_SCROLL_STRATEGY,
  deps: [Overlay],
  useFactory: MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY
};
function MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY() {
  return {
    showDelay: 0,
    hideDelay: 0,
    touchendHideDelay: 1500
  };
}
var MAT_TOOLTIP_DEFAULT_OPTIONS = new InjectionToken("mat-tooltip-default-options", {
  providedIn: "root",
  factory: MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY
});
var PANEL_CLASS = "tooltip-panel";
var passiveListenerOptions = normalizePassiveListenerOptions({
  passive: true
});
var MIN_VIEWPORT_TOOLTIP_THRESHOLD = 8;
var UNBOUNDED_ANCHOR_GAP = 8;
var MIN_HEIGHT = 24;
var MAX_WIDTH = 200;
var MatTooltip = class _MatTooltip {
  _elementRef = inject(ElementRef);
  _ngZone = inject(NgZone);
  _platform = inject(Platform);
  _ariaDescriber = inject(AriaDescriber);
  _focusMonitor = inject(FocusMonitor);
  _dir = inject(Directionality);
  _injector = inject(Injector);
  _viewContainerRef = inject(ViewContainerRef);
  _defaultOptions = inject(MAT_TOOLTIP_DEFAULT_OPTIONS, {
    optional: true
  });
  _overlayRef;
  _tooltipInstance;
  _portal;
  _position = "below";
  _positionAtOrigin = false;
  _disabled = false;
  _tooltipClass;
  _viewInitialized = false;
  _pointerExitEventsInitialized = false;
  _tooltipComponent = TooltipComponent;
  _viewportMargin = 8;
  _currentPosition;
  _cssClassPrefix = "mat-mdc";
  _ariaDescriptionPending;
  _dirSubscribed = false;
  /** Allows the user to define the position of the tooltip relative to the parent element */
  get position() {
    return this._position;
  }
  set position(value) {
    if (value !== this._position) {
      this._position = value;
      if (this._overlayRef) {
        this._updatePosition(this._overlayRef);
        this._tooltipInstance?.show(0);
        this._overlayRef.updatePosition();
      }
    }
  }
  /**
   * Whether tooltip should be relative to the click or touch origin
   * instead of outside the element bounding box.
   */
  get positionAtOrigin() {
    return this._positionAtOrigin;
  }
  set positionAtOrigin(value) {
    this._positionAtOrigin = coerceBooleanProperty(value);
    this._detach();
    this._overlayRef = null;
  }
  /** Disables the display of the tooltip. */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    const isDisabled = coerceBooleanProperty(value);
    if (this._disabled !== isDisabled) {
      this._disabled = isDisabled;
      if (isDisabled) {
        this.hide(0);
      } else {
        this._setupPointerEnterEventsIfNeeded();
      }
      this._syncAriaDescription(this.message);
    }
  }
  /** The default delay in ms before showing the tooltip after show is called */
  get showDelay() {
    return this._showDelay;
  }
  set showDelay(value) {
    this._showDelay = coerceNumberProperty(value);
  }
  _showDelay;
  /** The default delay in ms before hiding the tooltip after hide is called */
  get hideDelay() {
    return this._hideDelay;
  }
  set hideDelay(value) {
    this._hideDelay = coerceNumberProperty(value);
    if (this._tooltipInstance) {
      this._tooltipInstance._mouseLeaveHideDelay = this._hideDelay;
    }
  }
  _hideDelay;
  /**
   * How touch gestures should be handled by the tooltip. On touch devices the tooltip directive
   * uses a long press gesture to show and hide, however it can conflict with the native browser
   * gestures. To work around the conflict, Angular Material disables native gestures on the
   * trigger, but that might not be desirable on particular elements (e.g. inputs and draggable
   * elements). The different values for this option configure the touch event handling as follows:
   * - `auto` - Enables touch gestures for all elements, but tries to avoid conflicts with native
   *   browser gestures on particular elements. In particular, it allows text selection on inputs
   *   and textareas, and preserves the native browser dragging on elements marked as `draggable`.
   * - `on` - Enables touch gestures for all elements and disables native
   *   browser gestures with no exceptions.
   * - `off` - Disables touch gestures. Note that this will prevent the tooltip from
   *   showing on touch devices.
   */
  touchGestures = "auto";
  /** The message to be displayed in the tooltip */
  get message() {
    return this._message;
  }
  set message(value) {
    const oldMessage = this._message;
    this._message = value != null ? String(value).trim() : "";
    if (!this._message && this._isTooltipVisible()) {
      this.hide(0);
    } else {
      this._setupPointerEnterEventsIfNeeded();
      this._updateTooltipMessage();
    }
    this._syncAriaDescription(oldMessage);
  }
  _message = "";
  /** Classes to be passed to the tooltip. Supports the same syntax as `ngClass`. */
  get tooltipClass() {
    return this._tooltipClass;
  }
  set tooltipClass(value) {
    this._tooltipClass = value;
    if (this._tooltipInstance) {
      this._setTooltipClass(this._tooltipClass);
    }
  }
  /** Manually-bound passive event listeners. */
  _passiveListeners = [];
  /** Timer started at the last `touchstart` event. */
  _touchstartTimeout = null;
  /** Emits when the component is destroyed. */
  _destroyed = new Subject();
  /** Whether ngOnDestroyed has been called. */
  _isDestroyed = false;
  constructor() {
    const defaultOptions = this._defaultOptions;
    if (defaultOptions) {
      this._showDelay = defaultOptions.showDelay;
      this._hideDelay = defaultOptions.hideDelay;
      if (defaultOptions.position) {
        this.position = defaultOptions.position;
      }
      if (defaultOptions.positionAtOrigin) {
        this.positionAtOrigin = defaultOptions.positionAtOrigin;
      }
      if (defaultOptions.touchGestures) {
        this.touchGestures = defaultOptions.touchGestures;
      }
      if (defaultOptions.tooltipClass) {
        this.tooltipClass = defaultOptions.tooltipClass;
      }
    }
    this._viewportMargin = MIN_VIEWPORT_TOOLTIP_THRESHOLD;
  }
  ngAfterViewInit() {
    this._viewInitialized = true;
    this._setupPointerEnterEventsIfNeeded();
    this._focusMonitor.monitor(this._elementRef).pipe(takeUntil(this._destroyed)).subscribe((origin) => {
      if (!origin) {
        this._ngZone.run(() => this.hide(0));
      } else if (origin === "keyboard") {
        this._ngZone.run(() => this.show());
      }
    });
  }
  /**
   * Dispose the tooltip when destroyed.
   */
  ngOnDestroy() {
    const nativeElement = this._elementRef.nativeElement;
    if (this._touchstartTimeout) {
      clearTimeout(this._touchstartTimeout);
    }
    if (this._overlayRef) {
      this._overlayRef.dispose();
      this._tooltipInstance = null;
    }
    this._passiveListeners.forEach(([event, listener]) => {
      nativeElement.removeEventListener(event, listener, passiveListenerOptions);
    });
    this._passiveListeners.length = 0;
    this._destroyed.next();
    this._destroyed.complete();
    this._isDestroyed = true;
    this._ariaDescriber.removeDescription(nativeElement, this.message, "tooltip");
    this._focusMonitor.stopMonitoring(nativeElement);
  }
  /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */
  show(delay = this.showDelay, origin) {
    if (this.disabled || !this.message || this._isTooltipVisible()) {
      this._tooltipInstance?._cancelPendingAnimations();
      return;
    }
    const overlayRef = this._createOverlay(origin);
    this._detach();
    this._portal = this._portal || new ComponentPortal(this._tooltipComponent, this._viewContainerRef);
    const instance = this._tooltipInstance = overlayRef.attach(this._portal).instance;
    instance._triggerElement = this._elementRef.nativeElement;
    instance._mouseLeaveHideDelay = this._hideDelay;
    instance.afterHidden().pipe(takeUntil(this._destroyed)).subscribe(() => this._detach());
    this._setTooltipClass(this._tooltipClass);
    this._updateTooltipMessage();
    instance.show(delay);
  }
  /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */
  hide(delay = this.hideDelay) {
    const instance = this._tooltipInstance;
    if (instance) {
      if (instance.isVisible()) {
        instance.hide(delay);
      } else {
        instance._cancelPendingAnimations();
        this._detach();
      }
    }
  }
  /** Shows/hides the tooltip */
  toggle(origin) {
    this._isTooltipVisible() ? this.hide() : this.show(void 0, origin);
  }
  /** Returns true if the tooltip is currently visible to the user */
  _isTooltipVisible() {
    return !!this._tooltipInstance && this._tooltipInstance.isVisible();
  }
  /** Create the overlay config and position strategy */
  _createOverlay(origin) {
    if (this._overlayRef) {
      const existingStrategy = this._overlayRef.getConfig().positionStrategy;
      if ((!this.positionAtOrigin || !origin) && existingStrategy._origin instanceof ElementRef) {
        return this._overlayRef;
      }
      this._detach();
    }
    const scrollableAncestors = this._injector.get(ScrollDispatcher).getAncestorScrollContainers(this._elementRef);
    const overlay = this._injector.get(Overlay);
    const strategy = overlay.position().flexibleConnectedTo(this.positionAtOrigin ? origin || this._elementRef : this._elementRef).withTransformOriginOn(`.${this._cssClassPrefix}-tooltip`).withFlexibleDimensions(false).withViewportMargin(this._viewportMargin).withScrollableContainers(scrollableAncestors);
    strategy.positionChanges.pipe(takeUntil(this._destroyed)).subscribe((change) => {
      this._updateCurrentPositionClass(change.connectionPair);
      if (this._tooltipInstance) {
        if (change.scrollableViewProperties.isOverlayClipped && this._tooltipInstance.isVisible()) {
          this._ngZone.run(() => this.hide(0));
        }
      }
    });
    this._overlayRef = overlay.create({
      direction: this._dir,
      positionStrategy: strategy,
      panelClass: `${this._cssClassPrefix}-${PANEL_CLASS}`,
      scrollStrategy: this._injector.get(MAT_TOOLTIP_SCROLL_STRATEGY)()
    });
    this._updatePosition(this._overlayRef);
    this._overlayRef.detachments().pipe(takeUntil(this._destroyed)).subscribe(() => this._detach());
    this._overlayRef.outsidePointerEvents().pipe(takeUntil(this._destroyed)).subscribe(() => this._tooltipInstance?._handleBodyInteraction());
    this._overlayRef.keydownEvents().pipe(takeUntil(this._destroyed)).subscribe((event) => {
      if (this._isTooltipVisible() && event.keyCode === ESCAPE && !hasModifierKey(event)) {
        event.preventDefault();
        event.stopPropagation();
        this._ngZone.run(() => this.hide(0));
      }
    });
    if (this._defaultOptions?.disableTooltipInteractivity) {
      this._overlayRef.addPanelClass(`${this._cssClassPrefix}-tooltip-panel-non-interactive`);
    }
    if (!this._dirSubscribed) {
      this._dirSubscribed = true;
      this._dir.change.pipe(takeUntil(this._destroyed)).subscribe(() => {
        if (this._overlayRef) {
          this._updatePosition(this._overlayRef);
        }
      });
    }
    return this._overlayRef;
  }
  /** Detaches the currently-attached tooltip. */
  _detach() {
    if (this._overlayRef && this._overlayRef.hasAttached()) {
      this._overlayRef.detach();
    }
    this._tooltipInstance = null;
  }
  /** Updates the position of the current tooltip. */
  _updatePosition(overlayRef) {
    const position = overlayRef.getConfig().positionStrategy;
    const origin = this._getOrigin();
    const overlay = this._getOverlayPosition();
    position.withPositions([this._addOffset(__spreadValues(__spreadValues({}, origin.main), overlay.main)), this._addOffset(__spreadValues(__spreadValues({}, origin.fallback), overlay.fallback))]);
  }
  /** Adds the configured offset to a position. Used as a hook for child classes. */
  _addOffset(position) {
    const offset = UNBOUNDED_ANCHOR_GAP;
    const isLtr = !this._dir || this._dir.value == "ltr";
    if (position.originY === "top") {
      position.offsetY = -offset;
    } else if (position.originY === "bottom") {
      position.offsetY = offset;
    } else if (position.originX === "start") {
      position.offsetX = isLtr ? -offset : offset;
    } else if (position.originX === "end") {
      position.offsetX = isLtr ? offset : -offset;
    }
    return position;
  }
  /**
   * Returns the origin position and a fallback position based on the user's position preference.
   * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).
   */
  _getOrigin() {
    const isLtr = !this._dir || this._dir.value == "ltr";
    const position = this.position;
    let originPosition;
    if (position == "above" || position == "below") {
      originPosition = {
        originX: "center",
        originY: position == "above" ? "top" : "bottom"
      };
    } else if (position == "before" || position == "left" && isLtr || position == "right" && !isLtr) {
      originPosition = {
        originX: "start",
        originY: "center"
      };
    } else if (position == "after" || position == "right" && isLtr || position == "left" && !isLtr) {
      originPosition = {
        originX: "end",
        originY: "center"
      };
    } else if (typeof ngDevMode === "undefined" || ngDevMode) {
      throw getMatTooltipInvalidPositionError(position);
    }
    const {
      x,
      y
    } = this._invertPosition(originPosition.originX, originPosition.originY);
    return {
      main: originPosition,
      fallback: {
        originX: x,
        originY: y
      }
    };
  }
  /** Returns the overlay position and a fallback position based on the user's preference */
  _getOverlayPosition() {
    const isLtr = !this._dir || this._dir.value == "ltr";
    const position = this.position;
    let overlayPosition;
    if (position == "above") {
      overlayPosition = {
        overlayX: "center",
        overlayY: "bottom"
      };
    } else if (position == "below") {
      overlayPosition = {
        overlayX: "center",
        overlayY: "top"
      };
    } else if (position == "before" || position == "left" && isLtr || position == "right" && !isLtr) {
      overlayPosition = {
        overlayX: "end",
        overlayY: "center"
      };
    } else if (position == "after" || position == "right" && isLtr || position == "left" && !isLtr) {
      overlayPosition = {
        overlayX: "start",
        overlayY: "center"
      };
    } else if (typeof ngDevMode === "undefined" || ngDevMode) {
      throw getMatTooltipInvalidPositionError(position);
    }
    const {
      x,
      y
    } = this._invertPosition(overlayPosition.overlayX, overlayPosition.overlayY);
    return {
      main: overlayPosition,
      fallback: {
        overlayX: x,
        overlayY: y
      }
    };
  }
  /** Updates the tooltip message and repositions the overlay according to the new message length */
  _updateTooltipMessage() {
    if (this._tooltipInstance) {
      this._tooltipInstance.message = this.message;
      this._tooltipInstance._markForCheck();
      afterNextRender(() => {
        if (this._tooltipInstance) {
          this._overlayRef.updatePosition();
        }
      }, {
        injector: this._injector
      });
    }
  }
  /** Updates the tooltip class */
  _setTooltipClass(tooltipClass) {
    if (this._tooltipInstance) {
      this._tooltipInstance.tooltipClass = tooltipClass;
      this._tooltipInstance._markForCheck();
    }
  }
  /** Inverts an overlay position. */
  _invertPosition(x, y) {
    if (this.position === "above" || this.position === "below") {
      if (y === "top") {
        y = "bottom";
      } else if (y === "bottom") {
        y = "top";
      }
    } else {
      if (x === "end") {
        x = "start";
      } else if (x === "start") {
        x = "end";
      }
    }
    return {
      x,
      y
    };
  }
  /** Updates the class on the overlay panel based on the current position of the tooltip. */
  _updateCurrentPositionClass(connectionPair) {
    const {
      overlayY,
      originX,
      originY
    } = connectionPair;
    let newPosition;
    if (overlayY === "center") {
      if (this._dir && this._dir.value === "rtl") {
        newPosition = originX === "end" ? "left" : "right";
      } else {
        newPosition = originX === "start" ? "left" : "right";
      }
    } else {
      newPosition = overlayY === "bottom" && originY === "top" ? "above" : "below";
    }
    if (newPosition !== this._currentPosition) {
      const overlayRef = this._overlayRef;
      if (overlayRef) {
        const classPrefix = `${this._cssClassPrefix}-${PANEL_CLASS}-`;
        overlayRef.removePanelClass(classPrefix + this._currentPosition);
        overlayRef.addPanelClass(classPrefix + newPosition);
      }
      this._currentPosition = newPosition;
    }
  }
  /** Binds the pointer events to the tooltip trigger. */
  _setupPointerEnterEventsIfNeeded() {
    if (this._disabled || !this.message || !this._viewInitialized || this._passiveListeners.length) {
      return;
    }
    if (this._platformSupportsMouseEvents()) {
      this._passiveListeners.push(["mouseenter", (event) => {
        this._setupPointerExitEventsIfNeeded();
        let point = void 0;
        if (event.x !== void 0 && event.y !== void 0) {
          point = event;
        }
        this.show(void 0, point);
      }]);
    } else if (this.touchGestures !== "off") {
      this._disableNativeGesturesIfNecessary();
      this._passiveListeners.push(["touchstart", (event) => {
        const touch = event.targetTouches?.[0];
        const origin = touch ? {
          x: touch.clientX,
          y: touch.clientY
        } : void 0;
        this._setupPointerExitEventsIfNeeded();
        if (this._touchstartTimeout) {
          clearTimeout(this._touchstartTimeout);
        }
        const DEFAULT_LONGPRESS_DELAY = 500;
        this._touchstartTimeout = setTimeout(() => {
          this._touchstartTimeout = null;
          this.show(void 0, origin);
        }, this._defaultOptions?.touchLongPressShowDelay ?? DEFAULT_LONGPRESS_DELAY);
      }]);
    }
    this._addListeners(this._passiveListeners);
  }
  _setupPointerExitEventsIfNeeded() {
    if (this._pointerExitEventsInitialized) {
      return;
    }
    this._pointerExitEventsInitialized = true;
    const exitListeners = [];
    if (this._platformSupportsMouseEvents()) {
      exitListeners.push(["mouseleave", (event) => {
        const newTarget = event.relatedTarget;
        if (!newTarget || !this._overlayRef?.overlayElement.contains(newTarget)) {
          this.hide();
        }
      }], ["wheel", (event) => this._wheelListener(event)]);
    } else if (this.touchGestures !== "off") {
      this._disableNativeGesturesIfNecessary();
      const touchendListener = () => {
        if (this._touchstartTimeout) {
          clearTimeout(this._touchstartTimeout);
        }
        this.hide(this._defaultOptions?.touchendHideDelay);
      };
      exitListeners.push(["touchend", touchendListener], ["touchcancel", touchendListener]);
    }
    this._addListeners(exitListeners);
    this._passiveListeners.push(...exitListeners);
  }
  _addListeners(listeners) {
    listeners.forEach(([event, listener]) => {
      this._elementRef.nativeElement.addEventListener(event, listener, passiveListenerOptions);
    });
  }
  _platformSupportsMouseEvents() {
    return !this._platform.IOS && !this._platform.ANDROID;
  }
  /** Listener for the `wheel` event on the element. */
  _wheelListener(event) {
    if (this._isTooltipVisible()) {
      const elementUnderPointer = this._injector.get(DOCUMENT).elementFromPoint(event.clientX, event.clientY);
      const element = this._elementRef.nativeElement;
      if (elementUnderPointer !== element && !element.contains(elementUnderPointer)) {
        this.hide();
      }
    }
  }
  /** Disables the native browser gestures, based on how the tooltip has been configured. */
  _disableNativeGesturesIfNecessary() {
    const gestures = this.touchGestures;
    if (gestures !== "off") {
      const element = this._elementRef.nativeElement;
      const style = element.style;
      if (gestures === "on" || element.nodeName !== "INPUT" && element.nodeName !== "TEXTAREA") {
        style.userSelect = style.msUserSelect = style.webkitUserSelect = style.MozUserSelect = "none";
      }
      if (gestures === "on" || !element.draggable) {
        style.webkitUserDrag = "none";
      }
      style.touchAction = "none";
      style.webkitTapHighlightColor = "transparent";
    }
  }
  /** Updates the tooltip's ARIA description based on it current state. */
  _syncAriaDescription(oldMessage) {
    if (this._ariaDescriptionPending) {
      return;
    }
    this._ariaDescriptionPending = true;
    this._ariaDescriber.removeDescription(this._elementRef.nativeElement, oldMessage, "tooltip");
    if (!this._isDestroyed) {
      afterNextRender({
        write: () => {
          this._ariaDescriptionPending = false;
          if (this.message && !this.disabled) {
            this._ariaDescriber.describe(this._elementRef.nativeElement, this.message, "tooltip");
          }
        }
      }, {
        injector: this._injector
      });
    }
  }
  static \u0275fac = function MatTooltip_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatTooltip)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _MatTooltip,
    selectors: [["", "matTooltip", ""]],
    hostAttrs: [1, "mat-mdc-tooltip-trigger"],
    hostVars: 2,
    hostBindings: function MatTooltip_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("mat-mdc-tooltip-disabled", ctx.disabled);
      }
    },
    inputs: {
      position: [0, "matTooltipPosition", "position"],
      positionAtOrigin: [0, "matTooltipPositionAtOrigin", "positionAtOrigin"],
      disabled: [0, "matTooltipDisabled", "disabled"],
      showDelay: [0, "matTooltipShowDelay", "showDelay"],
      hideDelay: [0, "matTooltipHideDelay", "hideDelay"],
      touchGestures: [0, "matTooltipTouchGestures", "touchGestures"],
      message: [0, "matTooltip", "message"],
      tooltipClass: [0, "matTooltipClass", "tooltipClass"]
    },
    exportAs: ["matTooltip"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTooltip, [{
    type: Directive,
    args: [{
      selector: "[matTooltip]",
      exportAs: "matTooltip",
      host: {
        "class": "mat-mdc-tooltip-trigger",
        "[class.mat-mdc-tooltip-disabled]": "disabled"
      }
    }]
  }], () => [], {
    position: [{
      type: Input,
      args: ["matTooltipPosition"]
    }],
    positionAtOrigin: [{
      type: Input,
      args: ["matTooltipPositionAtOrigin"]
    }],
    disabled: [{
      type: Input,
      args: ["matTooltipDisabled"]
    }],
    showDelay: [{
      type: Input,
      args: ["matTooltipShowDelay"]
    }],
    hideDelay: [{
      type: Input,
      args: ["matTooltipHideDelay"]
    }],
    touchGestures: [{
      type: Input,
      args: ["matTooltipTouchGestures"]
    }],
    message: [{
      type: Input,
      args: ["matTooltip"]
    }],
    tooltipClass: [{
      type: Input,
      args: ["matTooltipClass"]
    }]
  });
})();
var TooltipComponent = class _TooltipComponent {
  _changeDetectorRef = inject(ChangeDetectorRef);
  _elementRef = inject(ElementRef);
  /* Whether the tooltip text overflows to multiple lines */
  _isMultiline = false;
  /** Message to display in the tooltip */
  message;
  /** Classes to be added to the tooltip. Supports the same syntax as `ngClass`. */
  tooltipClass;
  /** The timeout ID of any current timer set to show the tooltip */
  _showTimeoutId;
  /** The timeout ID of any current timer set to hide the tooltip */
  _hideTimeoutId;
  /** Element that caused the tooltip to open. */
  _triggerElement;
  /** Amount of milliseconds to delay the closing sequence. */
  _mouseLeaveHideDelay;
  /** Whether animations are currently disabled. */
  _animationsDisabled;
  /** Reference to the internal tooltip element. */
  _tooltip;
  /** Whether interactions on the page should close the tooltip */
  _closeOnInteraction = false;
  /** Whether the tooltip is currently visible. */
  _isVisible = false;
  /** Subject for notifying that the tooltip has been hidden from the view */
  _onHide = new Subject();
  /** Name of the show animation and the class that toggles it. */
  _showAnimation = "mat-mdc-tooltip-show";
  /** Name of the hide animation and the class that toggles it. */
  _hideAnimation = "mat-mdc-tooltip-hide";
  constructor() {
    const animationMode = inject(ANIMATION_MODULE_TYPE, {
      optional: true
    });
    this._animationsDisabled = animationMode === "NoopAnimations";
  }
  /**
   * Shows the tooltip with an animation originating from the provided origin
   * @param delay Amount of milliseconds to the delay showing the tooltip.
   */
  show(delay) {
    if (this._hideTimeoutId != null) {
      clearTimeout(this._hideTimeoutId);
    }
    this._showTimeoutId = setTimeout(() => {
      this._toggleVisibility(true);
      this._showTimeoutId = void 0;
    }, delay);
  }
  /**
   * Begins the animation to hide the tooltip after the provided delay in ms.
   * @param delay Amount of milliseconds to delay showing the tooltip.
   */
  hide(delay) {
    if (this._showTimeoutId != null) {
      clearTimeout(this._showTimeoutId);
    }
    this._hideTimeoutId = setTimeout(() => {
      this._toggleVisibility(false);
      this._hideTimeoutId = void 0;
    }, delay);
  }
  /** Returns an observable that notifies when the tooltip has been hidden from view. */
  afterHidden() {
    return this._onHide;
  }
  /** Whether the tooltip is being displayed. */
  isVisible() {
    return this._isVisible;
  }
  ngOnDestroy() {
    this._cancelPendingAnimations();
    this._onHide.complete();
    this._triggerElement = null;
  }
  /**
   * Interactions on the HTML body should close the tooltip immediately as defined in the
   * material design spec.
   * https://material.io/design/components/tooltips.html#behavior
   */
  _handleBodyInteraction() {
    if (this._closeOnInteraction) {
      this.hide(0);
    }
  }
  /**
   * Marks that the tooltip needs to be checked in the next change detection run.
   * Mainly used for rendering the initial text before positioning a tooltip, which
   * can be problematic in components with OnPush change detection.
   */
  _markForCheck() {
    this._changeDetectorRef.markForCheck();
  }
  _handleMouseLeave({
    relatedTarget
  }) {
    if (!relatedTarget || !this._triggerElement.contains(relatedTarget)) {
      if (this.isVisible()) {
        this.hide(this._mouseLeaveHideDelay);
      } else {
        this._finalizeAnimation(false);
      }
    }
  }
  /**
   * Callback for when the timeout in this.show() gets completed.
   * This method is only needed by the mdc-tooltip, and so it is only implemented
   * in the mdc-tooltip, not here.
   */
  _onShow() {
    this._isMultiline = this._isTooltipMultiline();
    this._markForCheck();
  }
  /** Whether the tooltip text has overflown to the next line */
  _isTooltipMultiline() {
    const rect = this._elementRef.nativeElement.getBoundingClientRect();
    return rect.height > MIN_HEIGHT && rect.width >= MAX_WIDTH;
  }
  /** Event listener dispatched when an animation on the tooltip finishes. */
  _handleAnimationEnd({
    animationName
  }) {
    if (animationName === this._showAnimation || animationName === this._hideAnimation) {
      this._finalizeAnimation(animationName === this._showAnimation);
    }
  }
  /** Cancels any pending animation sequences. */
  _cancelPendingAnimations() {
    if (this._showTimeoutId != null) {
      clearTimeout(this._showTimeoutId);
    }
    if (this._hideTimeoutId != null) {
      clearTimeout(this._hideTimeoutId);
    }
    this._showTimeoutId = this._hideTimeoutId = void 0;
  }
  /** Handles the cleanup after an animation has finished. */
  _finalizeAnimation(toVisible) {
    if (toVisible) {
      this._closeOnInteraction = true;
    } else if (!this.isVisible()) {
      this._onHide.next();
    }
  }
  /** Toggles the visibility of the tooltip element. */
  _toggleVisibility(isVisible) {
    const tooltip = this._tooltip.nativeElement;
    const showClass = this._showAnimation;
    const hideClass = this._hideAnimation;
    tooltip.classList.remove(isVisible ? hideClass : showClass);
    tooltip.classList.add(isVisible ? showClass : hideClass);
    if (this._isVisible !== isVisible) {
      this._isVisible = isVisible;
      this._changeDetectorRef.markForCheck();
    }
    if (isVisible && !this._animationsDisabled && typeof getComputedStyle === "function") {
      const styles = getComputedStyle(tooltip);
      if (styles.getPropertyValue("animation-duration") === "0s" || styles.getPropertyValue("animation-name") === "none") {
        this._animationsDisabled = true;
      }
    }
    if (isVisible) {
      this._onShow();
    }
    if (this._animationsDisabled) {
      tooltip.classList.add("_mat-animation-noopable");
      this._finalizeAnimation(isVisible);
    }
  }
  static \u0275fac = function TooltipComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TooltipComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _TooltipComponent,
    selectors: [["mat-tooltip-component"]],
    viewQuery: function TooltipComponent_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c03, 7);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx._tooltip = _t.first);
      }
    },
    hostAttrs: ["aria-hidden", "true"],
    hostBindings: function TooltipComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("mouseleave", function TooltipComponent_mouseleave_HostBindingHandler($event) {
          return ctx._handleMouseLeave($event);
        });
      }
    },
    decls: 4,
    vars: 4,
    consts: [["tooltip", ""], [1, "mdc-tooltip", "mat-mdc-tooltip", 3, "animationend", "ngClass"], [1, "mat-mdc-tooltip-surface", "mdc-tooltip__surface"]],
    template: function TooltipComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = \u0275\u0275getCurrentView();
        \u0275\u0275elementStart(0, "div", 1, 0);
        \u0275\u0275listener("animationend", function TooltipComponent_Template_div_animationend_0_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx._handleAnimationEnd($event));
        });
        \u0275\u0275elementStart(2, "div", 2);
        \u0275\u0275text(3);
        \u0275\u0275elementEnd()();
      }
      if (rf & 2) {
        \u0275\u0275classProp("mdc-tooltip--multiline", ctx._isMultiline);
        \u0275\u0275property("ngClass", ctx.tooltipClass);
        \u0275\u0275advance(3);
        \u0275\u0275textInterpolate(ctx.message);
      }
    },
    dependencies: [NgClass],
    styles: ['.mat-mdc-tooltip{position:relative;transform:scale(0);display:inline-flex}.mat-mdc-tooltip::before{content:"";top:0;right:0;bottom:0;left:0;z-index:-1;position:absolute}.mat-mdc-tooltip-panel-below .mat-mdc-tooltip::before{top:-8px}.mat-mdc-tooltip-panel-above .mat-mdc-tooltip::before{bottom:-8px}.mat-mdc-tooltip-panel-right .mat-mdc-tooltip::before{left:-8px}.mat-mdc-tooltip-panel-left .mat-mdc-tooltip::before{right:-8px}.mat-mdc-tooltip._mat-animation-noopable{animation:none;transform:scale(1)}.mat-mdc-tooltip-surface{word-break:normal;overflow-wrap:anywhere;padding:4px 8px;min-width:40px;max-width:200px;min-height:24px;max-height:40vh;box-sizing:border-box;overflow:hidden;text-align:center;will-change:transform,opacity;background-color:var(--mdc-plain-tooltip-container-color, var(--mat-sys-inverse-surface));color:var(--mdc-plain-tooltip-supporting-text-color, var(--mat-sys-inverse-on-surface));border-radius:var(--mdc-plain-tooltip-container-shape, var(--mat-sys-corner-extra-small));font-family:var(--mdc-plain-tooltip-supporting-text-font, var(--mat-sys-body-small-font));font-size:var(--mdc-plain-tooltip-supporting-text-size, var(--mat-sys-body-small-size));font-weight:var(--mdc-plain-tooltip-supporting-text-weight, var(--mat-sys-body-small-weight));line-height:var(--mdc-plain-tooltip-supporting-text-line-height, var(--mat-sys-body-small-line-height));letter-spacing:var(--mdc-plain-tooltip-supporting-text-tracking, var(--mat-sys-body-small-tracking))}.mat-mdc-tooltip-surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}.mdc-tooltip--multiline .mat-mdc-tooltip-surface{text-align:left}[dir=rtl] .mdc-tooltip--multiline .mat-mdc-tooltip-surface{text-align:right}.mat-mdc-tooltip-panel{line-height:normal}.mat-mdc-tooltip-panel.mat-mdc-tooltip-panel-non-interactive{pointer-events:none}@keyframes mat-mdc-tooltip-show{0%{opacity:0;transform:scale(0.8)}100%{opacity:1;transform:scale(1)}}@keyframes mat-mdc-tooltip-hide{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(0.8)}}.mat-mdc-tooltip-show{animation:mat-mdc-tooltip-show 150ms cubic-bezier(0, 0, 0.2, 1) forwards}.mat-mdc-tooltip-hide{animation:mat-mdc-tooltip-hide 75ms cubic-bezier(0.4, 0, 1, 1) forwards}\n'],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipComponent, [{
    type: Component,
    args: [{
      selector: "mat-tooltip-component",
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        "(mouseleave)": "_handleMouseLeave($event)",
        "aria-hidden": "true"
      },
      imports: [NgClass],
      template: '<div\n  #tooltip\n  class="mdc-tooltip mat-mdc-tooltip"\n  [ngClass]="tooltipClass"\n  (animationend)="_handleAnimationEnd($event)"\n  [class.mdc-tooltip--multiline]="_isMultiline">\n  <div class="mat-mdc-tooltip-surface mdc-tooltip__surface">{{message}}</div>\n</div>\n',
      styles: ['.mat-mdc-tooltip{position:relative;transform:scale(0);display:inline-flex}.mat-mdc-tooltip::before{content:"";top:0;right:0;bottom:0;left:0;z-index:-1;position:absolute}.mat-mdc-tooltip-panel-below .mat-mdc-tooltip::before{top:-8px}.mat-mdc-tooltip-panel-above .mat-mdc-tooltip::before{bottom:-8px}.mat-mdc-tooltip-panel-right .mat-mdc-tooltip::before{left:-8px}.mat-mdc-tooltip-panel-left .mat-mdc-tooltip::before{right:-8px}.mat-mdc-tooltip._mat-animation-noopable{animation:none;transform:scale(1)}.mat-mdc-tooltip-surface{word-break:normal;overflow-wrap:anywhere;padding:4px 8px;min-width:40px;max-width:200px;min-height:24px;max-height:40vh;box-sizing:border-box;overflow:hidden;text-align:center;will-change:transform,opacity;background-color:var(--mdc-plain-tooltip-container-color, var(--mat-sys-inverse-surface));color:var(--mdc-plain-tooltip-supporting-text-color, var(--mat-sys-inverse-on-surface));border-radius:var(--mdc-plain-tooltip-container-shape, var(--mat-sys-corner-extra-small));font-family:var(--mdc-plain-tooltip-supporting-text-font, var(--mat-sys-body-small-font));font-size:var(--mdc-plain-tooltip-supporting-text-size, var(--mat-sys-body-small-size));font-weight:var(--mdc-plain-tooltip-supporting-text-weight, var(--mat-sys-body-small-weight));line-height:var(--mdc-plain-tooltip-supporting-text-line-height, var(--mat-sys-body-small-line-height));letter-spacing:var(--mdc-plain-tooltip-supporting-text-tracking, var(--mat-sys-body-small-tracking))}.mat-mdc-tooltip-surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}.mdc-tooltip--multiline .mat-mdc-tooltip-surface{text-align:left}[dir=rtl] .mdc-tooltip--multiline .mat-mdc-tooltip-surface{text-align:right}.mat-mdc-tooltip-panel{line-height:normal}.mat-mdc-tooltip-panel.mat-mdc-tooltip-panel-non-interactive{pointer-events:none}@keyframes mat-mdc-tooltip-show{0%{opacity:0;transform:scale(0.8)}100%{opacity:1;transform:scale(1)}}@keyframes mat-mdc-tooltip-hide{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(0.8)}}.mat-mdc-tooltip-show{animation:mat-mdc-tooltip-show 150ms cubic-bezier(0, 0, 0.2, 1) forwards}.mat-mdc-tooltip-hide{animation:mat-mdc-tooltip-hide 75ms cubic-bezier(0.4, 0, 1, 1) forwards}\n']
    }]
  }], () => [], {
    _tooltip: [{
      type: ViewChild,
      args: ["tooltip", {
        // Use a static query here since we interact directly with
        // the DOM which can happen before `ngAfterViewInit`.
        static: true
      }]
    }]
  });
})();
var MatTooltipModule = class _MatTooltipModule {
  static \u0275fac = function MatTooltipModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatTooltipModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _MatTooltipModule,
    imports: [A11yModule, OverlayModule, MatCommonModule, MatTooltip, TooltipComponent],
    exports: [MatTooltip, TooltipComponent, MatCommonModule, CdkScrollableModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER],
    imports: [A11yModule, OverlayModule, MatCommonModule, MatCommonModule, CdkScrollableModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTooltipModule, [{
    type: NgModule,
    args: [{
      imports: [A11yModule, OverlayModule, MatCommonModule, MatTooltip, TooltipComponent],
      exports: [MatTooltip, TooltipComponent, MatCommonModule, CdkScrollableModule],
      providers: [MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER]
    }]
  }], null, null);
})();

// src/app/layout/layout.component.ts
var _forTrack0 = ($index, $item) => $item.label;
function LayoutComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "h3", 6);
    \u0275\u0275text(1, "Hojas de vida");
    \u0275\u0275elementEnd();
  }
}
function LayoutComponent_For_10_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 18);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(item_r3.label);
  }
}
function LayoutComponent_For_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-list-item", 16);
    \u0275\u0275listener("click", function LayoutComponent_For_10_Template_mat_list_item_click_0_listener() {
      const item_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.handleItemClick(item_r3));
    })("keydown.enter", function LayoutComponent_For_10_Template_mat_list_item_keydown_enter_0_listener() {
      const item_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.handleItemClick(item_r3));
    })("keydown.space", function LayoutComponent_For_10_Template_mat_list_item_keydown_space_0_listener() {
      const item_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.handleItemClick(item_r3));
    });
    \u0275\u0275elementStart(1, "mat-icon", 17);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, LayoutComponent_For_10_Conditional_3_Template, 2, 1, "span", 18);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275classProp("active", ctx_r3.isActive(item_r3));
    \u0275\u0275property("matTooltip", ctx_r3.isCollapsed() ? item_r3.label : "");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(item_r3.icon);
    \u0275\u0275advance();
    \u0275\u0275conditional(!ctx_r3.isCollapsed() || ctx_r3.isMobile() ? 3 : -1);
  }
}
function LayoutComponent_Conditional_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "h3", 6);
    \u0275\u0275text(1, "Cuenta");
    \u0275\u0275elementEnd();
  }
}
function LayoutComponent_For_15_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 18);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r6 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(item_r6.label);
  }
}
function LayoutComponent_For_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-list-item", 16);
    \u0275\u0275listener("click", function LayoutComponent_For_15_Template_mat_list_item_click_0_listener() {
      const item_r6 = \u0275\u0275restoreView(_r5).$implicit;
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.handleItemClick(item_r6));
    })("keydown.enter", function LayoutComponent_For_15_Template_mat_list_item_keydown_enter_0_listener() {
      const item_r6 = \u0275\u0275restoreView(_r5).$implicit;
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.handleItemClick(item_r6));
    })("keydown.space", function LayoutComponent_For_15_Template_mat_list_item_keydown_space_0_listener() {
      const item_r6 = \u0275\u0275restoreView(_r5).$implicit;
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.handleItemClick(item_r6));
    });
    \u0275\u0275elementStart(1, "mat-icon", 19);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, LayoutComponent_For_15_Conditional_3_Template, 2, 1, "span", 18);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r6 = ctx.$implicit;
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275classProp("active", ctx_r3.isActive(item_r6));
    \u0275\u0275property("matTooltip", ctx_r3.isCollapsed() ? item_r6.label : "");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(item_r6.icon);
    \u0275\u0275advance();
    \u0275\u0275conditional(!ctx_r3.isCollapsed() || ctx_r3.isMobile() ? 3 : -1);
  }
}
function LayoutComponent_Conditional_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 9)(1, "p", 20);
    \u0275\u0275text(2, "Versi\xF3n 2025.04.30");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "p", 21);
    \u0275\u0275text(4, " Reporte de errores y soporte: ");
    \u0275\u0275elementStart(5, "a", 22);
    \u0275\u0275text(6, " secretaria-administrativa@bucaramanga.gov.co ");
    \u0275\u0275elementEnd()()();
  }
}
function LayoutComponent_Conditional_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-icon", 10);
    \u0275\u0275text(1, "info");
    \u0275\u0275elementEnd();
  }
}
var LayoutComponent = class _LayoutComponent {
  breakpointObserver = inject(BreakpointObserver);
  router = inject(Router);
  auth = inject(AuthService);
  confirm = inject(ConfirmDialogService);
  isCollapsed = signal(false);
  isMobile = signal(false);
  currentUrl = signal("");
  constructor() {
    this.breakpointObserver.observe(["(max-width: 768px)"]).subscribe((result) => {
      this.isMobile.set(result.matches);
      if (result.matches) {
        this.isCollapsed.set(false);
      }
    });
    this.router.events.subscribe(() => {
      this.currentUrl.set(this.router.url);
    });
    this.currentUrl.set(this.router.url);
    const collapsed = localStorage.getItem("bipal.sidenav-collapsed");
    if (collapsed) {
      this.isCollapsed.set(collapsed === "true");
    }
  }
  // Computed signals simplificados
  sidenavMode = computed(() => this.isMobile() ? "over" : "side");
  sidenavOpened = computed(() => !this.isMobile());
  hasBackdrop = computed(() => this.isMobile());
  // Menús principales
  menuItems = [
    {
      label: "Mi hoja de vida",
      icon: "folder_managed",
      url: "/hoja-de-vida/personal"
    }
  ];
  // Menús de cuenta
  accountMenuItems = [
    {
      label: "Eliminar mis datos",
      icon: "delete_forever",
      url: "/hoja-de-vida/eliminar-datos"
    },
    {
      label: "T\xE9rminos y condiciones",
      icon: "description",
      url: "/hoja-de-vida/terminos-condiciones"
    },
    {
      label: "Cerrar sesi\xF3n",
      icon: "logout",
      action: () => {
        this.confirm.open({
          title: "Confirmar cierre de sesi\xF3n",
          message: "\xBFEst\xE1s seguro de que deseas cerrar sesi\xF3n?",
          type: "warning",
          primaryText: "Cerrar sesi\xF3n",
          secondaryText: "Cancelar"
        }).subscribe((ok) => {
          if (!ok)
            return;
          this.cerrarSesion();
        });
      }
    }
  ];
  isActive = (item) => !!item.url && this.currentUrl().startsWith(item.url);
  handleItemClick(item) {
    if (item.action) {
      item.action();
      return;
    }
    if (item.url) {
      this.router.navigate([item.url]);
    }
  }
  toggleSidenav() {
    this.isCollapsed.update((collapsed) => !collapsed);
    localStorage.setItem("bipal.sidenav-collapsed", this.isCollapsed() ? "true" : "false");
  }
  // Métodos de acción simplificados
  cerrarSesion() {
    this.auth.signOut().then(() => {
      this.router.navigate(["/auth"]);
    });
  }
  static \u0275fac = function LayoutComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LayoutComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _LayoutComponent, selectors: [["app-layout"]], decls: 27, vars: 12, consts: [["drawer", ""], [1, "sidenav-container", 3, "autosize", "hasBackdrop"], [1, "sidenav", 3, "mode", "opened"], [1, "sidenav-header"], ["alt", "Logo Alcald\xEDa de Bucaramanga", 1, "logo", 3, "src"], [1, "menu-content"], [1, "section-title"], ["matTooltipPosition", "right", 1, "menu-item", 3, "active", "matTooltip"], [1, "sidenav-footer"], [1, "footer-content"], [1, "footer-icon"], [2, "width", "100%"], ["color", "primary"], ["mat-icon-button", "", "color", "primary", 3, "click"], ["src", "assets/img/banner.png", "alt", "Logo", 1, "toolbar-logo"], [1, "main-content"], ["matTooltipPosition", "right", 1, "menu-item", 3, "click", "keydown.enter", "keydown.space", "matTooltip"], ["matListItemIcon", "", 1, "menu-icon"], ["matListItemTitle", ""], ["matListItemIcon", ""], [1, "version"], [1, "support"], ["href", "mailto:secretaria-administrativa@bucaramanga.gov.co"]], template: function LayoutComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275elementStart(0, "mat-sidenav-container", 1)(1, "mat-sidenav", 2, 0)(3, "div", 3);
      \u0275\u0275element(4, "img", 4);
      \u0275\u0275elementEnd();
      \u0275\u0275element(5, "mat-divider");
      \u0275\u0275elementStart(6, "div", 5);
      \u0275\u0275template(7, LayoutComponent_Conditional_7_Template, 2, 0, "h3", 6);
      \u0275\u0275elementStart(8, "mat-nav-list");
      \u0275\u0275repeaterCreate(9, LayoutComponent_For_10_Template, 4, 5, "mat-list-item", 7, _forTrack0);
      \u0275\u0275elementEnd();
      \u0275\u0275element(11, "mat-divider");
      \u0275\u0275template(12, LayoutComponent_Conditional_12_Template, 2, 0, "h3", 6);
      \u0275\u0275elementStart(13, "mat-nav-list");
      \u0275\u0275repeaterCreate(14, LayoutComponent_For_15_Template, 4, 5, "mat-list-item", 7, _forTrack0);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(16, "div", 8);
      \u0275\u0275template(17, LayoutComponent_Conditional_17_Template, 7, 0, "div", 9)(18, LayoutComponent_Conditional_18_Template, 2, 0, "mat-icon", 10);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(19, "mat-sidenav-content", 11)(20, "mat-toolbar", 12)(21, "button", 13);
      \u0275\u0275listener("click", function LayoutComponent_Template_button_click_21_listener() {
        \u0275\u0275restoreView(_r1);
        const drawer_r7 = \u0275\u0275reference(2);
        return \u0275\u0275resetView(ctx.isMobile() ? drawer_r7.toggle() : ctx.toggleSidenav());
      });
      \u0275\u0275elementStart(22, "mat-icon");
      \u0275\u0275text(23);
      \u0275\u0275elementEnd()();
      \u0275\u0275element(24, "img", 14);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(25, "main", 15);
      \u0275\u0275element(26, "router-outlet");
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275property("autosize", true)("hasBackdrop", ctx.hasBackdrop());
      \u0275\u0275advance();
      \u0275\u0275classProp("collapsed", ctx.isCollapsed() && !ctx.isMobile());
      \u0275\u0275property("mode", ctx.sidenavMode())("opened", ctx.sidenavOpened());
      \u0275\u0275advance(3);
      \u0275\u0275property("src", ctx.isCollapsed() && !ctx.isMobile() ? "assets/img/logo.png" : "assets/img/logo_large.png", \u0275\u0275sanitizeUrl);
      \u0275\u0275advance(3);
      \u0275\u0275conditional(!ctx.isCollapsed() || ctx.isMobile() ? 7 : -1);
      \u0275\u0275advance(2);
      \u0275\u0275repeater(ctx.menuItems);
      \u0275\u0275advance(3);
      \u0275\u0275conditional(!ctx.isCollapsed() || ctx.isMobile() ? 12 : -1);
      \u0275\u0275advance(2);
      \u0275\u0275repeater(ctx.accountMenuItems);
      \u0275\u0275advance(3);
      \u0275\u0275conditional(!ctx.isCollapsed() || ctx.isMobile() ? 17 : -1);
      \u0275\u0275advance();
      \u0275\u0275conditional(ctx.isCollapsed() && !ctx.isMobile() ? 18 : -1);
      \u0275\u0275advance(5);
      \u0275\u0275textInterpolate(ctx.isMobile() ? "menu" : ctx.isCollapsed() ? "menu" : "menu_open");
    }
  }, dependencies: [
    RouterOutlet,
    RouterModule,
    CommonModule,
    MatSidenavModule,
    MatSidenav,
    MatSidenavContainer,
    MatSidenavContent,
    MatToolbarModule,
    MatToolbar,
    MatButtonModule,
    MatIconButton,
    MatIconModule,
    MatIcon,
    MatListModule,
    MatNavList,
    MatListItem,
    MatListItemIcon,
    MatDivider,
    MatListItemTitle,
    MatDividerModule,
    MatTooltipModule,
    MatTooltip
  ], styles: ["\n\n[_nghost-%COMP%] {\n  display: block;\n  height: 100vh;\n}\n.mat-sidenav-container[_ngcontent-%COMP%] {\n  display: flex;\n  height: 100%;\n}\n.sidenav[_ngcontent-%COMP%] {\n  background-color: #f5f5f5;\n}\n.sidenav.collapsed[_ngcontent-%COMP%] {\n  width: 64px;\n  --mat-list-list-item-leading-icon-start-space: 12px;\n}\n.sidenav[_ngcontent-%COMP%]   .sidenav-header[_ngcontent-%COMP%] {\n  padding: 16px;\n  text-align: center;\n}\n.sidenav[_ngcontent-%COMP%]   .sidenav-header[_ngcontent-%COMP%]   .logo[_ngcontent-%COMP%] {\n  height: 48px;\n  max-width: 100%;\n  object-fit: contain;\n}\n.sidenav[_ngcontent-%COMP%]   .menu-content[_ngcontent-%COMP%] {\n  flex: 1;\n  padding: 8px 0;\n}\n.sidenav[_ngcontent-%COMP%]   .menu-content[_ngcontent-%COMP%]   .section-title[_ngcontent-%COMP%] {\n  font-size: 12px;\n  font-weight: 500;\n  color: #666;\n  margin: 16px 16px 8px 16px;\n  text-transform: uppercase;\n  letter-spacing: 0.8px;\n}\n.sidenav[_ngcontent-%COMP%]   .menu-content[_ngcontent-%COMP%]   .menu-item[_ngcontent-%COMP%] {\n  width: unset;\n  margin: 2px 8px;\n  border-radius: 8px;\n}\n.sidenav[_ngcontent-%COMP%]   .menu-content[_ngcontent-%COMP%]   .menu-item.active[_ngcontent-%COMP%] {\n  background-color: var(--primary-color);\n  --mdc-list-list-item-label-text-color: white;\n  --mdc-list-list-item-hover-label-text-color: var(--surface);\n}\n.sidenav[_ngcontent-%COMP%]   .menu-content[_ngcontent-%COMP%]   .menu-item.active[_ngcontent-%COMP%]   mat-icon.menu-icon[_ngcontent-%COMP%] {\n  color: white;\n}\n.sidenav[_ngcontent-%COMP%]   .menu-content[_ngcontent-%COMP%]   .menu-item.active[_ngcontent-%COMP%] {\n  background: var(--primary-color);\n  font-weight: 600;\n}\n.sidenav[_ngcontent-%COMP%]   .menu-content[_ngcontent-%COMP%]   .menu-item.active[_ngcontent-%COMP%]   .mat-icon[_ngcontent-%COMP%] {\n  color: white;\n}\n.sidenav[_ngcontent-%COMP%]   .sidenav-footer[_ngcontent-%COMP%] {\n  padding: 12px;\n  border-top: 1px solid #e0e0e0;\n  margin-top: auto;\n  text-align: center;\n}\n.sidenav[_ngcontent-%COMP%]   .sidenav-footer[_ngcontent-%COMP%]   .footer-content[_ngcontent-%COMP%]   .version[_ngcontent-%COMP%] {\n  margin: 0 0 4px 0;\n  font-size: 11px;\n  color: #888;\n}\n.sidenav[_ngcontent-%COMP%]   .sidenav-footer[_ngcontent-%COMP%]   .footer-content[_ngcontent-%COMP%]   .support[_ngcontent-%COMP%] {\n  margin: 0;\n  font-size: 10px;\n  color: #888;\n  line-height: 1.3;\n}\n.sidenav[_ngcontent-%COMP%]   .sidenav-footer[_ngcontent-%COMP%]   .footer-content[_ngcontent-%COMP%]   .support[_ngcontent-%COMP%]   a[_ngcontent-%COMP%] {\n  color: #1976d2;\n  text-decoration: none;\n}\n.sidenav[_ngcontent-%COMP%]   .sidenav-footer[_ngcontent-%COMP%]   .footer-icon[_ngcontent-%COMP%] {\n  color: #888;\n  font-size: 18px;\n}\nmat-toolbar[_ngcontent-%COMP%] {\n  display: flex;\n  align-items: center;\n  gap: 16px;\n  background-color: white !important;\n  color: #333 !important;\n  border-bottom: 1px solid #e0e0e0;\n}\nmat-toolbar[_ngcontent-%COMP%]   .toolbar-logo[_ngcontent-%COMP%] {\n  height: 100%;\n  margin-left: auto;\n}\nmat-toolbar[_ngcontent-%COMP%]   .toolbar-title[_ngcontent-%COMP%] {\n  font-size: 18px;\n  font-weight: 500;\n}\n.main-content[_ngcontent-%COMP%] {\n  height: calc(100% - 112px);\n  padding: 1.5rem;\n  background-color: #fafafa;\n  position: relative;\n}\n@media (max-width: 768px) {\n  .sidenav[_ngcontent-%COMP%] {\n    width: 280px !important;\n  }\n  .main-content[_ngcontent-%COMP%] {\n    padding: 16px;\n  }\n  .toolbar-title[_ngcontent-%COMP%] {\n    font-size: 16px;\n  }\n}\n/*# sourceMappingURL=layout.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutComponent, [{
    type: Component,
    args: [{ selector: "app-layout", imports: [
      RouterOutlet,
      RouterModule,
      CommonModule,
      MatSidenavModule,
      MatToolbarModule,
      MatButtonModule,
      MatIconModule,
      MatListModule,
      MatDividerModule,
      MatTooltipModule
    ], template: `<mat-sidenav-container [autosize]="true" [hasBackdrop]="hasBackdrop()" class="sidenav-container">
  <mat-sidenav 
    #drawer 
    class="sidenav" 
    [class.collapsed]="isCollapsed() && !isMobile()"
    [mode]="sidenavMode()"
    [opened]="sidenavOpened()">
    
    <!-- Header -->
    <div class="sidenav-header">
      <img 
        [src]="isCollapsed() && !isMobile() ? 'assets/img/logo.png' : 'assets/img/logo_large.png'"
        alt="Logo Alcald\xEDa de Bucaramanga"
        class="logo">
    </div>
    
    <mat-divider></mat-divider>
    
    <!-- Men\xFA principal -->
    <div class="menu-content">
      @if (!isCollapsed() || isMobile()) {
        <h3 class="section-title">Hojas de vida</h3>
      }
      
      <mat-nav-list>
        @for (item of menuItems; track item.label) {
          <mat-list-item 
            class="menu-item"
            [class.active]="isActive(item)"
            (click)="handleItemClick(item)"
            [matTooltip]=" isCollapsed() ? item.label : ''"
            matTooltipPosition="right"
            (keydown.enter)="handleItemClick(item)"
            (keydown.space)="handleItemClick(item)">
            <mat-icon matListItemIcon class="menu-icon">{{ item.icon }}</mat-icon>
            @if (!isCollapsed() || isMobile()) {
              <span matListItemTitle>{{ item.label }}</span>
            }
          </mat-list-item>
        }
      </mat-nav-list>
      
      <mat-divider></mat-divider>
      
      <!-- Secci\xF3n Cuenta -->
      @if (!isCollapsed() || isMobile()) {
        <h3 class="section-title">Cuenta</h3>
      }
      
      <mat-nav-list>
        @for (item of accountMenuItems; track item.label) {
          <mat-list-item 
            class="menu-item"
            [class.active]="isActive(item)"
            (click)="handleItemClick(item)"
            [matTooltip]=" isCollapsed() ? item.label : ''"
            matTooltipPosition="right"
            (keydown.enter)="handleItemClick(item)"
            (keydown.space)="handleItemClick(item)">
            <mat-icon matListItemIcon>{{ item.icon }}</mat-icon>
            @if (!isCollapsed() || isMobile()) {
              <span matListItemTitle>{{ item.label }}</span>
            }
          </mat-list-item>
        }
      </mat-nav-list>
    </div>
    
    <!-- Footer -->
      <div class="sidenav-footer">
      @if (!isCollapsed() || isMobile()) {
        <div class="footer-content">
          <p class="version">Versi\xF3n 2025.04.30</p>
          <p class="support">
            Reporte de errores y soporte: 
            <a href="mailto:secretaria-administrativa&#64;bucaramanga.gov.co">
              secretaria-administrativa&#64;bucaramanga.gov.co
            </a>
          </p>
        </div>
      }
      @if (isCollapsed() && !isMobile()) {
        <mat-icon class="footer-icon">info</mat-icon>
      }
    </div>
  </mat-sidenav>

  <mat-sidenav-content style="width: 100%">
    <!-- Toolbar -->
    <mat-toolbar color="primary">
      <button 
        mat-icon-button
        color="primary"
        (click)="isMobile() ? drawer.toggle() : toggleSidenav()">
        <mat-icon>{{ isMobile() ? 'menu' : (isCollapsed() ? 'menu' : 'menu_open') }}</mat-icon>
      </button>
      
      <img src="assets/img/banner.png" alt="Logo" class="toolbar-logo">
    </mat-toolbar>
    
    <!-- Contenido principal -->
    <main class="main-content">
      <router-outlet />
    </main>
  </mat-sidenav-content>
</mat-sidenav-container>
`, styles: ["/* src/app/layout/layout.component.scss */\n:host {\n  display: block;\n  height: 100vh;\n}\n.mat-sidenav-container {\n  display: flex;\n  height: 100%;\n}\n.sidenav {\n  background-color: #f5f5f5;\n}\n.sidenav.collapsed {\n  width: 64px;\n  --mat-list-list-item-leading-icon-start-space: 12px;\n}\n.sidenav .sidenav-header {\n  padding: 16px;\n  text-align: center;\n}\n.sidenav .sidenav-header .logo {\n  height: 48px;\n  max-width: 100%;\n  object-fit: contain;\n}\n.sidenav .menu-content {\n  flex: 1;\n  padding: 8px 0;\n}\n.sidenav .menu-content .section-title {\n  font-size: 12px;\n  font-weight: 500;\n  color: #666;\n  margin: 16px 16px 8px 16px;\n  text-transform: uppercase;\n  letter-spacing: 0.8px;\n}\n.sidenav .menu-content .menu-item {\n  width: unset;\n  margin: 2px 8px;\n  border-radius: 8px;\n}\n.sidenav .menu-content .menu-item.active {\n  background-color: var(--primary-color);\n  --mdc-list-list-item-label-text-color: white;\n  --mdc-list-list-item-hover-label-text-color: var(--surface);\n}\n.sidenav .menu-content .menu-item.active mat-icon.menu-icon {\n  color: white;\n}\n.sidenav .menu-content .menu-item.active {\n  background: var(--primary-color);\n  font-weight: 600;\n}\n.sidenav .menu-content .menu-item.active .mat-icon {\n  color: white;\n}\n.sidenav .sidenav-footer {\n  padding: 12px;\n  border-top: 1px solid #e0e0e0;\n  margin-top: auto;\n  text-align: center;\n}\n.sidenav .sidenav-footer .footer-content .version {\n  margin: 0 0 4px 0;\n  font-size: 11px;\n  color: #888;\n}\n.sidenav .sidenav-footer .footer-content .support {\n  margin: 0;\n  font-size: 10px;\n  color: #888;\n  line-height: 1.3;\n}\n.sidenav .sidenav-footer .footer-content .support a {\n  color: #1976d2;\n  text-decoration: none;\n}\n.sidenav .sidenav-footer .footer-icon {\n  color: #888;\n  font-size: 18px;\n}\nmat-toolbar {\n  display: flex;\n  align-items: center;\n  gap: 16px;\n  background-color: white !important;\n  color: #333 !important;\n  border-bottom: 1px solid #e0e0e0;\n}\nmat-toolbar .toolbar-logo {\n  height: 100%;\n  margin-left: auto;\n}\nmat-toolbar .toolbar-title {\n  font-size: 18px;\n  font-weight: 500;\n}\n.main-content {\n  height: calc(100% - 112px);\n  padding: 1.5rem;\n  background-color: #fafafa;\n  position: relative;\n}\n@media (max-width: 768px) {\n  .sidenav {\n    width: 280px !important;\n  }\n  .main-content {\n    padding: 16px;\n  }\n  .toolbar-title {\n    font-size: 16px;\n  }\n}\n/*# sourceMappingURL=layout.component.css.map */\n"] }]
  }], () => [], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(LayoutComponent, { className: "LayoutComponent", filePath: "src/app/layout/layout.component.ts", lineNumber: 40 });
})();

// src/app/modules/hojadevida/guard/hoja-de-vida-auth.guard.ts
function ensureSessionOrRedirect() {
  return __async(this, null, function* () {
    console.log("Ensuring session");
    const auth = inject(AuthService);
    const router = inject(Router);
    const notifier = inject(NotificationService);
    try {
      yield auth.ensureSessionLoaded();
      if (!auth.session) {
        notifier.showInfo("Debe iniciar sesi\xF3n para continuar");
        return router.createUrlTree(["/auth"]);
      }
      const { data } = yield auth.profile();
      const onboardingStep = data?.user?.user_metadata?.onboarding_step;
      const emailConfirmedAt = data?.user?.email_confirmed_at;
      if (onboardingStep && onboardingStep !== "completed" || !emailConfirmedAt) {
        return router.createUrlTree(["/auth/crear-clave"]);
      }
      return true;
    } catch (e) {
      console.error("ensureSession error", e);
      notifier.showError("Error verificando sesi\xF3n");
      return router.createUrlTree(["/auth"]);
    }
  });
}
var hojaDeVidaCanActivateChild = () => {
  return ensureSessionOrRedirect();
};

// node_modules/.pnpm/@angular+material@19.2.18_@angular+cdk@19.2.19_@angular+common@19.2.14_@angular+core@19_102b8bfb5e382f9d0615b5538deb6474/node_modules/@angular/material/fesm2022/checkbox.mjs
var _c04 = ["input"];
var _c13 = ["label"];
var _c22 = ["*"];
var MAT_CHECKBOX_DEFAULT_OPTIONS = new InjectionToken("mat-checkbox-default-options", {
  providedIn: "root",
  factory: MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY
});
function MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY() {
  return {
    color: "accent",
    clickAction: "check-indeterminate",
    disabledInteractive: false
  };
}
var TransitionCheckState;
(function(TransitionCheckState2) {
  TransitionCheckState2[TransitionCheckState2["Init"] = 0] = "Init";
  TransitionCheckState2[TransitionCheckState2["Checked"] = 1] = "Checked";
  TransitionCheckState2[TransitionCheckState2["Unchecked"] = 2] = "Unchecked";
  TransitionCheckState2[TransitionCheckState2["Indeterminate"] = 3] = "Indeterminate";
})(TransitionCheckState || (TransitionCheckState = {}));
var MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => MatCheckbox),
  multi: true
};
var MatCheckboxChange = class {
  /** The source checkbox of the event. */
  source;
  /** The new `checked` value of the checkbox. */
  checked;
};
var defaults = MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY();
var MatCheckbox = class _MatCheckbox {
  _elementRef = inject(ElementRef);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _ngZone = inject(NgZone);
  _animationMode = inject(ANIMATION_MODULE_TYPE, {
    optional: true
  });
  _options = inject(MAT_CHECKBOX_DEFAULT_OPTIONS, {
    optional: true
  });
  /** Focuses the checkbox. */
  focus() {
    this._inputElement.nativeElement.focus();
  }
  /** Creates the change event that will be emitted by the checkbox. */
  _createChangeEvent(isChecked) {
    const event = new MatCheckboxChange();
    event.source = this;
    event.checked = isChecked;
    return event;
  }
  /** Gets the element on which to add the animation CSS classes. */
  _getAnimationTargetElement() {
    return this._inputElement?.nativeElement;
  }
  /** CSS classes to add when transitioning between the different checkbox states. */
  _animationClasses = {
    uncheckedToChecked: "mdc-checkbox--anim-unchecked-checked",
    uncheckedToIndeterminate: "mdc-checkbox--anim-unchecked-indeterminate",
    checkedToUnchecked: "mdc-checkbox--anim-checked-unchecked",
    checkedToIndeterminate: "mdc-checkbox--anim-checked-indeterminate",
    indeterminateToChecked: "mdc-checkbox--anim-indeterminate-checked",
    indeterminateToUnchecked: "mdc-checkbox--anim-indeterminate-unchecked"
  };
  /**
   * Attached to the aria-label attribute of the host element. In most cases, aria-labelledby will
   * take precedence so this may be omitted.
   */
  ariaLabel = "";
  /**
   * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
   */
  ariaLabelledby = null;
  /** The 'aria-describedby' attribute is read after the element's label and field type. */
  ariaDescribedby;
  /**
   * Users can specify the `aria-expanded` attribute which will be forwarded to the input element
   */
  ariaExpanded;
  /**
   * Users can specify the `aria-controls` attribute which will be forwarded to the input element
   */
  ariaControls;
  /** Users can specify the `aria-owns` attribute which will be forwarded to the input element */
  ariaOwns;
  _uniqueId;
  /** A unique id for the checkbox input. If none is supplied, it will be auto-generated. */
  id;
  /** Returns the unique id for the visual hidden input. */
  get inputId() {
    return `${this.id || this._uniqueId}-input`;
  }
  /** Whether the checkbox is required. */
  required;
  /** Whether the label should appear after or before the checkbox. Defaults to 'after' */
  labelPosition = "after";
  /** Name value will be applied to the input element if present */
  name = null;
  /** Event emitted when the checkbox's `checked` value changes. */
  change = new EventEmitter();
  /** Event emitted when the checkbox's `indeterminate` value changes. */
  indeterminateChange = new EventEmitter();
  /** The value attribute of the native input element */
  value;
  /** Whether the checkbox has a ripple. */
  disableRipple;
  /** The native `<input type="checkbox">` element */
  _inputElement;
  /** The native `<label>` element */
  _labelElement;
  /** Tabindex for the checkbox. */
  tabIndex;
  // TODO(crisbeto): this should be a ThemePalette, but some internal apps were abusing
  // the lack of type checking previously and assigning random strings.
  /**
   * Theme color of the checkbox. This API is supported in M2 themes only, it
   * has no effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/checkbox/styling.
   *
   * For information on applying color variants in M3, see
   * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants
   */
  color;
  /** Whether the checkbox should remain interactive when it is disabled. */
  disabledInteractive;
  /**
   * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.
   * @docs-private
   */
  _onTouched = () => {
  };
  _currentAnimationClass = "";
  _currentCheckState = TransitionCheckState.Init;
  _controlValueAccessorChangeFn = () => {
  };
  _validatorChangeFn = () => {
  };
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);
    const tabIndex = inject(new HostAttributeToken("tabindex"), {
      optional: true
    });
    this._options = this._options || defaults;
    this.color = this._options.color || defaults.color;
    this.tabIndex = tabIndex == null ? 0 : parseInt(tabIndex) || 0;
    this.id = this._uniqueId = inject(_IdGenerator).getId("mat-mdc-checkbox-");
    this.disabledInteractive = this._options?.disabledInteractive ?? false;
  }
  ngOnChanges(changes) {
    if (changes["required"]) {
      this._validatorChangeFn();
    }
  }
  ngAfterViewInit() {
    this._syncIndeterminate(this._indeterminate);
  }
  /** Whether the checkbox is checked. */
  get checked() {
    return this._checked;
  }
  set checked(value) {
    if (value != this.checked) {
      this._checked = value;
      this._changeDetectorRef.markForCheck();
    }
  }
  _checked = false;
  /** Whether the checkbox is disabled. */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    if (value !== this.disabled) {
      this._disabled = value;
      this._changeDetectorRef.markForCheck();
    }
  }
  _disabled = false;
  /**
   * Whether the checkbox is indeterminate. This is also known as "mixed" mode and can be used to
   * represent a checkbox with three states, e.g. a checkbox that represents a nested list of
   * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately
   * set to false.
   */
  get indeterminate() {
    return this._indeterminate;
  }
  set indeterminate(value) {
    const changed = value != this._indeterminate;
    this._indeterminate = value;
    if (changed) {
      if (this._indeterminate) {
        this._transitionCheckState(TransitionCheckState.Indeterminate);
      } else {
        this._transitionCheckState(this.checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);
      }
      this.indeterminateChange.emit(this._indeterminate);
    }
    this._syncIndeterminate(this._indeterminate);
  }
  _indeterminate = false;
  _isRippleDisabled() {
    return this.disableRipple || this.disabled;
  }
  /** Method being called whenever the label text changes. */
  _onLabelTextChange() {
    this._changeDetectorRef.detectChanges();
  }
  // Implemented as part of ControlValueAccessor.
  writeValue(value) {
    this.checked = !!value;
  }
  // Implemented as part of ControlValueAccessor.
  registerOnChange(fn) {
    this._controlValueAccessorChangeFn = fn;
  }
  // Implemented as part of ControlValueAccessor.
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  // Implemented as part of ControlValueAccessor.
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  // Implemented as a part of Validator.
  validate(control) {
    return this.required && control.value !== true ? {
      "required": true
    } : null;
  }
  // Implemented as a part of Validator.
  registerOnValidatorChange(fn) {
    this._validatorChangeFn = fn;
  }
  _transitionCheckState(newState) {
    let oldState = this._currentCheckState;
    let element = this._getAnimationTargetElement();
    if (oldState === newState || !element) {
      return;
    }
    if (this._currentAnimationClass) {
      element.classList.remove(this._currentAnimationClass);
    }
    this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(oldState, newState);
    this._currentCheckState = newState;
    if (this._currentAnimationClass.length > 0) {
      element.classList.add(this._currentAnimationClass);
      const animationClass = this._currentAnimationClass;
      this._ngZone.runOutsideAngular(() => {
        setTimeout(() => {
          element.classList.remove(animationClass);
        }, 1e3);
      });
    }
  }
  _emitChangeEvent() {
    this._controlValueAccessorChangeFn(this.checked);
    this.change.emit(this._createChangeEvent(this.checked));
    if (this._inputElement) {
      this._inputElement.nativeElement.checked = this.checked;
    }
  }
  /** Toggles the `checked` state of the checkbox. */
  toggle() {
    this.checked = !this.checked;
    this._controlValueAccessorChangeFn(this.checked);
  }
  _handleInputClick() {
    const clickAction = this._options?.clickAction;
    if (!this.disabled && clickAction !== "noop") {
      if (this.indeterminate && clickAction !== "check") {
        Promise.resolve().then(() => {
          this._indeterminate = false;
          this.indeterminateChange.emit(this._indeterminate);
        });
      }
      this._checked = !this._checked;
      this._transitionCheckState(this._checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);
      this._emitChangeEvent();
    } else if (this.disabled && this.disabledInteractive || !this.disabled && clickAction === "noop") {
      this._inputElement.nativeElement.checked = this.checked;
      this._inputElement.nativeElement.indeterminate = this.indeterminate;
    }
  }
  _onInteractionEvent(event) {
    event.stopPropagation();
  }
  _onBlur() {
    Promise.resolve().then(() => {
      this._onTouched();
      this._changeDetectorRef.markForCheck();
    });
  }
  _getAnimationClassForCheckStateTransition(oldState, newState) {
    if (this._animationMode === "NoopAnimations") {
      return "";
    }
    switch (oldState) {
      case TransitionCheckState.Init:
        if (newState === TransitionCheckState.Checked) {
          return this._animationClasses.uncheckedToChecked;
        } else if (newState == TransitionCheckState.Indeterminate) {
          return this._checked ? this._animationClasses.checkedToIndeterminate : this._animationClasses.uncheckedToIndeterminate;
        }
        break;
      case TransitionCheckState.Unchecked:
        return newState === TransitionCheckState.Checked ? this._animationClasses.uncheckedToChecked : this._animationClasses.uncheckedToIndeterminate;
      case TransitionCheckState.Checked:
        return newState === TransitionCheckState.Unchecked ? this._animationClasses.checkedToUnchecked : this._animationClasses.checkedToIndeterminate;
      case TransitionCheckState.Indeterminate:
        return newState === TransitionCheckState.Checked ? this._animationClasses.indeterminateToChecked : this._animationClasses.indeterminateToUnchecked;
    }
    return "";
  }
  /**
   * Syncs the indeterminate value with the checkbox DOM node.
   *
   * We sync `indeterminate` directly on the DOM node, because in Ivy the check for whether a
   * property is supported on an element boils down to `if (propName in element)`. Domino's
   * HTMLInputElement doesn't have an `indeterminate` property so Ivy will warn during
   * server-side rendering.
   */
  _syncIndeterminate(value) {
    const nativeCheckbox = this._inputElement;
    if (nativeCheckbox) {
      nativeCheckbox.nativeElement.indeterminate = value;
    }
  }
  _onInputClick() {
    this._handleInputClick();
  }
  _onTouchTargetClick() {
    this._handleInputClick();
    if (!this.disabled) {
      this._inputElement.nativeElement.focus();
    }
  }
  /**
   *  Prevent click events that come from the `<label/>` element from bubbling. This prevents the
   *  click handler on the host from triggering twice when clicking on the `<label/>` element. After
   *  the click event on the `<label/>` propagates, the browsers dispatches click on the associated
   *  `<input/>`. By preventing clicks on the label by bubbling, we ensure only one click event
   *  bubbles when the label is clicked.
   */
  _preventBubblingFromLabel(event) {
    if (!!event.target && this._labelElement.nativeElement.contains(event.target)) {
      event.stopPropagation();
    }
  }
  static \u0275fac = function MatCheckbox_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatCheckbox)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _MatCheckbox,
    selectors: [["mat-checkbox"]],
    viewQuery: function MatCheckbox_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c04, 5);
        \u0275\u0275viewQuery(_c13, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx._inputElement = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx._labelElement = _t.first);
      }
    },
    hostAttrs: [1, "mat-mdc-checkbox"],
    hostVars: 16,
    hostBindings: function MatCheckbox_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275hostProperty("id", ctx.id);
        \u0275\u0275attribute("tabindex", null)("aria-label", null)("aria-labelledby", null);
        \u0275\u0275classMap(ctx.color ? "mat-" + ctx.color : "mat-accent");
        \u0275\u0275classProp("_mat-animation-noopable", ctx._animationMode === "NoopAnimations")("mdc-checkbox--disabled", ctx.disabled)("mat-mdc-checkbox-disabled", ctx.disabled)("mat-mdc-checkbox-checked", ctx.checked)("mat-mdc-checkbox-disabled-interactive", ctx.disabledInteractive);
      }
    },
    inputs: {
      ariaLabel: [0, "aria-label", "ariaLabel"],
      ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"],
      ariaDescribedby: [0, "aria-describedby", "ariaDescribedby"],
      ariaExpanded: [2, "aria-expanded", "ariaExpanded", booleanAttribute],
      ariaControls: [0, "aria-controls", "ariaControls"],
      ariaOwns: [0, "aria-owns", "ariaOwns"],
      id: "id",
      required: [2, "required", "required", booleanAttribute],
      labelPosition: "labelPosition",
      name: "name",
      value: "value",
      disableRipple: [2, "disableRipple", "disableRipple", booleanAttribute],
      tabIndex: [2, "tabIndex", "tabIndex", (value) => value == null ? void 0 : numberAttribute(value)],
      color: "color",
      disabledInteractive: [2, "disabledInteractive", "disabledInteractive", booleanAttribute],
      checked: [2, "checked", "checked", booleanAttribute],
      disabled: [2, "disabled", "disabled", booleanAttribute],
      indeterminate: [2, "indeterminate", "indeterminate", booleanAttribute]
    },
    outputs: {
      change: "change",
      indeterminateChange: "indeterminateChange"
    },
    exportAs: ["matCheckbox"],
    features: [\u0275\u0275ProvidersFeature([MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR, {
      provide: NG_VALIDATORS,
      useExisting: _MatCheckbox,
      multi: true
    }]), \u0275\u0275NgOnChangesFeature],
    ngContentSelectors: _c22,
    decls: 15,
    vars: 23,
    consts: [["checkbox", ""], ["input", ""], ["label", ""], ["mat-internal-form-field", "", 3, "click", "labelPosition"], [1, "mdc-checkbox"], [1, "mat-mdc-checkbox-touch-target", 3, "click"], ["type", "checkbox", 1, "mdc-checkbox__native-control", 3, "blur", "click", "change", "checked", "indeterminate", "disabled", "id", "required", "tabIndex"], [1, "mdc-checkbox__ripple"], [1, "mdc-checkbox__background"], ["focusable", "false", "viewBox", "0 0 24 24", "aria-hidden", "true", 1, "mdc-checkbox__checkmark"], ["fill", "none", "d", "M1.73,12.91 8.1,19.28 22.79,4.59", 1, "mdc-checkbox__checkmark-path"], [1, "mdc-checkbox__mixedmark"], ["mat-ripple", "", 1, "mat-mdc-checkbox-ripple", "mat-focus-indicator", 3, "matRippleTrigger", "matRippleDisabled", "matRippleCentered"], [1, "mdc-label", 3, "for"]],
    template: function MatCheckbox_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = \u0275\u0275getCurrentView();
        \u0275\u0275projectionDef();
        \u0275\u0275elementStart(0, "div", 3);
        \u0275\u0275listener("click", function MatCheckbox_Template_div_click_0_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx._preventBubblingFromLabel($event));
        });
        \u0275\u0275elementStart(1, "div", 4, 0)(3, "div", 5);
        \u0275\u0275listener("click", function MatCheckbox_Template_div_click_3_listener() {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx._onTouchTargetClick());
        });
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(4, "input", 6, 1);
        \u0275\u0275listener("blur", function MatCheckbox_Template_input_blur_4_listener() {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx._onBlur());
        })("click", function MatCheckbox_Template_input_click_4_listener() {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx._onInputClick());
        })("change", function MatCheckbox_Template_input_change_4_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx._onInteractionEvent($event));
        });
        \u0275\u0275elementEnd();
        \u0275\u0275element(6, "div", 7);
        \u0275\u0275elementStart(7, "div", 8);
        \u0275\u0275namespaceSVG();
        \u0275\u0275elementStart(8, "svg", 9);
        \u0275\u0275element(9, "path", 10);
        \u0275\u0275elementEnd();
        \u0275\u0275namespaceHTML();
        \u0275\u0275element(10, "div", 11);
        \u0275\u0275elementEnd();
        \u0275\u0275element(11, "div", 12);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(12, "label", 13, 2);
        \u0275\u0275projection(14);
        \u0275\u0275elementEnd()();
      }
      if (rf & 2) {
        const checkbox_r2 = \u0275\u0275reference(2);
        \u0275\u0275property("labelPosition", ctx.labelPosition);
        \u0275\u0275advance(4);
        \u0275\u0275classProp("mdc-checkbox--selected", ctx.checked);
        \u0275\u0275property("checked", ctx.checked)("indeterminate", ctx.indeterminate)("disabled", ctx.disabled && !ctx.disabledInteractive)("id", ctx.inputId)("required", ctx.required)("tabIndex", ctx.disabled && !ctx.disabledInteractive ? -1 : ctx.tabIndex);
        \u0275\u0275attribute("aria-label", ctx.ariaLabel || null)("aria-labelledby", ctx.ariaLabelledby)("aria-describedby", ctx.ariaDescribedby)("aria-checked", ctx.indeterminate ? "mixed" : null)("aria-controls", ctx.ariaControls)("aria-disabled", ctx.disabled && ctx.disabledInteractive ? true : null)("aria-expanded", ctx.ariaExpanded)("aria-owns", ctx.ariaOwns)("name", ctx.name)("value", ctx.value);
        \u0275\u0275advance(7);
        \u0275\u0275property("matRippleTrigger", checkbox_r2)("matRippleDisabled", ctx.disableRipple || ctx.disabled)("matRippleCentered", true);
        \u0275\u0275advance();
        \u0275\u0275property("for", ctx.inputId);
      }
    },
    dependencies: [MatRipple, _MatInternalFormField],
    styles: ['.mdc-checkbox{display:inline-block;position:relative;flex:0 0 18px;box-sizing:content-box;width:18px;height:18px;line-height:0;white-space:nowrap;cursor:pointer;vertical-align:bottom;padding:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2);margin:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2)}.mdc-checkbox:hover>.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:hover>.mat-mdc-checkbox-ripple>.mat-ripple-element{background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control:focus+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-focus-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control:focus~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-unselected-focus-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:active>.mdc-checkbox__native-control+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-pressed-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:active>.mdc-checkbox__native-control~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-unselected-pressed-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:hover .mdc-checkbox__native-control:checked+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity));background-color:var(--mdc-checkbox-selected-hover-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:hover .mdc-checkbox__native-control:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-hover-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox .mdc-checkbox__native-control:focus:checked+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity));background-color:var(--mdc-checkbox-selected-focus-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox .mdc-checkbox__native-control:focus:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-focus-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:active>.mdc-checkbox__native-control:checked+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));background-color:var(--mdc-checkbox-selected-pressed-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:active>.mdc-checkbox__native-control:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-pressed-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control~.mat-mdc-checkbox-ripple .mat-ripple-element,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control+.mdc-checkbox__ripple{background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control{position:absolute;margin:0;padding:0;opacity:0;cursor:inherit;z-index:1;width:var(--mdc-checkbox-state-layer-size, 40px);height:var(--mdc-checkbox-state-layer-size, 40px);top:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2);right:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2);left:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2)}.mdc-checkbox--disabled{cursor:default;pointer-events:none}@media(forced-colors: active){.mdc-checkbox--disabled{opacity:.5}}.mdc-checkbox__background{display:inline-flex;position:absolute;align-items:center;justify-content:center;box-sizing:border-box;width:18px;height:18px;border:2px solid currentColor;border-radius:2px;background-color:rgba(0,0,0,0);pointer-events:none;will-change:background-color,border-color;transition:background-color 90ms cubic-bezier(0.4, 0, 0.6, 1),border-color 90ms cubic-bezier(0.4, 0, 0.6, 1);-webkit-print-color-adjust:exact;color-adjust:exact;border-color:var(--mdc-checkbox-unselected-icon-color, var(--mat-sys-on-surface-variant));top:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2);left:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2)}.mdc-checkbox__native-control:enabled:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:enabled:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-icon-color, var(--mat-sys-primary))}.mdc-checkbox--disabled .mdc-checkbox__background{border-color:var(--mdc-checkbox-disabled-unselected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-checkbox__native-control:disabled:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:disabled:indeterminate~.mdc-checkbox__background{background-color:var(--mdc-checkbox-disabled-selected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));border-color:rgba(0,0,0,0)}.mdc-checkbox:hover>.mdc-checkbox__native-control:not(:checked)~.mdc-checkbox__background,.mdc-checkbox:hover>.mdc-checkbox__native-control:not(:indeterminate)~.mdc-checkbox__background{border-color:var(--mdc-checkbox-unselected-hover-icon-color, var(--mat-sys-on-surface));background-color:rgba(0,0,0,0)}.mdc-checkbox:hover>.mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox:hover>.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-hover-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-hover-icon-color, var(--mat-sys-primary))}.mdc-checkbox__native-control:focus:focus:not(:checked)~.mdc-checkbox__background,.mdc-checkbox__native-control:focus:focus:not(:indeterminate)~.mdc-checkbox__background{border-color:var(--mdc-checkbox-unselected-focus-icon-color, var(--mat-sys-on-surface))}.mdc-checkbox__native-control:focus:focus:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:focus:focus:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-focus-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-focus-icon-color, var(--mat-sys-primary))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox:hover>.mdc-checkbox__native-control~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control:focus~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__background{border-color:var(--mdc-checkbox-disabled-unselected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{background-color:var(--mdc-checkbox-disabled-selected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));border-color:rgba(0,0,0,0)}.mdc-checkbox__checkmark{position:absolute;top:0;right:0;bottom:0;left:0;width:100%;opacity:0;transition:opacity 180ms cubic-bezier(0.4, 0, 0.6, 1);color:var(--mdc-checkbox-selected-checkmark-color, var(--mat-sys-on-primary))}@media(forced-colors: active){.mdc-checkbox__checkmark{color:CanvasText}}.mdc-checkbox--disabled .mdc-checkbox__checkmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__checkmark{color:var(--mdc-checkbox-disabled-selected-checkmark-color, var(--mat-sys-surface))}@media(forced-colors: active){.mdc-checkbox--disabled .mdc-checkbox__checkmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__checkmark{color:CanvasText}}.mdc-checkbox__checkmark-path{transition:stroke-dashoffset 180ms cubic-bezier(0.4, 0, 0.6, 1);stroke:currentColor;stroke-width:3.12px;stroke-dashoffset:29.7833385;stroke-dasharray:29.7833385}.mdc-checkbox__mixedmark{width:100%;height:0;transform:scaleX(0) rotate(0deg);border-width:1px;border-style:solid;opacity:0;transition:opacity 90ms cubic-bezier(0.4, 0, 0.6, 1),transform 90ms cubic-bezier(0.4, 0, 0.6, 1);border-color:var(--mdc-checkbox-selected-checkmark-color, var(--mat-sys-on-primary))}@media(forced-colors: active){.mdc-checkbox__mixedmark{margin:0 1px}}.mdc-checkbox--disabled .mdc-checkbox__mixedmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__mixedmark{border-color:var(--mdc-checkbox-disabled-selected-checkmark-color, var(--mat-sys-surface))}.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__background,.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__background,.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__background,.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__background{animation-duration:180ms;animation-timing-function:linear}.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__checkmark-path{animation:mdc-checkbox-unchecked-checked-checkmark-path 180ms linear;transition:none}.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__mixedmark{animation:mdc-checkbox-unchecked-indeterminate-mixedmark 90ms linear;transition:none}.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__checkmark-path{animation:mdc-checkbox-checked-unchecked-checkmark-path 90ms linear;transition:none}.mdc-checkbox--anim-checked-indeterminate .mdc-checkbox__checkmark{animation:mdc-checkbox-checked-indeterminate-checkmark 90ms linear;transition:none}.mdc-checkbox--anim-checked-indeterminate .mdc-checkbox__mixedmark{animation:mdc-checkbox-checked-indeterminate-mixedmark 90ms linear;transition:none}.mdc-checkbox--anim-indeterminate-checked .mdc-checkbox__checkmark{animation:mdc-checkbox-indeterminate-checked-checkmark 500ms linear;transition:none}.mdc-checkbox--anim-indeterminate-checked .mdc-checkbox__mixedmark{animation:mdc-checkbox-indeterminate-checked-mixedmark 500ms linear;transition:none}.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__mixedmark{animation:mdc-checkbox-indeterminate-unchecked-mixedmark 300ms linear;transition:none}.mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{transition:border-color 90ms cubic-bezier(0, 0, 0.2, 1),background-color 90ms cubic-bezier(0, 0, 0.2, 1)}.mdc-checkbox__native-control:checked~.mdc-checkbox__background>.mdc-checkbox__checkmark>.mdc-checkbox__checkmark-path,.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background>.mdc-checkbox__checkmark>.mdc-checkbox__checkmark-path{stroke-dashoffset:0}.mdc-checkbox__native-control:checked~.mdc-checkbox__background>.mdc-checkbox__checkmark{transition:opacity 180ms cubic-bezier(0, 0, 0.2, 1),transform 180ms cubic-bezier(0, 0, 0.2, 1);opacity:1}.mdc-checkbox__native-control:checked~.mdc-checkbox__background>.mdc-checkbox__mixedmark{transform:scaleX(1) rotate(-45deg)}.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background>.mdc-checkbox__checkmark{transform:rotate(45deg);opacity:0;transition:opacity 90ms cubic-bezier(0.4, 0, 0.6, 1),transform 90ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background>.mdc-checkbox__mixedmark{transform:scaleX(1) rotate(0deg);opacity:1}@keyframes mdc-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:29.7833385}50%{animation-timing-function:cubic-bezier(0, 0, 0.2, 1)}100%{stroke-dashoffset:0}}@keyframes mdc-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0, 0, 0, 1)}100%{transform:scaleX(1)}}@keyframes mdc-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(0.4, 0, 1, 1);opacity:1;stroke-dashoffset:0}to{opacity:0;stroke-dashoffset:-29.7833385}}@keyframes mdc-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 1);transform:rotate(0deg);opacity:1}to{transform:rotate(45deg);opacity:0}}@keyframes mdc-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);transform:rotate(45deg);opacity:0}to{transform:rotate(360deg);opacity:1}}@keyframes mdc-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 1);transform:rotate(-45deg);opacity:0}to{transform:rotate(0deg);opacity:1}}@keyframes mdc-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);transform:rotate(0deg);opacity:1}to{transform:rotate(315deg);opacity:0}}@keyframes mdc-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;transform:scaleX(1);opacity:1}32.8%,100%{transform:scaleX(0);opacity:0}}.mat-mdc-checkbox{display:inline-block;position:relative;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mat-mdc-checkbox-touch-target,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__native-control,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__ripple,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mat-mdc-checkbox-ripple::before,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background>.mdc-checkbox__checkmark,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background>.mdc-checkbox__checkmark>.mdc-checkbox__checkmark-path,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background>.mdc-checkbox__mixedmark{transition:none !important;animation:none !important}.mat-mdc-checkbox label{cursor:pointer}.mat-mdc-checkbox .mat-internal-form-field{color:var(--mat-checkbox-label-text-color, var(--mat-sys-on-surface));font-family:var(--mat-checkbox-label-text-font, var(--mat-sys-body-medium-font));line-height:var(--mat-checkbox-label-text-line-height, var(--mat-sys-body-medium-line-height));font-size:var(--mat-checkbox-label-text-size, var(--mat-sys-body-medium-size));letter-spacing:var(--mat-checkbox-label-text-tracking, var(--mat-sys-body-medium-tracking));font-weight:var(--mat-checkbox-label-text-weight, var(--mat-sys-body-medium-weight))}.mat-mdc-checkbox.mat-mdc-checkbox-disabled.mat-mdc-checkbox-disabled-interactive{pointer-events:auto}.mat-mdc-checkbox.mat-mdc-checkbox-disabled.mat-mdc-checkbox-disabled-interactive input{cursor:default}.mat-mdc-checkbox.mat-mdc-checkbox-disabled label{cursor:default;color:var(--mat-checkbox-disabled-label-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-checkbox label:empty{display:none}.mat-mdc-checkbox .mdc-checkbox__ripple{opacity:0}.mat-mdc-checkbox .mat-mdc-checkbox-ripple,.mdc-checkbox__ripple{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:50%;pointer-events:none}.mat-mdc-checkbox .mat-mdc-checkbox-ripple:not(:empty),.mdc-checkbox__ripple:not(:empty){transform:translateZ(0)}.mat-mdc-checkbox-ripple .mat-ripple-element{opacity:.1}.mat-mdc-checkbox-touch-target{position:absolute;top:50%;left:50%;height:48px;width:48px;transform:translate(-50%, -50%);display:var(--mat-checkbox-touch-target-display, block)}.mat-mdc-checkbox .mat-mdc-checkbox-ripple::before{border-radius:50%}.mdc-checkbox__native-control:focus~.mat-focus-indicator::before{content:""}\n'],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatCheckbox, [{
    type: Component,
    args: [{
      selector: "mat-checkbox",
      host: {
        "class": "mat-mdc-checkbox",
        "[attr.tabindex]": "null",
        "[attr.aria-label]": "null",
        "[attr.aria-labelledby]": "null",
        "[class._mat-animation-noopable]": `_animationMode === 'NoopAnimations'`,
        "[class.mdc-checkbox--disabled]": "disabled",
        "[id]": "id",
        // Add classes that users can use to more easily target disabled or checked checkboxes.
        "[class.mat-mdc-checkbox-disabled]": "disabled",
        "[class.mat-mdc-checkbox-checked]": "checked",
        "[class.mat-mdc-checkbox-disabled-interactive]": "disabledInteractive",
        "[class]": 'color ? "mat-" + color : "mat-accent"'
      },
      providers: [MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR, {
        provide: NG_VALIDATORS,
        useExisting: MatCheckbox,
        multi: true
      }],
      exportAs: "matCheckbox",
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [MatRipple, _MatInternalFormField],
      template: `<div mat-internal-form-field [labelPosition]="labelPosition" (click)="_preventBubblingFromLabel($event)">
  <div #checkbox class="mdc-checkbox">
    <!-- Render this element first so the input is on top. -->
    <div class="mat-mdc-checkbox-touch-target" (click)="_onTouchTargetClick()"></div>
    <input #input
           type="checkbox"
           class="mdc-checkbox__native-control"
           [class.mdc-checkbox--selected]="checked"
           [attr.aria-label]="ariaLabel || null"
           [attr.aria-labelledby]="ariaLabelledby"
           [attr.aria-describedby]="ariaDescribedby"
           [attr.aria-checked]="indeterminate ? 'mixed' : null"
           [attr.aria-controls]="ariaControls"
           [attr.aria-disabled]="disabled && disabledInteractive ? true : null"
           [attr.aria-expanded]="ariaExpanded"
           [attr.aria-owns]="ariaOwns"
           [attr.name]="name"
           [attr.value]="value"
           [checked]="checked"
           [indeterminate]="indeterminate"
           [disabled]="disabled && !disabledInteractive"
           [id]="inputId"
           [required]="required"
           [tabIndex]="disabled && !disabledInteractive ? -1 : tabIndex"
           (blur)="_onBlur()"
           (click)="_onInputClick()"
           (change)="_onInteractionEvent($event)"/>
    <div class="mdc-checkbox__ripple"></div>
    <div class="mdc-checkbox__background">
      <svg class="mdc-checkbox__checkmark"
           focusable="false"
           viewBox="0 0 24 24"
           aria-hidden="true">
        <path class="mdc-checkbox__checkmark-path"
              fill="none"
              d="M1.73,12.91 8.1,19.28 22.79,4.59"/>
      </svg>
      <div class="mdc-checkbox__mixedmark"></div>
    </div>
    <div class="mat-mdc-checkbox-ripple mat-focus-indicator" mat-ripple
      [matRippleTrigger]="checkbox"
      [matRippleDisabled]="disableRipple || disabled"
      [matRippleCentered]="true"></div>
  </div>
  <!--
    Avoid putting a click handler on the <label/> to fix duplicate navigation stop on Talk Back
    (#14385). Putting a click handler on the <label/> caused this bug because the browser produced
    an unnecessary accessibility tree node.
  -->
  <label class="mdc-label" #label [for]="inputId">
    <ng-content></ng-content>
  </label>
</div>
`,
      styles: ['.mdc-checkbox{display:inline-block;position:relative;flex:0 0 18px;box-sizing:content-box;width:18px;height:18px;line-height:0;white-space:nowrap;cursor:pointer;vertical-align:bottom;padding:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2);margin:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2)}.mdc-checkbox:hover>.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:hover>.mat-mdc-checkbox-ripple>.mat-ripple-element{background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control:focus+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-focus-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control:focus~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-unselected-focus-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:active>.mdc-checkbox__native-control+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-pressed-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:active>.mdc-checkbox__native-control~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-unselected-pressed-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:hover .mdc-checkbox__native-control:checked+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity));background-color:var(--mdc-checkbox-selected-hover-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:hover .mdc-checkbox__native-control:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-hover-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox .mdc-checkbox__native-control:focus:checked+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity));background-color:var(--mdc-checkbox-selected-focus-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox .mdc-checkbox__native-control:focus:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-focus-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:active>.mdc-checkbox__native-control:checked+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));background-color:var(--mdc-checkbox-selected-pressed-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:active>.mdc-checkbox__native-control:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-pressed-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control~.mat-mdc-checkbox-ripple .mat-ripple-element,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control+.mdc-checkbox__ripple{background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control{position:absolute;margin:0;padding:0;opacity:0;cursor:inherit;z-index:1;width:var(--mdc-checkbox-state-layer-size, 40px);height:var(--mdc-checkbox-state-layer-size, 40px);top:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2);right:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2);left:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2)}.mdc-checkbox--disabled{cursor:default;pointer-events:none}@media(forced-colors: active){.mdc-checkbox--disabled{opacity:.5}}.mdc-checkbox__background{display:inline-flex;position:absolute;align-items:center;justify-content:center;box-sizing:border-box;width:18px;height:18px;border:2px solid currentColor;border-radius:2px;background-color:rgba(0,0,0,0);pointer-events:none;will-change:background-color,border-color;transition:background-color 90ms cubic-bezier(0.4, 0, 0.6, 1),border-color 90ms cubic-bezier(0.4, 0, 0.6, 1);-webkit-print-color-adjust:exact;color-adjust:exact;border-color:var(--mdc-checkbox-unselected-icon-color, var(--mat-sys-on-surface-variant));top:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2);left:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2)}.mdc-checkbox__native-control:enabled:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:enabled:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-icon-color, var(--mat-sys-primary))}.mdc-checkbox--disabled .mdc-checkbox__background{border-color:var(--mdc-checkbox-disabled-unselected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-checkbox__native-control:disabled:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:disabled:indeterminate~.mdc-checkbox__background{background-color:var(--mdc-checkbox-disabled-selected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));border-color:rgba(0,0,0,0)}.mdc-checkbox:hover>.mdc-checkbox__native-control:not(:checked)~.mdc-checkbox__background,.mdc-checkbox:hover>.mdc-checkbox__native-control:not(:indeterminate)~.mdc-checkbox__background{border-color:var(--mdc-checkbox-unselected-hover-icon-color, var(--mat-sys-on-surface));background-color:rgba(0,0,0,0)}.mdc-checkbox:hover>.mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox:hover>.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-hover-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-hover-icon-color, var(--mat-sys-primary))}.mdc-checkbox__native-control:focus:focus:not(:checked)~.mdc-checkbox__background,.mdc-checkbox__native-control:focus:focus:not(:indeterminate)~.mdc-checkbox__background{border-color:var(--mdc-checkbox-unselected-focus-icon-color, var(--mat-sys-on-surface))}.mdc-checkbox__native-control:focus:focus:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:focus:focus:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-focus-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-focus-icon-color, var(--mat-sys-primary))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox:hover>.mdc-checkbox__native-control~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control:focus~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__background{border-color:var(--mdc-checkbox-disabled-unselected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{background-color:var(--mdc-checkbox-disabled-selected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));border-color:rgba(0,0,0,0)}.mdc-checkbox__checkmark{position:absolute;top:0;right:0;bottom:0;left:0;width:100%;opacity:0;transition:opacity 180ms cubic-bezier(0.4, 0, 0.6, 1);color:var(--mdc-checkbox-selected-checkmark-color, var(--mat-sys-on-primary))}@media(forced-colors: active){.mdc-checkbox__checkmark{color:CanvasText}}.mdc-checkbox--disabled .mdc-checkbox__checkmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__checkmark{color:var(--mdc-checkbox-disabled-selected-checkmark-color, var(--mat-sys-surface))}@media(forced-colors: active){.mdc-checkbox--disabled .mdc-checkbox__checkmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__checkmark{color:CanvasText}}.mdc-checkbox__checkmark-path{transition:stroke-dashoffset 180ms cubic-bezier(0.4, 0, 0.6, 1);stroke:currentColor;stroke-width:3.12px;stroke-dashoffset:29.7833385;stroke-dasharray:29.7833385}.mdc-checkbox__mixedmark{width:100%;height:0;transform:scaleX(0) rotate(0deg);border-width:1px;border-style:solid;opacity:0;transition:opacity 90ms cubic-bezier(0.4, 0, 0.6, 1),transform 90ms cubic-bezier(0.4, 0, 0.6, 1);border-color:var(--mdc-checkbox-selected-checkmark-color, var(--mat-sys-on-primary))}@media(forced-colors: active){.mdc-checkbox__mixedmark{margin:0 1px}}.mdc-checkbox--disabled .mdc-checkbox__mixedmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__mixedmark{border-color:var(--mdc-checkbox-disabled-selected-checkmark-color, var(--mat-sys-surface))}.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__background,.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__background,.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__background,.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__background{animation-duration:180ms;animation-timing-function:linear}.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__checkmark-path{animation:mdc-checkbox-unchecked-checked-checkmark-path 180ms linear;transition:none}.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__mixedmark{animation:mdc-checkbox-unchecked-indeterminate-mixedmark 90ms linear;transition:none}.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__checkmark-path{animation:mdc-checkbox-checked-unchecked-checkmark-path 90ms linear;transition:none}.mdc-checkbox--anim-checked-indeterminate .mdc-checkbox__checkmark{animation:mdc-checkbox-checked-indeterminate-checkmark 90ms linear;transition:none}.mdc-checkbox--anim-checked-indeterminate .mdc-checkbox__mixedmark{animation:mdc-checkbox-checked-indeterminate-mixedmark 90ms linear;transition:none}.mdc-checkbox--anim-indeterminate-checked .mdc-checkbox__checkmark{animation:mdc-checkbox-indeterminate-checked-checkmark 500ms linear;transition:none}.mdc-checkbox--anim-indeterminate-checked .mdc-checkbox__mixedmark{animation:mdc-checkbox-indeterminate-checked-mixedmark 500ms linear;transition:none}.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__mixedmark{animation:mdc-checkbox-indeterminate-unchecked-mixedmark 300ms linear;transition:none}.mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{transition:border-color 90ms cubic-bezier(0, 0, 0.2, 1),background-color 90ms cubic-bezier(0, 0, 0.2, 1)}.mdc-checkbox__native-control:checked~.mdc-checkbox__background>.mdc-checkbox__checkmark>.mdc-checkbox__checkmark-path,.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background>.mdc-checkbox__checkmark>.mdc-checkbox__checkmark-path{stroke-dashoffset:0}.mdc-checkbox__native-control:checked~.mdc-checkbox__background>.mdc-checkbox__checkmark{transition:opacity 180ms cubic-bezier(0, 0, 0.2, 1),transform 180ms cubic-bezier(0, 0, 0.2, 1);opacity:1}.mdc-checkbox__native-control:checked~.mdc-checkbox__background>.mdc-checkbox__mixedmark{transform:scaleX(1) rotate(-45deg)}.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background>.mdc-checkbox__checkmark{transform:rotate(45deg);opacity:0;transition:opacity 90ms cubic-bezier(0.4, 0, 0.6, 1),transform 90ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background>.mdc-checkbox__mixedmark{transform:scaleX(1) rotate(0deg);opacity:1}@keyframes mdc-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:29.7833385}50%{animation-timing-function:cubic-bezier(0, 0, 0.2, 1)}100%{stroke-dashoffset:0}}@keyframes mdc-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0, 0, 0, 1)}100%{transform:scaleX(1)}}@keyframes mdc-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(0.4, 0, 1, 1);opacity:1;stroke-dashoffset:0}to{opacity:0;stroke-dashoffset:-29.7833385}}@keyframes mdc-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 1);transform:rotate(0deg);opacity:1}to{transform:rotate(45deg);opacity:0}}@keyframes mdc-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);transform:rotate(45deg);opacity:0}to{transform:rotate(360deg);opacity:1}}@keyframes mdc-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 1);transform:rotate(-45deg);opacity:0}to{transform:rotate(0deg);opacity:1}}@keyframes mdc-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);transform:rotate(0deg);opacity:1}to{transform:rotate(315deg);opacity:0}}@keyframes mdc-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;transform:scaleX(1);opacity:1}32.8%,100%{transform:scaleX(0);opacity:0}}.mat-mdc-checkbox{display:inline-block;position:relative;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mat-mdc-checkbox-touch-target,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__native-control,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__ripple,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mat-mdc-checkbox-ripple::before,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background>.mdc-checkbox__checkmark,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background>.mdc-checkbox__checkmark>.mdc-checkbox__checkmark-path,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background>.mdc-checkbox__mixedmark{transition:none !important;animation:none !important}.mat-mdc-checkbox label{cursor:pointer}.mat-mdc-checkbox .mat-internal-form-field{color:var(--mat-checkbox-label-text-color, var(--mat-sys-on-surface));font-family:var(--mat-checkbox-label-text-font, var(--mat-sys-body-medium-font));line-height:var(--mat-checkbox-label-text-line-height, var(--mat-sys-body-medium-line-height));font-size:var(--mat-checkbox-label-text-size, var(--mat-sys-body-medium-size));letter-spacing:var(--mat-checkbox-label-text-tracking, var(--mat-sys-body-medium-tracking));font-weight:var(--mat-checkbox-label-text-weight, var(--mat-sys-body-medium-weight))}.mat-mdc-checkbox.mat-mdc-checkbox-disabled.mat-mdc-checkbox-disabled-interactive{pointer-events:auto}.mat-mdc-checkbox.mat-mdc-checkbox-disabled.mat-mdc-checkbox-disabled-interactive input{cursor:default}.mat-mdc-checkbox.mat-mdc-checkbox-disabled label{cursor:default;color:var(--mat-checkbox-disabled-label-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-checkbox label:empty{display:none}.mat-mdc-checkbox .mdc-checkbox__ripple{opacity:0}.mat-mdc-checkbox .mat-mdc-checkbox-ripple,.mdc-checkbox__ripple{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:50%;pointer-events:none}.mat-mdc-checkbox .mat-mdc-checkbox-ripple:not(:empty),.mdc-checkbox__ripple:not(:empty){transform:translateZ(0)}.mat-mdc-checkbox-ripple .mat-ripple-element{opacity:.1}.mat-mdc-checkbox-touch-target{position:absolute;top:50%;left:50%;height:48px;width:48px;transform:translate(-50%, -50%);display:var(--mat-checkbox-touch-target-display, block)}.mat-mdc-checkbox .mat-mdc-checkbox-ripple::before{border-radius:50%}.mdc-checkbox__native-control:focus~.mat-focus-indicator::before{content:""}\n']
    }]
  }], () => [], {
    ariaLabel: [{
      type: Input,
      args: ["aria-label"]
    }],
    ariaLabelledby: [{
      type: Input,
      args: ["aria-labelledby"]
    }],
    ariaDescribedby: [{
      type: Input,
      args: ["aria-describedby"]
    }],
    ariaExpanded: [{
      type: Input,
      args: [{
        alias: "aria-expanded",
        transform: booleanAttribute
      }]
    }],
    ariaControls: [{
      type: Input,
      args: ["aria-controls"]
    }],
    ariaOwns: [{
      type: Input,
      args: ["aria-owns"]
    }],
    id: [{
      type: Input
    }],
    required: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    labelPosition: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    change: [{
      type: Output
    }],
    indeterminateChange: [{
      type: Output
    }],
    value: [{
      type: Input
    }],
    disableRipple: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    _inputElement: [{
      type: ViewChild,
      args: ["input"]
    }],
    _labelElement: [{
      type: ViewChild,
      args: ["label"]
    }],
    tabIndex: [{
      type: Input,
      args: [{
        transform: (value) => value == null ? void 0 : numberAttribute(value)
      }]
    }],
    color: [{
      type: Input
    }],
    disabledInteractive: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    checked: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    indeterminate: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var MAT_CHECKBOX_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MatCheckboxRequiredValidator),
  multi: true
};
var MatCheckboxRequiredValidator = class _MatCheckboxRequiredValidator extends CheckboxRequiredValidator {
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275MatCheckboxRequiredValidator_BaseFactory;
    return function MatCheckboxRequiredValidator_Factory(__ngFactoryType__) {
      return (\u0275MatCheckboxRequiredValidator_BaseFactory || (\u0275MatCheckboxRequiredValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MatCheckboxRequiredValidator)))(__ngFactoryType__ || _MatCheckboxRequiredValidator);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _MatCheckboxRequiredValidator,
    selectors: [["mat-checkbox", "required", "", "formControlName", ""], ["mat-checkbox", "required", "", "formControl", ""], ["mat-checkbox", "required", "", "ngModel", ""]],
    features: [\u0275\u0275ProvidersFeature([MAT_CHECKBOX_REQUIRED_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatCheckboxRequiredValidator, [{
    type: Directive,
    args: [{
      selector: `mat-checkbox[required][formControlName],
             mat-checkbox[required][formControl], mat-checkbox[required][ngModel]`,
      providers: [MAT_CHECKBOX_REQUIRED_VALIDATOR]
    }]
  }], null, null);
})();
var _MatCheckboxRequiredValidatorModule = class __MatCheckboxRequiredValidatorModule {
  static \u0275fac = function _MatCheckboxRequiredValidatorModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __MatCheckboxRequiredValidatorModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: __MatCheckboxRequiredValidatorModule,
    imports: [MatCheckboxRequiredValidator],
    exports: [MatCheckboxRequiredValidator]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_MatCheckboxRequiredValidatorModule, [{
    type: NgModule,
    args: [{
      imports: [MatCheckboxRequiredValidator],
      exports: [MatCheckboxRequiredValidator]
    }]
  }], null, null);
})();
var MatCheckboxModule = class _MatCheckboxModule {
  static \u0275fac = function MatCheckboxModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatCheckboxModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _MatCheckboxModule,
    imports: [MatCheckbox, MatCommonModule],
    exports: [MatCheckbox, MatCommonModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [MatCheckbox, MatCommonModule, MatCommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatCheckboxModule, [{
    type: NgModule,
    args: [{
      imports: [MatCheckbox, MatCommonModule],
      exports: [MatCheckbox, MatCommonModule]
    }]
  }], null, null);
})();

// src/app/modules/auth/authentication.component.ts
var AuthenticationComponent = class _AuthenticationComponent {
  static \u0275fac = function AuthenticationComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AuthenticationComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AuthenticationComponent, selectors: [["app-authentication"]], decls: 5, vars: 0, consts: [[1, "background-img"], [1, "title-container"], [1, "title"]], template: function AuthenticationComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "h1", 2);
      \u0275\u0275text(3, " Banco de informaci\xF3n de perfiles acad\xE9micos y laborales - BIPAL. ");
      \u0275\u0275elementEnd()();
      \u0275\u0275element(4, "router-outlet");
      \u0275\u0275elementEnd();
    }
  }, dependencies: [
    FormsModule,
    MatFormFieldModule,
    MatDividerModule,
    RouterModule,
    RouterOutlet,
    MatExpansionModule,
    MatCheckboxModule,
    CommonModule
  ], styles: ['\n\n[_nghost-%COMP%]   h2[_ngcontent-%COMP%] {\n  color: #000;\n}\n.background-img[_ngcontent-%COMP%] {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  height: 100%;\n  background-image: url("./media/background-auth.jpg");\n  background-size: inherit;\n}\nspan[_ngcontent-%COMP%] {\n  padding: 1rem;\n}\n.title[_ngcontent-%COMP%] {\n  display: flex;\n  margin: 0;\n  padding: 5vh 20vw 0 20vw;\n  text-align: center;\n  color: #5b5d61;\n}\n@media (max-width: 840px) {\n  .title[_ngcontent-%COMP%] {\n    font-size: 1.8rem;\n  }\n}\n@media (max-width: 600px) {\n  .title[_ngcontent-%COMP%] {\n    font-size: 1.4rem;\n  }\n}\n/*# sourceMappingURL=authentication.component.css.map */'] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AuthenticationComponent, [{
    type: Component,
    args: [{ selector: "app-authentication", imports: [
      FormsModule,
      MatFormFieldModule,
      MatDividerModule,
      RouterModule,
      MatExpansionModule,
      MatCheckboxModule,
      CommonModule,
      // FullContainerAuthComponent,
      RouterModule
    ], template: '<!--TODO: falta agregar el el identificador de usuario que se pueda identificar por correo o por numero de celular-->\n<div class="background-img">\n  <div class="title-container">\n    <h1 class="title">\n      Banco de informaci\xF3n de perfiles acad\xE9micos y laborales - BIPAL.\n    </h1>\n  </div>\n  <!-- <app-full-container-auth></app-full-container-auth> -->\n  <router-outlet/>\n</div>\n', styles: ['/* src/app/modules/auth/authentication.component.scss */\n:host h2 {\n  color: #000;\n}\n.background-img {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  height: 100%;\n  background-image: url("./media/background-auth.jpg");\n  background-size: inherit;\n}\nspan {\n  padding: 1rem;\n}\n.title {\n  display: flex;\n  margin: 0;\n  padding: 5vh 20vw 0 20vw;\n  text-align: center;\n  color: #5b5d61;\n}\n@media (max-width: 840px) {\n  .title {\n    font-size: 1.8rem;\n  }\n}\n@media (max-width: 600px) {\n  .title {\n    font-size: 1.4rem;\n  }\n}\n/*# sourceMappingURL=authentication.component.css.map */\n'] }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AuthenticationComponent, { className: "AuthenticationComponent", filePath: "src/app/modules/auth/authentication.component.ts", lineNumber: 41 });
})();

// src/app/modules/auth/components/registrarse/registrarse.component.ts
function RegistrarseComponent_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-error");
    \u0275\u0275text(1, "El n\xFAmero de documento es ");
    \u0275\u0275elementStart(2, "strong");
    \u0275\u0275text(3, "obligatorio");
    \u0275\u0275elementEnd()();
  }
}
function RegistrarseComponent_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-error");
    \u0275\u0275text(1, "Ingresa un n\xFAmero de documento v\xE1lido ");
    \u0275\u0275elementEnd();
  }
}
function RegistrarseComponent_Conditional_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-error");
    \u0275\u0275text(1, "Por favor ingresa un email v\xE1lido");
    \u0275\u0275elementEnd();
  }
}
function RegistrarseComponent_Conditional_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-error");
    \u0275\u0275text(1, "El email es ");
    \u0275\u0275elementStart(2, "strong");
    \u0275\u0275text(3, "obligatorio");
    \u0275\u0275elementEnd()();
  }
}
function RegistrarseComponent_Conditional_31_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0, " Enviar c\xF3digo ");
  }
}
function RegistrarseComponent_Conditional_32_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275textInterpolate1(" Reintenta en ", ctx_r0.cooldownSeconds, "s ");
  }
}
var RegistrarseComponent = class _RegistrarseComponent {
  fb;
  routerBj;
  httpBj;
  //injectamos las depdencias
  authService = inject(AuthService);
  BorrarData() {
    console.log("hola");
  }
  registerForm;
  clickOnCheckbox = false;
  // cooldown de reenvío
  isCooldown = false;
  cooldownSeconds = environment.emailSenderCooldown ?? 60;
  cooldownTimer = null;
  constructor(fb, routerBj, httpBj) {
    this.fb = fb;
    this.routerBj = routerBj;
    this.httpBj = httpBj;
    this.registerForm = this.fb.group({
      documentNumber: [
        "",
        [
          Validators.required,
          Validators.pattern(/^\d+$/)
          //validator de digitos numericos
        ]
      ],
      email: [
        "",
        [
          Validators.required,
          Validators.pattern(/^[a-zA-Z0-9._%+*-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/)
          // REGEX PARA CORREO
        ]
      ]
    });
  }
  /**
   * Este metodo se encarga de avisarle al front que el codigo de verificacion ya fue enviado
   * al usuario por medio de la API de supabase y se proceda a cargar la vista de llenado del codigo
   */
  consultarEstadoCodigo() {
    this.authService.sendCodeVerification(this.registerForm.value.email, this.registerForm.value.documentNumber).then(({ error }) => {
      if (error) {
        const code = error?.code ?? error?.status ?? "";
        if (code === "over_email_send_rate_limit" || code === 429 || code === "email_rate_limit_exceeded") {
          this.startCooldown(environment.emailSenderCooldown ?? 60);
        }
        console.error("Error al enviar el c\xF3digo de verificaci\xF3n:", error);
      } else {
        this.routerBj.navigate(["auth", "comprobar-codigo"], {
          queryParams: {
            email: this.registerForm.value.email,
            documento: this.registerForm.value.documentNumber,
            origin: "register"
          }
        });
      }
    });
  }
  onSubmit() {
    this.registerForm.markAllAsTouched();
    if (this.registerForm.invalid)
      return;
    if (this.clickOnCheckbox && this.registerForm.valid && !this.isCooldown) {
      this.consultarEstadoCodigo();
    }
  }
  startCooldown(seconds) {
    this.isCooldown = true;
    this.cooldownSeconds = seconds;
    if (this.cooldownTimer) {
      clearInterval(this.cooldownTimer);
    }
    this.cooldownTimer = setInterval(() => {
      this.cooldownSeconds -= 1;
      if (this.cooldownSeconds <= 0) {
        this.isCooldown = false;
        clearInterval(this.cooldownTimer);
        this.cooldownTimer = null;
      }
    }, 1e3);
  }
  static \u0275fac = function RegistrarseComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RegistrarseComponent)(\u0275\u0275directiveInject(FormBuilder), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(HttpClient));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _RegistrarseComponent, selectors: [["app-registrarse"]], decls: 33, vars: 6, consts: [[1, "register-form", 3, "formGroup"], [1, "wid-100"], ["matPrefix", "", 1, "prefix-icon"], ["matInput", "", "placeholder", " N\xFAmero de documento sin puntos ni comas", "formControlName", "documentNumber"], ["matInput", "", "placeholder", "ejemplo@gmail.com", "formControlName", "email"], [3, "change"], ["routerLink", "/terminos-condiciones"], [1, "align-center"], ["mat-flat-button", "", "type", "submit", 1, "mar-05rem", 3, "click", "disabled"]], template: function RegistrarseComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "form", 0)(1, "h2");
      \u0275\u0275text(2, "Registrarme");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "mat-form-field", 1)(4, "mat-label");
      \u0275\u0275text(5, " N\xFAmero de documento");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(6, "mat-icon", 2);
      \u0275\u0275text(7, "badge");
      \u0275\u0275elementEnd();
      \u0275\u0275element(8, "input", 3);
      \u0275\u0275template(9, RegistrarseComponent_Conditional_9_Template, 4, 0, "mat-error")(10, RegistrarseComponent_Conditional_10_Template, 2, 0, "mat-error");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(11, "mat-form-field", 1)(12, "mat-label");
      \u0275\u0275text(13, " Correo electr\xF3nico ");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(14, "mat-icon", 2);
      \u0275\u0275text(15, "mail");
      \u0275\u0275elementEnd();
      \u0275\u0275element(16, "input", 4);
      \u0275\u0275template(17, RegistrarseComponent_Conditional_17_Template, 2, 0, "mat-error")(18, RegistrarseComponent_Conditional_18_Template, 4, 0, "mat-error");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(19, "mat-checkbox", 5);
      \u0275\u0275listener("change", function RegistrarseComponent_Template_mat_checkbox_change_19_listener() {
        return ctx.clickOnCheckbox = !ctx.clickOnCheckbox;
      });
      \u0275\u0275elementStart(20, "span");
      \u0275\u0275text(21, " Declaro que he le\xEDdo y aceptado los ");
      \u0275\u0275elementStart(22, "a", 6);
      \u0275\u0275text(23, "t\xE9rminos y condiciones ");
      \u0275\u0275elementEnd();
      \u0275\u0275text(24, " aqu\xED establecidos. ");
      \u0275\u0275elementEnd()();
      \u0275\u0275element(25, "mat-divider");
      \u0275\u0275elementStart(26, "span");
      \u0275\u0275element(27, "br", 7);
      \u0275\u0275text(28, " Para el proceso de registro se debe verificar su correo electr\xF3nico con un c\xF3digo de verificaci\xF3n. ");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(29, "div")(30, "button", 8);
      \u0275\u0275listener("click", function RegistrarseComponent_Template_button_click_30_listener() {
        return ctx.onSubmit();
      });
      \u0275\u0275template(31, RegistrarseComponent_Conditional_31_Template, 1, 0)(32, RegistrarseComponent_Conditional_32_Template, 1, 1);
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275property("formGroup", ctx.registerForm);
      \u0275\u0275advance(9);
      \u0275\u0275conditional(ctx.registerForm.controls["documentNumber"].hasError("required") ? 9 : ctx.registerForm.controls["documentNumber"].hasError("pattern") ? 10 : -1);
      \u0275\u0275advance(8);
      \u0275\u0275conditional(ctx.registerForm.controls["email"].hasError("pattern") && !ctx.registerForm.controls["email"].hasError("required") ? 17 : -1);
      \u0275\u0275advance();
      \u0275\u0275conditional(ctx.registerForm.controls["email"].hasError("required") ? 18 : -1);
      \u0275\u0275advance(12);
      \u0275\u0275property("disabled", !ctx.registerForm.valid || !ctx.clickOnCheckbox || ctx.isCooldown);
      \u0275\u0275advance();
      \u0275\u0275conditional(!ctx.isCooldown ? 31 : 32);
    }
  }, dependencies: [
    MatInputModule,
    MatInput,
    MatFormField,
    MatLabel,
    MatError,
    MatPrefix,
    MatIcon,
    MatDivider,
    RouterModule,
    RouterLink,
    MatButtonModule,
    MatButton,
    ReactiveFormsModule,
    \u0275NgNoValidate,
    DefaultValueAccessor,
    NgControlStatus,
    NgControlStatusGroup,
    FormGroupDirective,
    FormControlName,
    MatCheckbox
  ], styles: ["\n\n[_nghost-%COMP%] {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  max-width: 100vw;\n  overflow-x: hidden;\n}\n.register-form[_ngcontent-%COMP%] {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  height: 100%;\n  max-width: 500px;\n}\n.wid-100[_ngcontent-%COMP%] {\n  width: 100%;\n}\n.non-space[_ngcontent-%COMP%] {\n  padding: 0;\n  margin: 0;\n}\n.mar-05rem[_ngcontent-%COMP%] {\n  margin: 0.5rem;\n}\n/*# sourceMappingURL=registrarse.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RegistrarseComponent, [{
    type: Component,
    args: [{ selector: "app-registrarse", imports: [
      MatInputModule,
      MatIcon,
      MatDivider,
      RouterModule,
      MatButtonModule,
      ReactiveFormsModule,
      MatCheckbox
    ], template: `<form [formGroup]="registerForm" class="register-form">
  <h2>Registrarme</h2>
  <!-- ----------------------------------------------------------- -->
  <mat-form-field class="wid-100">
    <mat-label> N\xFAmero de documento</mat-label>
    <mat-icon matPrefix class="prefix-icon">badge</mat-icon>
    <input
      matInput
      placeholder=" N\xFAmero de documento sin puntos ni comas"
      formControlName="documentNumber"
    />
    @if (registerForm.controls['documentNumber'].hasError('required')) {
    <mat-error
      >El n\xFAmero de documento es <strong>obligatorio</strong>
    </mat-error>
    }
    @else if(registerForm.controls['documentNumber'].hasError('pattern') ) {
      <mat-error>Ingresa un n\xFAmero de documento v\xE1lido </mat-error>
    }
  </mat-form-field>
  <!-- ---------------------------------------------------------- -->
  <mat-form-field class="wid-100">
    <mat-label> Correo electr\xF3nico </mat-label>
    <mat-icon matPrefix class="prefix-icon">mail</mat-icon>
    <input matInput placeholder="ejemplo@gmail.com" formControlName="email">
    @if (registerForm.controls['email'].hasError('pattern') && !registerForm.controls['email'].hasError('required')) {
      <mat-error>Por favor ingresa un email v\xE1lido</mat-error>
    }
    @if (registerForm.controls['email'].hasError('required')) {
      <mat-error>El email es <strong>obligatorio</strong></mat-error>
    }
  </mat-form-field>
        <!-- ------------------------------------------------------------ -->
        <mat-checkbox (change)="clickOnCheckbox=!clickOnCheckbox">
          <span>
            Declaro que he le\xEDdo y aceptado los
            <a routerLink="/terminos-condiciones">t\xE9rminos y condiciones </a>
            aqu\xED establecidos. 
          </span>
        </mat-checkbox>
        <mat-divider></mat-divider>
        <!-- --------------------------------------------------------------- -->
        <span>
        <br class="align-center">
          Para el proceso de registro se debe verificar su correo electr\xF3nico con un c\xF3digo de verificaci\xF3n.
        </span>
        <!-- ------------------------------------------------------------- -->
        <div>
            <!--TODO: [routerLink]="['../hoja-de-vida']" este router va en los atricutos del boton pero falta que vaya a la ruta codigo de verificacion -->
            <!-- routerLinkActive="router-link-active" >  -->
          <button class="mar-05rem"
            mat-flat-button
            type="submit"
            (click)="onSubmit()"
            [disabled]="!registerForm.valid || !clickOnCheckbox || isCooldown"
            
            >
            @if (!isCooldown) { Enviar c\xF3digo }
            @else { Reintenta en {{ cooldownSeconds }}s }
          </button>
        </div>
        <!-- ------------------------------------------------------------- -->
</form>
`, styles: ["/* src/app/modules/auth/components/registrarse/registrarse.component.scss */\n:host {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  max-width: 100vw;\n  overflow-x: hidden;\n}\n.register-form {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  height: 100%;\n  max-width: 500px;\n}\n.wid-100 {\n  width: 100%;\n}\n.non-space {\n  padding: 0;\n  margin: 0;\n}\n.mar-05rem {\n  margin: 0.5rem;\n}\n/*# sourceMappingURL=registrarse.component.css.map */\n"] }]
  }], () => [{ type: FormBuilder }, { type: Router }, { type: HttpClient }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(RegistrarseComponent, { className: "RegistrarseComponent", filePath: "src/app/modules/auth/components/registrarse/registrarse.component.ts", lineNumber: 33 });
})();

// src/app/modules/auth/components/iniciar-sesion/iniciar-sesion.component.ts
function IniciarSesionComponent_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-error");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.getErrorMessage, " ");
  }
}
var IniciarSesionComponent = class _IniciarSesionComponent {
  fb;
  authService = inject(AuthService);
  router = inject(Router);
  modal = inject(ConfirmDialogService);
  loginForm;
  hidePassword = true;
  clickOnOlvidarContrasena = false;
  //control validator del email de recuperar cuenta
  emailControl = new FormControl("", [Validators.required, Validators.email]);
  get isValidInput() {
    const control = this.loginForm?.get("email");
    if (!control || !control.value)
      return false;
    const value = control.value.toString();
    return this.isEmail(value) || this.isDocument(value);
  }
  get isValidEmail() {
    const control = this.loginForm?.get("email");
    if (!control || !control.value)
      return false;
    return this.isEmail(control.value.toString());
  }
  isEmail(value) {
    return /^[a-zA-Z0-9._%+*-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(value);
  }
  isDocument(value) {
    return /^\d{8,10}$/.test(value);
  }
  get getErrorMessage() {
    const control = this.loginForm?.get("email");
    if (!control)
      return "";
    if (!control.value)
      return "Este campo es requerido";
    if (!this.isEmail(control.value) && !this.isDocument(control.value)) {
      return "Ingresa un correo electr\xF3nico v\xE1lido o un n\xFAmero de documento (8-10 d\xEDgitos)";
    }
    return "";
  }
  get tooltipMessage() {
    if (!this.loginForm?.get("email")?.value) {
      return "Debes ingresar un correo electr\xF3nico o n\xFAmero de documento";
    }
    const value = this.loginForm?.get("email")?.value;
    if (!value) {
      return "Debes ingresar un correo electr\xF3nico para recuperar tu contrase\xF1a";
    }
    if (this.isDocument(value)) {
      return "Para recuperar tu contrase\xF1a, debes ingresar un correo electr\xF3nico";
    }
    if (!this.isValidEmail) {
      return "Ingresa un correo electr\xF3nico v\xE1lido para recuperar tu contrase\xF1a";
    }
    return "";
  }
  constructor(fb) {
    this.fb = fb;
    this.loginForm = this.fb.group({
      email: [
        "",
        [
          Validators.required
        ]
      ],
      password: [
        "",
        [
          Validators.required
        ]
      ]
    });
  }
  // -----------------
  onSubmit() {
    if (this.loginForm.valid) {
      console.info("la informaci\xF3n del formulario es:", this.loginForm.value);
      this.authService.signIn(this.loginForm.value.email, this.loginForm.value.password).then(({ user, error }) => {
        if (error) {
          console.error("Error al iniciar sesi\xF3n:", error);
        } else {
          console.log("Usuario autenticado:", user);
          this.router.navigate(["/hoja-de-vida"], { queryParams: { email: this.loginForm.value.email, origin: "login" } });
          this.loginForm.reset();
        }
      });
    }
  }
  static \u0275fac = function IniciarSesionComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _IniciarSesionComponent)(\u0275\u0275directiveInject(FormBuilder));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _IniciarSesionComponent, selectors: [["app-iniciar-sesion"]], decls: 24, vars: 7, consts: [[1, "login-form", 3, "formGroup"], ["required", "", 1, "wid-100"], ["matPrefix", "", 1, "prefix-icon"], ["matInput", "", "placeholder", "ejemplo@gmail.com o n\xFAmero de documento", "formControlName", "email"], ["matInput", "", "placeholder", "Ingresa tu contrase\xF1a", "formControlName", "password", 3, "type", "readonly"], ["matSuffix", "", "mat-icon-button", "", "type", "button", 3, "click"], [1, "non-space", "main-color", "password-reset-link", 3, "routerLink"], ["mat-flat-button", "", 1, "mar-05rem", 3, "click", "disabled"]], template: function IniciarSesionComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "form", 0)(1, "h2");
      \u0275\u0275text(2, "Iniciar sesi\xF3n");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "mat-form-field", 1)(4, "mat-label");
      \u0275\u0275text(5, " Correo electr\xF3nico o n\xFAmero de documento ");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(6, "mat-icon", 2);
      \u0275\u0275text(7, "person");
      \u0275\u0275elementEnd();
      \u0275\u0275element(8, "input", 3);
      \u0275\u0275template(9, IniciarSesionComponent_Conditional_9_Template, 2, 1, "mat-error");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(10, "mat-form-field", 1)(11, "mat-label");
      \u0275\u0275text(12, " Contrase\xF1a ");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(13, "mat-icon", 2);
      \u0275\u0275text(14, "lock");
      \u0275\u0275elementEnd();
      \u0275\u0275element(15, "input", 4);
      \u0275\u0275elementStart(16, "button", 5);
      \u0275\u0275listener("click", function IniciarSesionComponent_Template_button_click_16_listener() {
        return ctx.hidePassword = !ctx.hidePassword;
      });
      \u0275\u0275elementStart(17, "mat-icon");
      \u0275\u0275text(18);
      \u0275\u0275elementEnd()()();
      \u0275\u0275elementStart(19, "a", 6);
      \u0275\u0275text(20, " \xBFHas olvidado la contrase\xF1a? ");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(21, "button", 7);
      \u0275\u0275listener("click", function IniciarSesionComponent_Template_button_click_21_listener() {
        return ctx.onSubmit();
      });
      \u0275\u0275text(22, " Iniciar sesi\xF3n ");
      \u0275\u0275elementEnd();
      \u0275\u0275element(23, "mat-divider");
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      let tmp_1_0;
      \u0275\u0275property("formGroup", ctx.loginForm);
      \u0275\u0275advance(9);
      \u0275\u0275conditional(((tmp_1_0 = ctx.loginForm.get("email")) == null ? null : tmp_1_0.invalid) ? 9 : -1);
      \u0275\u0275advance(6);
      \u0275\u0275property("type", ctx.hidePassword ? "password" : "text")("readonly", false);
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(ctx.hidePassword ? "visibility_off" : "visibility");
      \u0275\u0275advance();
      \u0275\u0275property("routerLink", "/auth/recuperar-contrasena");
      \u0275\u0275advance(2);
      \u0275\u0275property("disabled", ctx.loginForm.invalid);
    }
  }, dependencies: [
    RouterModule,
    RouterLink,
    ReactiveFormsModule,
    \u0275NgNoValidate,
    DefaultValueAccessor,
    NgControlStatus,
    NgControlStatusGroup,
    FormGroupDirective,
    FormControlName,
    MatInputModule,
    MatInput,
    MatFormField,
    MatLabel,
    MatError,
    MatPrefix,
    MatSuffix,
    MatIconModule,
    MatIcon,
    MatDivider,
    MatButtonModule,
    MatButton,
    MatIconButton,
    MatFormFieldModule,
    MatCheckboxModule,
    MatTooltipModule,
    MatCardModule
  ], styles: ["\n\n[_nghost-%COMP%] {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin: 0;\n  padding: 0;\n  width: 100%;\n}\n.login-form[_ngcontent-%COMP%] {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  max-width: 500px;\n  width: 100%;\n  height: 100%;\n  padding: 1rem;\n  padding: 0;\n}\n.login-form[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%] {\n  font-size: 1.5rem;\n  margin-bottom: 1rem;\n  color: #2d5f00;\n}\n.wid-100[_ngcontent-%COMP%] {\n  width: 100%;\n}\n@media (max-width: 768px) {\n  .wid-100[_ngcontent-%COMP%]     .mat-mdc-form-field {\n    font-size: 14px;\n  }\n  .wid-100[_ngcontent-%COMP%]   input[_ngcontent-%COMP%] {\n    font-size: 14px;\n  }\n}\n.non-space[_ngcontent-%COMP%] {\n  padding: 0;\n  margin: 0;\n}\n.mar-05rem[_ngcontent-%COMP%] {\n  margin: 0.5rem;\n}\n.main-color[_ngcontent-%COMP%] {\n  color: #2d5f00;\n}\n.password-reset-link[_ngcontent-%COMP%] {\n  position: relative;\n  display: inline-block;\n  margin: 0.4rem 0;\n  font-size: 0.9rem;\n  cursor: pointer;\n}\n  .custom-tooltip {\n  font-size: 14px !important;\n  background-color: rgba(97, 97, 97, 0.9) !important;\n  padding: 8px 12px !important;\n}\na.disabled[_ngcontent-%COMP%] {\n  color: rgba(0, 0, 0, 0.38);\n  pointer-events: none;\n  cursor: not-allowed;\n  text-decoration: none;\n}\na.disabled[_ngcontent-%COMP%]:hover {\n  text-decoration: none;\n}\n[_ngcontent-%COMP%]::-ms-reveal {\n  display: none;\n}\ninput[_ngcontent-%COMP%]::-webkit-credentials-auto-fill-button {\n  visibility: hidden;\n  position: absolute;\n  right: 0;\n}\ninput[type=password][_ngcontent-%COMP%]::-ms-reveal, \ninput[type=password][_ngcontent-%COMP%]::-ms-clear {\n  display: none;\n}\n.modal-card[_ngcontent-%COMP%] {\n  padding: 2rem;\n  margin: 2rem;\n  font-size: 1rem;\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  z-index: 1000;\n  width: 100%;\n  max-width: 700px;\n  max-height: 500px;\n  background: white;\n  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);\n  border-radius: 8px;\n}\n.modal-card[_ngcontent-%COMP%]   p[_ngcontent-%COMP%] {\n  margin: 0;\n}\n.modal-card[_ngcontent-%COMP%]   .mat-mdc-card-actions[_ngcontent-%COMP%] {\n  justify-content: center;\n}\n@media (max-width: 768px) {\n  .modal-card[_ngcontent-%COMP%]   .modal-media[_ngcontent-%COMP%] {\n    font-size: 3rem;\n  }\n  .modal-card[_ngcontent-%COMP%]   input[_ngcontent-%COMP%] {\n    font-size: 0.9rem;\n  }\n}\n/*# sourceMappingURL=iniciar-sesion.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IniciarSesionComponent, [{
    type: Component,
    args: [{ selector: "app-iniciar-sesion", imports: [
      RouterModule,
      ReactiveFormsModule,
      MatInputModule,
      MatIconModule,
      MatDivider,
      MatButtonModule,
      MatIconModule,
      MatFormFieldModule,
      MatCheckboxModule,
      MatIcon,
      MatTooltipModule,
      MatCardModule
    ], template: `<!-- --------------------------------------------form------------------------------------------------------------ -->
<form [formGroup]="loginForm" class="login-form">
  <h2>Iniciar sesi\xF3n</h2>
  <!-- ------------------------------------------------ ---------- -->
  <mat-form-field required class="wid-100">
    <mat-label> Correo electr\xF3nico o n\xFAmero de documento </mat-label>
    <mat-icon matPrefix class="prefix-icon">person</mat-icon>
    <input
      matInput
      placeholder="ejemplo@gmail.com o n\xFAmero de documento"
      formControlName="email"
    />
    @if (loginForm.get('email')?.invalid) {
    <mat-error>
      {{ getErrorMessage }}
    </mat-error>
    }
  </mat-form-field>
  <!-- ----------------------------------------------------------- -->
  <mat-form-field required class="wid-100">
    <mat-label> Contrase\xF1a </mat-label>
    <mat-icon matPrefix class="prefix-icon">lock</mat-icon>
    <input
      matInput
      [type]="hidePassword ? 'password' : 'text'"
      [readonly]="false"
      placeholder="Ingresa tu contrase\xF1a"
      formControlName="password"
    />
    <button
      matSuffix
      mat-icon-button
      (click)="hidePassword = !hidePassword"
      type="button"
    >
      <mat-icon>{{ hidePassword ? "visibility_off" : "visibility" }}</mat-icon>
    </button>
  </mat-form-field>
  <!-- ------------------------------------------------------------ -->
  <!--[state]="{ email: loginForm.get('email')?.value }"
  [class.disabled]="!isValidEmail"
  -->
  <!-- [routerLink]="isValidEmail ? '/auth/recuperar-contrasena' : null" -->
  <a 
    [routerLink]=" '/auth/recuperar-contrasena'"
    class="non-space main-color password-reset-link"
  >
    \xBFHas olvidado la contrase\xF1a?
  </a>
<!-- ------------------------------------------------------------ -->
  <button
    class="mar-05rem"
    mat-flat-button
    [disabled]="loginForm.invalid"
    (click)="onSubmit()"
  >
    Iniciar sesi\xF3n
  </button>
  <!-- ------------------------------------------------------------- -->
  <mat-divider></mat-divider>
</form>
<!-- ----------------------------------------------------------------------------------------------------------------------- -->
`, styles: ["/* src/app/modules/auth/components/iniciar-sesion/iniciar-sesion.component.scss */\n:host {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin: 0;\n  padding: 0;\n  width: 100%;\n}\n.login-form {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  max-width: 500px;\n  width: 100%;\n  height: 100%;\n  padding: 1rem;\n  padding: 0;\n}\n.login-form h2 {\n  font-size: 1.5rem;\n  margin-bottom: 1rem;\n  color: #2d5f00;\n}\n.wid-100 {\n  width: 100%;\n}\n@media (max-width: 768px) {\n  .wid-100 ::ng-deep .mat-mdc-form-field {\n    font-size: 14px;\n  }\n  .wid-100 input {\n    font-size: 14px;\n  }\n}\n.non-space {\n  padding: 0;\n  margin: 0;\n}\n.mar-05rem {\n  margin: 0.5rem;\n}\n.main-color {\n  color: #2d5f00;\n}\n.password-reset-link {\n  position: relative;\n  display: inline-block;\n  margin: 0.4rem 0;\n  font-size: 0.9rem;\n  cursor: pointer;\n}\n::ng-deep .custom-tooltip {\n  font-size: 14px !important;\n  background-color: rgba(97, 97, 97, 0.9) !important;\n  padding: 8px 12px !important;\n}\na.disabled {\n  color: rgba(0, 0, 0, 0.38);\n  pointer-events: none;\n  cursor: not-allowed;\n  text-decoration: none;\n}\na.disabled:hover {\n  text-decoration: none;\n}\n::-ms-reveal {\n  display: none;\n}\ninput::-webkit-credentials-auto-fill-button {\n  visibility: hidden;\n  position: absolute;\n  right: 0;\n}\ninput[type=password]::-ms-reveal,\ninput[type=password]::-ms-clear {\n  display: none;\n}\n.modal-card {\n  padding: 2rem;\n  margin: 2rem;\n  font-size: 1rem;\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  z-index: 1000;\n  width: 100%;\n  max-width: 700px;\n  max-height: 500px;\n  background: white;\n  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);\n  border-radius: 8px;\n}\n.modal-card p {\n  margin: 0;\n}\n.modal-card .mat-mdc-card-actions {\n  justify-content: center;\n}\n@media (max-width: 768px) {\n  .modal-card .modal-media {\n    font-size: 3rem;\n  }\n  .modal-card input {\n    font-size: 0.9rem;\n  }\n}\n/*# sourceMappingURL=iniciar-sesion.component.css.map */\n"] }]
  }], () => [{ type: FormBuilder }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(IniciarSesionComponent, { className: "IniciarSesionComponent", filePath: "src/app/modules/auth/components/iniciar-sesion/iniciar-sesion.component.ts", lineNumber: 36 });
})();

// src/app/modules/auth/components/full-container-auth/full-container-auth.component.ts
function FullContainerAuthComponent_ng_template_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-iniciar-sesion");
  }
}
function FullContainerAuthComponent_ng_template_24_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-registrarse");
  }
}
var FullContainerAuthComponent = class _FullContainerAuthComponent {
  static \u0275fac = function FullContainerAuthComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FullContainerAuthComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _FullContainerAuthComponent, selectors: [["app-full-container-auth"]], decls: 25, vars: 2, consts: [[1, "full-container"], [1, "left-container"], ["src", "assets/img/banco_info_perfiles.svg", 1, "img-perfiles"], [1, "text-perfiles"], [1, "right-container"], [3, "multi"], [3, "expanded"], [1, "panel-description"], ["matExpansionPanelContent", ""]], template: function FullContainerAuthComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0)(1, "div", 1);
      \u0275\u0275element(2, "img", 2);
      \u0275\u0275elementStart(3, "div", 3)(4, "h3");
      \u0275\u0275text(5, "Sistema hoja de vida para el talento local");
      \u0275\u0275elementEnd();
      \u0275\u0275text(6, " Este sistema tiene como objetivo ampliar las oportunidades laborales para los profesionales de la regi\xF3n mediante la recopilaci\xF3n de informaci\xF3n en una base de datos centralizada. ");
      \u0275\u0275element(7, "br");
      \u0275\u0275text(8, "Al registrarse en la plataforma y completar el formulario, su perfil quedar\xE1 disponible para consulta cuando la alcald\xEDa requiera cubrir una vacante en una profesi\xF3n espec\xEDfica. En ese momento, se revisar\xE1 la informaci\xF3n registrada en la base de datos y se seleccionar\xE1n candidatos para participar en un proceso deselecci\xF3n esta iniciativa, buscamos reunir y organizar las ofertas laborales en un \xFAnico espacio, facilitando la conexi\xF3n entre talento local y oportunidades de empleo. ");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(9, "div", 4)(10, "mat-accordion", 5)(11, "mat-expansion-panel", 6)(12, "mat-expansion-panel-header", 7)(13, "mat-panel-title");
      \u0275\u0275text(14, " Iniciar sesi\xF3n ");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(15, "mat-panel-description");
      \u0275\u0275text(16, " Ac\xE1 podr\xE1s registrar tu hoja de vida ");
      \u0275\u0275elementEnd()();
      \u0275\u0275template(17, FullContainerAuthComponent_ng_template_17_Template, 1, 0, "ng-template", 8);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(18, "mat-expansion-panel")(19, "mat-expansion-panel-header", 7)(20, "mat-panel-title");
      \u0275\u0275text(21, " Registarse ");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(22, "mat-panel-description");
      \u0275\u0275text(23, " Ac\xE1 podr\xE1s crear tu usuario para ingresar a BIPAL ");
      \u0275\u0275elementEnd()();
      \u0275\u0275template(24, FullContainerAuthComponent_ng_template_24_Template, 1, 0, "ng-template", 8);
      \u0275\u0275elementEnd()()()();
    }
    if (rf & 2) {
      \u0275\u0275advance(10);
      \u0275\u0275property("multi", false);
      \u0275\u0275advance();
      \u0275\u0275property("expanded", true);
    }
  }, dependencies: [
    MatExpansionPanel,
    MatExpansionModule,
    MatAccordion,
    MatExpansionPanelHeader,
    MatExpansionPanelTitle,
    MatExpansionPanelDescription,
    MatExpansionPanelContent,
    RegistrarseComponent,
    IniciarSesionComponent
  ], styles: ["\n\n[_nghost-%COMP%] {\n  display: flex;\n  justify-content: center;\n  width: 100%;\n  max-width: 100vw;\n}\n.title-container[_ngcontent-%COMP%] {\n  display: flex;\n  width: 100%;\n  max-width: 100vw;\n}\n.full-container[_ngcontent-%COMP%] {\n  display: flex;\n  width: 90%;\n  max-width: 1200px;\n  flex-direction: row;\n  padding-top: 2rem;\n  justify-content: center;\n}\n@media (max-width: 768px) {\n  .full-container[_ngcontent-%COMP%] {\n    flex-direction: column;\n    width: 95%;\n    padding-top: 1rem;\n  }\n}\n.left-container[_ngcontent-%COMP%] {\n  width: 50%;\n  background-color: #2D5F00;\n  color: white;\n  padding: 0;\n  border-radius: 1.7rem 0 0 1.7rem;\n  display: flex;\n  flex-direction: column;\n}\n@media (max-width: 768px) {\n  .left-container[_ngcontent-%COMP%] {\n    width: 100%;\n    border-radius: 1.7rem 1.7rem 0 0;\n    margin: 0rem;\n    padding: 0rem;\n  }\n}\n.img-perfiles[_ngcontent-%COMP%] {\n  width: 100%;\n  border-radius: 1.7rem 0 0 0;\n}\n@media (max-width: 768px) {\n  .img-perfiles[_ngcontent-%COMP%] {\n    max-height: 200px;\n    object-fit: cover;\n    border-radius: 1.7rem 1.7rem 0 0;\n  }\n}\n.text-perfiles[_ngcontent-%COMP%] {\n  padding: 2rem;\n  font-size: 1rem;\n}\n.text-perfiles[_ngcontent-%COMP%]   h3[_ngcontent-%COMP%] {\n  margin-top: 0;\n}\n@media (max-width: 768px) {\n  .text-perfiles[_ngcontent-%COMP%] {\n    padding: 0rem;\n    margin: 2rem;\n    font-size: 0.9rem;\n  }\n  .text-perfiles[_ngcontent-%COMP%]   h3[_ngcontent-%COMP%] {\n    font-size: 1.2rem;\n    padding: 1rem;\n  }\n}\n.right-container[_ngcontent-%COMP%] {\n  background-color: rgba(207, 210, 210, 0.5);\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  padding: 2rem;\n  width: 50%;\n  border-radius: 0 1.7rem 1.7rem 0;\n}\n@media (max-width: 768px) {\n  .right-container[_ngcontent-%COMP%] {\n    width: 100%;\n    padding: 1rem;\n    border-radius: 0 0 1.7rem 1.7rem;\n    margin: 0rem -1rem;\n  }\n}\n.mat-expansion-panel-header-description[_ngcontent-%COMP%] {\n  flex-basis: min-content;\n}\n@media (max-width: 855px) {\n  .mat-expansion-panel-header-description[_ngcontent-%COMP%] {\n    font-size: 0.79rem;\n  }\n}\n.panel-description[_ngcontent-%COMP%] {\n  font-size: 0.9rem;\n}\n/*# sourceMappingURL=full-container-auth.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FullContainerAuthComponent, [{
    type: Component,
    args: [{ selector: "app-full-container-auth", imports: [
      MatExpansionPanel,
      MatExpansionModule,
      RegistrarseComponent,
      IniciarSesionComponent,
      MatAccordion
    ], template: '<div class="full-container">\n    <div class="left-container">\n      <img src="assets/img/banco_info_perfiles.svg" class="img-perfiles" />\n      <div class="text-perfiles">\n        <h3>Sistema hoja de vida para el talento local</h3>\n            Este sistema tiene como objetivo ampliar las oportunidades laborales\n            para los profesionales de la regi\xF3n mediante la recopilaci\xF3n de\n            informaci\xF3n en una base de datos centralizada. \n            <br>Al registrarse en la\n            plataforma y completar el formulario, su perfil quedar\xE1 disponible para\n            consulta cuando la alcald\xEDa requiera cubrir una vacante en una profesi\xF3n\n            espec\xEDfica. En ese momento, se revisar\xE1 la informaci\xF3n registrada en la\n            base de datos y se seleccionar\xE1n candidatos para participar en un\n            proceso deselecci\xF3n esta iniciativa, buscamos reunir y organizar las\n            ofertas laborales en un \xFAnico espacio, facilitando la conexi\xF3n entre\n            talento local y oportunidades de empleo.\n      </div>\n    </div>\n    <!---------------------------------------------------------------------------------------  -->\n    <div class="right-container">\n      <!-- ------------------------------ iniciar sesion ----------------------- -->\n      <mat-accordion [multi]="false">\n        <mat-expansion-panel [expanded]="true">\n          <mat-expansion-panel-header class="panel-description">\n            <mat-panel-title> Iniciar sesi\xF3n </mat-panel-title>\n            <mat-panel-description>\n              Ac\xE1 podr\xE1s registrar tu hoja de vida\n            </mat-panel-description>\n          </mat-expansion-panel-header>\n            <ng-template matExpansionPanelContent> <!--TODO terminar de hacer el lazyloading con el ngtemplate-->\n\n              <app-iniciar-sesion></app-iniciar-sesion>\n\n            </ng-template>\n          </mat-expansion-panel>\n        <!------------------------------------------------------- -->\n    <!-- ------------------------------- registrarse ------------------------ -->\n        <mat-expansion-panel >\n          <mat-expansion-panel-header class="panel-description">\n            <mat-panel-title> Registarse </mat-panel-title>\n              <mat-panel-description>\n                Ac\xE1 podr\xE1s crear tu usuario para ingresar a BIPAL\n              </mat-panel-description>\n                </mat-expansion-panel-header>\n                <!--registrarse componente-->\n                <ng-template matExpansionPanelContent>\n                  <app-registrarse></app-registrarse>\n                </ng-template>\n                </mat-expansion-panel>\n      </mat-accordion>\n      <!------------------------------------------------------- -->\n    </div>\n  </div>\n', styles: ["/* src/app/modules/auth/components/full-container-auth/full-container-auth.component.scss */\n:host {\n  display: flex;\n  justify-content: center;\n  width: 100%;\n  max-width: 100vw;\n}\n.title-container {\n  display: flex;\n  width: 100%;\n  max-width: 100vw;\n}\n.full-container {\n  display: flex;\n  width: 90%;\n  max-width: 1200px;\n  flex-direction: row;\n  padding-top: 2rem;\n  justify-content: center;\n}\n@media (max-width: 768px) {\n  .full-container {\n    flex-direction: column;\n    width: 95%;\n    padding-top: 1rem;\n  }\n}\n.left-container {\n  width: 50%;\n  background-color: #2D5F00;\n  color: white;\n  padding: 0;\n  border-radius: 1.7rem 0 0 1.7rem;\n  display: flex;\n  flex-direction: column;\n}\n@media (max-width: 768px) {\n  .left-container {\n    width: 100%;\n    border-radius: 1.7rem 1.7rem 0 0;\n    margin: 0rem;\n    padding: 0rem;\n  }\n}\n.img-perfiles {\n  width: 100%;\n  border-radius: 1.7rem 0 0 0;\n}\n@media (max-width: 768px) {\n  .img-perfiles {\n    max-height: 200px;\n    object-fit: cover;\n    border-radius: 1.7rem 1.7rem 0 0;\n  }\n}\n.text-perfiles {\n  padding: 2rem;\n  font-size: 1rem;\n}\n.text-perfiles h3 {\n  margin-top: 0;\n}\n@media (max-width: 768px) {\n  .text-perfiles {\n    padding: 0rem;\n    margin: 2rem;\n    font-size: 0.9rem;\n  }\n  .text-perfiles h3 {\n    font-size: 1.2rem;\n    padding: 1rem;\n  }\n}\n.right-container {\n  background-color: rgba(207, 210, 210, 0.5);\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  padding: 2rem;\n  width: 50%;\n  border-radius: 0 1.7rem 1.7rem 0;\n}\n@media (max-width: 768px) {\n  .right-container {\n    width: 100%;\n    padding: 1rem;\n    border-radius: 0 0 1.7rem 1.7rem;\n    margin: 0rem -1rem;\n  }\n}\n.mat-expansion-panel-header-description {\n  flex-basis: min-content;\n}\n@media (max-width: 855px) {\n  .mat-expansion-panel-header-description {\n    font-size: 0.79rem;\n  }\n}\n.panel-description {\n  font-size: 0.9rem;\n}\n/*# sourceMappingURL=full-container-auth.component.css.map */\n"] }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(FullContainerAuthComponent, { className: "FullContainerAuthComponent", filePath: "src/app/modules/auth/components/full-container-auth/full-container-auth.component.ts", lineNumber: 22 });
})();

// src/app/core/auth/auth-user.guard.ts
var userRedirectAutenticated = (_route, state) => __async(null, null, function* () {
  const auth = inject(AuthService);
  const router = inject(Router);
  const loading = inject(LoadingService);
  loading.show();
  try {
    const session = yield auth.ensureSessionLoaded();
    if (!session)
      return true;
    if (state.url.startsWith("/auth/reset-password")) {
      return true;
    }
    if (auth.isRecoverySession) {
      if (state.url.startsWith("/auth/reset-password"))
        return true;
      return router.createUrlTree(["/auth/reset-password"]);
    }
    const { data, error } = yield auth.profile();
    if (error) {
      console.error("Error obteniendo el perfil del usuario", error);
      return true;
    }
    const onboardingStep = data?.user?.user_metadata?.onboarding_step;
    console.log("onboardingStep", onboardingStep);
    const emailConfirmedAt = data?.user?.email_confirmed_at;
    if (onboardingStep && onboardingStep !== "completed" || !emailConfirmedAt) {
      if (state.url.startsWith("/auth/crear-clave"))
        return true;
      return router.createUrlTree(["/auth/crear-clave"]);
    }
    return router.createUrlTree(["/hoja-de-vida/personal"]);
  } catch (err) {
    console.error("Error checking authentication", err);
    return true;
  } finally {
    loading.hide();
  }
});

// src/app/modules/auth/Validators/passwordValidators.ts
var PasswordValidators = class {
  static matchPassword(controlName) {
    return (control) => {
      const password = control.get(controlName);
      const confirmPassword = control.get("confirmPassword");
      if (password?.value !== confirmPassword?.value) {
        return { passwordMismatch: true };
      }
      return null;
    };
  }
  static UpperCaseCheck() {
    return (control) => {
      return /[A-Z]/.test(control.value) ? null : { uppercase: true };
    };
  }
  static numberCheck() {
    return (control) => {
      return /\d/.test(control.value) ? null : { number: true };
    };
  }
  static lengthCheck(minLength = 6) {
    return (input2) => {
      return (input2.value?.length || 0) >= minLength ? null : { minLength: true };
    };
  }
};

// src/app/modules/auth/components/password-form/password-form.component.ts
function PasswordFormComponent_Conditional_39_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-error", 8);
    \u0275\u0275text(1, "Las contrase\xF1as deben coincidir");
    \u0275\u0275elementEnd();
  }
}
var PasswordFormComponent = class _PasswordFormComponent {
  fb;
  router;
  notificationService;
  auth;
  form;
  hidePassword = true;
  hideConfirmPassword = true;
  isSubmitting = false;
  // Para controlar el estado de loading
  // parámetros de entrada
  email = input();
  numeroDocumento = input();
  constructor(fb, router, notificationService, auth) {
    this.fb = fb;
    this.router = router;
    this.notificationService = notificationService;
    this.auth = auth;
    this.form = this.fb.group({
      password: [
        "",
        [
          Validators.required,
          // Caracteres validos del regex: cualquiera que no sea emojis, espacios o cosas raras
          Validators.pattern(`^[a-zA-Z0-9!@#$%^&*()_+\\-=[\\]{}|:;"'<>,.?\\\\/]+$`),
          PasswordValidators.UpperCaseCheck(),
          PasswordValidators.lengthCheck(6),
          PasswordValidators.numberCheck()
        ]
      ],
      confirmPassword: ["", [Validators.required]]
    }, {
      validators: PasswordValidators.matchPassword("password")
    });
  }
  //---------------------------checkList---------------------------------------------------------------------
  get hasMinLength() {
    const password = this.form.get("password")?.value;
    return password ? password.length >= 6 : false;
  }
  get hasUpperCase() {
    const password = this.form.get("password")?.value;
    return password ? /[A-Z]/.test(password) : false;
  }
  get hasNumber() {
    const password = this.form.get("password")?.value;
    return password ? /[0-9]/.test(password) : false;
  }
  get hasValidCharacters() {
    const password = this.form.get("password")?.value;
    return password ? /[!@#$%^&*()_+\-=\[\]{}|:;"'<>,.?\\/]+/.test(password) : false;
  }
  get passwordsMatch() {
    const password = this.form.get("password")?.value;
    const confirmPassword = this.form.get("confirmPassword")?.value;
    return password && confirmPassword ? password === confirmPassword : false;
  }
  get isPasswordNotEmpty() {
    const password = this.form.get("password")?.value;
    return password ? password.length > 0 : false;
  }
  onSubmit() {
    if (this.form.valid && !this.isSubmitting) {
      this.isSubmitting = true;
      const password = this.form.value.password;
      this.auth.resetPasswordWithNewPassword(password).then(({ error }) => {
        if (error) {
          return false;
        }
        return this.router.navigate(["/auth"], { replaceUrl: true });
      }).catch(() => {
      }).finally(() => {
        this.isSubmitting = false;
      });
    }
  }
  static \u0275fac = function PasswordFormComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PasswordFormComponent)(\u0275\u0275directiveInject(FormBuilder), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(NotificationService), \u0275\u0275directiveInject(AuthService));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PasswordFormComponent, selectors: [["app-password-form"]], inputs: { email: [1, "email"], numeroDocumento: [1, "numeroDocumento"] }, decls: 40, vars: 20, consts: [[1, "password-form", 3, "formGroup"], [1, "password-requirements"], [1, "requirements-title"], ["required", "", 1, "wid-100"], ["matPrefix", "", 1, "prefix-icon"], ["matInput", "", "autocomplete", "off", "formControlName", "password", 3, "type", "readonly"], ["matSuffix", "", "mat-icon-button", "", "type", "button", 3, "click"], ["matInput", "", "autocomplete", "off", "placeholder", "Ingresa la misma contrase\xF1a", "formControlName", "confirmPassword", 3, "type", "readonly"], [2, "text-align", "center"]], template: function PasswordFormComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "form", 0)(1, "div", 1)(2, "p", 2);
      \u0275\u0275text(3, "La contrase\xF1a debe cumplir:");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, "ul")(5, "li")(6, "mat-icon");
      \u0275\u0275text(7);
      \u0275\u0275elementEnd();
      \u0275\u0275text(8, " Al menos 6 caracteres ");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(9, "li")(10, "mat-icon");
      \u0275\u0275text(11);
      \u0275\u0275elementEnd();
      \u0275\u0275text(12, " Al menos una may\xFAscula ");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(13, "li")(14, "mat-icon");
      \u0275\u0275text(15);
      \u0275\u0275elementEnd();
      \u0275\u0275text(16, " Al menos un n\xFAmero ");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(17, "li")(18, "mat-icon");
      \u0275\u0275text(19);
      \u0275\u0275elementEnd();
      \u0275\u0275text(20, " Al menos un car\xE1cter especial ");
      \u0275\u0275elementEnd()()();
      \u0275\u0275elementStart(21, "mat-form-field", 3)(22, "mat-label");
      \u0275\u0275text(23, "Nueva contrase\xF1a");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(24, "mat-icon", 4);
      \u0275\u0275text(25, "lock");
      \u0275\u0275elementEnd();
      \u0275\u0275element(26, "input", 5);
      \u0275\u0275elementStart(27, "button", 6);
      \u0275\u0275listener("click", function PasswordFormComponent_Template_button_click_27_listener() {
        return ctx.hidePassword = !ctx.hidePassword;
      });
      \u0275\u0275elementStart(28, "mat-icon");
      \u0275\u0275text(29);
      \u0275\u0275elementEnd()()();
      \u0275\u0275elementStart(30, "mat-form-field", 3)(31, "mat-label");
      \u0275\u0275text(32, "Confirmar contrase\xF1a");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(33, "mat-icon", 4);
      \u0275\u0275text(34, "lock");
      \u0275\u0275elementEnd();
      \u0275\u0275element(35, "input", 7);
      \u0275\u0275elementStart(36, "button", 6);
      \u0275\u0275listener("click", function PasswordFormComponent_Template_button_click_36_listener() {
        return ctx.hideConfirmPassword = !ctx.hideConfirmPassword;
      });
      \u0275\u0275elementStart(37, "mat-icon");
      \u0275\u0275text(38);
      \u0275\u0275elementEnd()()();
      \u0275\u0275template(39, PasswordFormComponent_Conditional_39_Template, 2, 0, "mat-error", 8);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("formGroup", ctx.form);
      \u0275\u0275advance(5);
      \u0275\u0275classProp("valid", ctx.hasMinLength);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate(ctx.hasMinLength ? "check_circle" : "radio_button_unchecked");
      \u0275\u0275advance(2);
      \u0275\u0275classProp("valid", ctx.hasUpperCase);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate(ctx.hasUpperCase ? "check_circle" : "radio_button_unchecked");
      \u0275\u0275advance(2);
      \u0275\u0275classProp("valid", ctx.hasNumber);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate(ctx.hasNumber ? "check_circle" : "radio_button_unchecked");
      \u0275\u0275advance(2);
      \u0275\u0275classProp("valid", ctx.hasValidCharacters);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate(ctx.hasValidCharacters ? "check_circle" : "radio_button_unchecked");
      \u0275\u0275advance(7);
      \u0275\u0275property("type", ctx.hidePassword ? "password" : "text")("readonly", false);
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(ctx.hidePassword ? "visibility_off" : "visibility");
      \u0275\u0275advance(6);
      \u0275\u0275property("type", ctx.hideConfirmPassword ? "password" : "text")("readonly", false);
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(ctx.hideConfirmPassword ? "visibility_off" : "visibility");
      \u0275\u0275advance();
      \u0275\u0275conditional(ctx.form.hasError("passwordMismatch") ? 39 : -1);
    }
  }, dependencies: [
    MatFormFieldModule,
    MatFormField,
    MatLabel,
    MatError,
    MatPrefix,
    MatSuffix,
    MatIcon,
    MatInputModule,
    MatInput,
    MatIconModule,
    ReactiveFormsModule,
    \u0275NgNoValidate,
    DefaultValueAccessor,
    NgControlStatus,
    NgControlStatusGroup,
    FormGroupDirective,
    FormControlName,
    MatButtonModule,
    MatIconButton
  ], styles: ["\n\n.reset-form[_ngcontent-%COMP%] {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  max-width: 500px;\n  width: 100%;\n  padding: 1rem;\n}\n@media (max-width: 768px) {\n  .reset-form[_ngcontent-%COMP%] {\n    padding: 0.5rem;\n  }\n  .reset-form[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%] {\n    font-size: 1.5rem;\n    margin-bottom: 1rem;\n  }\n}\n[_nghost-%COMP%] {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin: 2rem;\n  overflow-x: hidden;\n}\n@media (max-width: 768px) {\n  [_nghost-%COMP%] {\n    margin: 1rem;\n  }\n}\n.wid-100[_ngcontent-%COMP%] {\n  width: 100%;\n}\n@media (max-width: 768px) {\n  .wid-100[_ngcontent-%COMP%]     .mat-mdc-form-field {\n    font-size: 14px;\n  }\n  .wid-100[_ngcontent-%COMP%]   input[_ngcontent-%COMP%] {\n    font-size: 14px;\n  }\n}\n.non-space[_ngcontent-%COMP%] {\n  padding: 0;\n  margin: 0;\n}\n.mar-05rem[_ngcontent-%COMP%] {\n  margin: 0.8rem;\n}\n@media (max-width: 768px) {\n  .mar-05rem[_ngcontent-%COMP%] {\n    margin: 0.5rem;\n    width: 100%;\n  }\n}\n.main-color[_ngcontent-%COMP%] {\n  color: #2d5f00;\n}\n.password-requirements[_ngcontent-%COMP%] {\n  width: 100%;\n  max-width: 300px;\n  margin: 1rem auto;\n  padding: 0 1rem;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n.password-requirements[_ngcontent-%COMP%]   .requirements-title[_ngcontent-%COMP%] {\n  color: rgba(0, 0, 0, 0.6);\n  font-size: 0.9rem;\n  margin-bottom: 0.5rem;\n  text-align: center;\n}\n.password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%] {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n  width: fit-content;\n}\n.password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%] {\n  display: flex;\n  align-items: center;\n  color: rgba(0, 0, 0, 0.6);\n  font-size: 0.9rem;\n  margin-bottom: 0.3rem;\n}\n.password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%] {\n  font-size: 1rem;\n  height: 1rem;\n  width: 1rem;\n  margin-right: 0.5rem;\n}\n.password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li.valid[_ngcontent-%COMP%] {\n  color: #2d5f00;\n}\n.password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li.valid[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%] {\n  color: #2d5f00;\n}\n@media (max-width: 768px) {\n  .password-requirements[_ngcontent-%COMP%] {\n    padding: 0 0.5rem;\n  }\n  .password-requirements[_ngcontent-%COMP%]   .requirements-title[_ngcontent-%COMP%] {\n    font-size: 0.8rem;\n  }\n  .password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%] {\n    font-size: 0.8rem;\n  }\n  .password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%] {\n    font-size: 0.9rem;\n    height: 0.9rem;\n    width: 0.9rem;\n  }\n}\n[_ngcontent-%COMP%]::-ms-reveal {\n  display: none;\n}\ninput[_ngcontent-%COMP%]::-webkit-credentials-auto-fill-button {\n  visibility: hidden;\n  position: absolute;\n  right: 0;\n}\ninput[type=password][_ngcontent-%COMP%]::-ms-reveal, \ninput[type=password][_ngcontent-%COMP%]::-ms-clear {\n  display: none;\n}\n/*# sourceMappingURL=password-form.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PasswordFormComponent, [{
    type: Component,
    args: [{ selector: "app-password-form", imports: [
      MatFormFieldModule,
      MatIcon,
      MatInputModule,
      MatIconModule,
      ReactiveFormsModule,
      MatFormFieldModule,
      MatButtonModule
    ], template: `<form [formGroup]="form" class="password-form">
  <!-- Lista de validaciones -->
  <div class="password-requirements">
    <p class="requirements-title">La contrase\xF1a debe cumplir:</p>
    <ul>
      <li [class.valid]="hasMinLength">
        <mat-icon>{{
          hasMinLength ? "check_circle" : "radio_button_unchecked"
        }}</mat-icon>
        Al menos 6 caracteres
      </li>
      <li [class.valid]="hasUpperCase">
        <mat-icon>{{
          hasUpperCase ? "check_circle" : "radio_button_unchecked"
        }}</mat-icon>
        Al menos una may\xFAscula
      </li>
      <li [class.valid]="hasNumber">
        <mat-icon>{{
          hasNumber ? "check_circle" : "radio_button_unchecked"
        }}</mat-icon>
        Al menos un n\xFAmero
      </li>
      <li [class.valid]="hasValidCharacters">
        <mat-icon>{{
          hasValidCharacters ? "check_circle" : "radio_button_unchecked"
        }}</mat-icon>
        Al menos un car\xE1cter especial
      </li>
    </ul>
  </div>

  <mat-form-field required class="wid-100">
    <mat-label>Nueva contrase\xF1a</mat-label>
    <mat-icon matPrefix class="prefix-icon">lock</mat-icon>
    <input
      matInput
      [type]="hidePassword ? 'password' : 'text'"
      autocomplete="off"
      [readonly]="false"
      formControlName="password"
    />
    <button
      matSuffix
      mat-icon-button
      (click)="hidePassword = !hidePassword"
      type="button"
    >
      <mat-icon>{{ hidePassword ? "visibility_off" : "visibility" }}</mat-icon>
    </button>
  </mat-form-field>

  <mat-form-field required class="wid-100">
    <mat-label>Confirmar contrase\xF1a</mat-label>
    <mat-icon matPrefix class="prefix-icon">lock</mat-icon>
    <input
      matInput
      [type]="hideConfirmPassword ? 'password' : 'text'"
      autocomplete="off"
      [readonly]="false"
      placeholder="Ingresa la misma contrase\xF1a"
      formControlName="confirmPassword"
    />
    <button
      matSuffix
      mat-icon-button
      (click)="hideConfirmPassword = !hideConfirmPassword"
      type="button"
    >
      <mat-icon>{{
        hideConfirmPassword ? "visibility_off" : "visibility"
      }}</mat-icon>
    </button>
  </mat-form-field>

  @if (form.hasError('passwordMismatch')) {
  <mat-error style="text-align: center;">Las contrase\xF1as deben coincidir</mat-error>
  }
</form>
`, styles: ["/* src/app/modules/auth/components/password-form/password-form.component.scss */\n.reset-form {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  max-width: 500px;\n  width: 100%;\n  padding: 1rem;\n}\n@media (max-width: 768px) {\n  .reset-form {\n    padding: 0.5rem;\n  }\n  .reset-form h2 {\n    font-size: 1.5rem;\n    margin-bottom: 1rem;\n  }\n}\n:host {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin: 2rem;\n  overflow-x: hidden;\n}\n@media (max-width: 768px) {\n  :host {\n    margin: 1rem;\n  }\n}\n.wid-100 {\n  width: 100%;\n}\n@media (max-width: 768px) {\n  .wid-100 ::ng-deep .mat-mdc-form-field {\n    font-size: 14px;\n  }\n  .wid-100 input {\n    font-size: 14px;\n  }\n}\n.non-space {\n  padding: 0;\n  margin: 0;\n}\n.mar-05rem {\n  margin: 0.8rem;\n}\n@media (max-width: 768px) {\n  .mar-05rem {\n    margin: 0.5rem;\n    width: 100%;\n  }\n}\n.main-color {\n  color: #2d5f00;\n}\n.password-requirements {\n  width: 100%;\n  max-width: 300px;\n  margin: 1rem auto;\n  padding: 0 1rem;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n.password-requirements .requirements-title {\n  color: rgba(0, 0, 0, 0.6);\n  font-size: 0.9rem;\n  margin-bottom: 0.5rem;\n  text-align: center;\n}\n.password-requirements ul {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n  width: fit-content;\n}\n.password-requirements ul li {\n  display: flex;\n  align-items: center;\n  color: rgba(0, 0, 0, 0.6);\n  font-size: 0.9rem;\n  margin-bottom: 0.3rem;\n}\n.password-requirements ul li mat-icon {\n  font-size: 1rem;\n  height: 1rem;\n  width: 1rem;\n  margin-right: 0.5rem;\n}\n.password-requirements ul li.valid {\n  color: #2d5f00;\n}\n.password-requirements ul li.valid mat-icon {\n  color: #2d5f00;\n}\n@media (max-width: 768px) {\n  .password-requirements {\n    padding: 0 0.5rem;\n  }\n  .password-requirements .requirements-title {\n    font-size: 0.8rem;\n  }\n  .password-requirements ul li {\n    font-size: 0.8rem;\n  }\n  .password-requirements ul li mat-icon {\n    font-size: 0.9rem;\n    height: 0.9rem;\n    width: 0.9rem;\n  }\n}\n::-ms-reveal {\n  display: none;\n}\ninput::-webkit-credentials-auto-fill-button {\n  visibility: hidden;\n  position: absolute;\n  right: 0;\n}\ninput[type=password]::-ms-reveal,\ninput[type=password]::-ms-clear {\n  display: none;\n}\n/*# sourceMappingURL=password-form.component.css.map */\n"] }]
  }], () => [{ type: FormBuilder }, { type: Router }, { type: NotificationService }, { type: AuthService }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PasswordFormComponent, { className: "PasswordFormComponent", filePath: "src/app/modules/auth/components/password-form/password-form.component.ts", lineNumber: 26 });
})();

// src/app/modules/auth/pages/reset-password/reset-pasword-component.component.ts
function ResetPaswordComponentComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1, "Cambiar contrase\xF1a");
    \u0275\u0275elementEnd();
  }
}
function ResetPaswordComponentComponent_span_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1, "Cambiando contrase\xF1a...");
    \u0275\u0275elementEnd();
  }
}
var ResetPaswordComponentComponent = class _ResetPaswordComponentComponent {
  isSubmitting = false;
  // Para controlar el estado de loading
  auth = inject(AuthService);
  router = inject(Router);
  passwordFormComponent;
  get codeForm() {
    return this.passwordFormComponent?.form;
  }
  onSubmit() {
    if (this.codeForm?.valid && !this.isSubmitting) {
      this.isSubmitting = true;
      const password = this.codeForm.value.password;
      this.auth.resetPasswordWithNewPassword(password).then(({ error }) => {
        if (error) {
          return false;
        }
        return this.router.navigate(["/auth"], { replaceUrl: true });
      }).catch(() => {
      }).finally(() => {
        this.isSubmitting = false;
      });
    }
  }
  // Permite cancelar el flujo de recuperación y cerrar sesión explícitamente
  cancelRecovery() {
    this.auth.signOut().finally(() => {
      this.router.navigate(["/auth"], { replaceUrl: true });
    });
  }
  static \u0275fac = function ResetPaswordComponentComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ResetPaswordComponentComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ResetPaswordComponentComponent, selectors: [["app-reset-pasword-component"]], viewQuery: function ResetPaswordComponentComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(PasswordFormComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.passwordFormComponent = _t.first);
    }
  }, decls: 13, vars: 3, consts: [[1, "container-reset"], ["mat-flat-button", "", 1, "mar-05rem", 3, "click", "disabled"], [4, "ngIf"], [1, "info-warning", 2, "margin-top", "1rem"], ["mat-stroked-button", "", "color", "primary", 3, "click"]], template: function ResetPaswordComponentComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0)(1, "h2");
      \u0275\u0275text(2, "Restablecer contrase\xF1a");
      \u0275\u0275elementEnd();
      \u0275\u0275element(3, "app-password-form");
      \u0275\u0275elementStart(4, "button", 1);
      \u0275\u0275listener("click", function ResetPaswordComponentComponent_Template_button_click_4_listener() {
        return ctx.onSubmit();
      });
      \u0275\u0275template(5, ResetPaswordComponentComponent_span_5_Template, 2, 0, "span", 2)(6, ResetPaswordComponentComponent_span_6_Template, 2, 0, "span", 2);
      \u0275\u0275elementEnd();
      \u0275\u0275element(7, "mat-divider");
      \u0275\u0275elementStart(8, "div", 3)(9, "p");
      \u0275\u0275text(10, " Importante: si cierra esta p\xE1gina o la recargas sin cambiar su contrase\xF1a, la sesi\xF3n permanecer\xE1 activa y podr\xE1 ingresar al sistema autenticado autom\xE1ticamente. ");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(11, "button", 4);
      \u0275\u0275listener("click", function ResetPaswordComponentComponent_Template_button_click_11_listener() {
        return ctx.cancelRecovery();
      });
      \u0275\u0275text(12, " No cambiar clave ");
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275advance(4);
      \u0275\u0275property("disabled", !(ctx.codeForm == null ? null : ctx.codeForm.valid) || ctx.isSubmitting);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !ctx.isSubmitting);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.isSubmitting);
    }
  }, dependencies: [
    MatInputModule,
    MatIconModule,
    ReactiveFormsModule,
    MatDivider,
    MatFormFieldModule,
    MatButtonModule,
    MatButton,
    NgIf,
    PasswordFormComponent
  ], styles: ["\n\n[_nghost-%COMP%] {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  margin-top: 2rem;\n}\n.container-reset[_ngcontent-%COMP%] {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  background-color: rgba(207, 210, 210, 0.5);\n  border-radius: 1.7rem;\n  padding: 2rem;\n  margin: 0 2rem;\n  width: 100%;\n  max-width: 500px;\n}\n@media (max-width: 768px) {\n  .container-reset[_ngcontent-%COMP%] {\n    margin: 1rem;\n    padding: 1rem;\n    border-radius: 1rem;\n  }\n}\n.wid-100[_ngcontent-%COMP%] {\n  width: 100%;\n}\n@media (max-width: 768px) {\n  .wid-100[_ngcontent-%COMP%]     .mat-mdc-form-field {\n    font-size: 14px;\n  }\n  .wid-100[_ngcontent-%COMP%]   input[_ngcontent-%COMP%] {\n    font-size: 14px;\n  }\n}\n.non-space[_ngcontent-%COMP%] {\n  padding: 0;\n  margin: 0;\n}\n.mar-05rem[_ngcontent-%COMP%] {\n  margin: 0.8rem;\n}\n@media (max-width: 768px) {\n  .mar-05rem[_ngcontent-%COMP%] {\n    margin: 0.5rem;\n    width: 100%;\n  }\n}\n.main-color[_ngcontent-%COMP%] {\n  color: #2d5f00;\n}\n.password-requirements[_ngcontent-%COMP%] {\n  width: 100%;\n  max-width: 300px;\n  margin: 1rem auto;\n  padding: 0 1rem;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n.password-requirements[_ngcontent-%COMP%]   .requirements-title[_ngcontent-%COMP%] {\n  color: rgba(0, 0, 0, 0.6);\n  font-size: 0.9rem;\n  margin-bottom: 0.5rem;\n  text-align: center;\n}\n.password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%] {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n  width: fit-content;\n}\n.password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%] {\n  display: flex;\n  align-items: center;\n  color: rgba(0, 0, 0, 0.6);\n  font-size: 0.9rem;\n  margin-bottom: 0.3rem;\n}\n.password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%] {\n  font-size: 1rem;\n  height: 1rem;\n  width: 1rem;\n  margin-right: 0.5rem;\n}\n.password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li.valid[_ngcontent-%COMP%] {\n  color: #2d5f00;\n}\n.password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li.valid[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%] {\n  color: #2d5f00;\n}\n@media (max-width: 768px) {\n  .password-requirements[_ngcontent-%COMP%] {\n    padding: 0 0.5rem;\n  }\n  .password-requirements[_ngcontent-%COMP%]   .requirements-title[_ngcontent-%COMP%] {\n    font-size: 0.8rem;\n  }\n  .password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%] {\n    font-size: 0.8rem;\n  }\n  .password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%] {\n    font-size: 0.9rem;\n    height: 0.9rem;\n    width: 0.9rem;\n  }\n}\n[_ngcontent-%COMP%]::-ms-reveal {\n  display: none;\n}\ninput[_ngcontent-%COMP%]::-webkit-credentials-auto-fill-button {\n  visibility: hidden;\n  position: absolute;\n  right: 0;\n}\ninput[type=password][_ngcontent-%COMP%]::-ms-reveal, \ninput[type=password][_ngcontent-%COMP%]::-ms-clear {\n  display: none;\n}\n/*# sourceMappingURL=reset-pasword-component.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResetPaswordComponentComponent, [{
    type: Component,
    args: [{ selector: "app-reset-pasword-component", imports: [
      MatInputModule,
      MatIconModule,
      ReactiveFormsModule,
      MatDivider,
      MatFormFieldModule,
      MatButtonModule,
      NgIf,
      PasswordFormComponent
    ], template: '<div class="container-reset">\n  <h2>Restablecer contrase\xF1a</h2>\n\n  <app-password-form></app-password-form>\n\n  <button\n    mat-flat-button\n    class="mar-05rem"\n    [disabled]="!codeForm?.valid || isSubmitting"\n    (click)="onSubmit()"\n  >\n    <span *ngIf="!isSubmitting">Cambiar contrase\xF1a</span>\n    <span *ngIf="isSubmitting">Cambiando contrase\xF1a...</span>\n  </button>\n\n  <mat-divider></mat-divider>\n\n  <div class="info-warning" style="margin-top: 1rem">\n    <p>\n      Importante: si cierra esta p\xE1gina o la recargas sin cambiar su contrase\xF1a,\n      la sesi\xF3n permanecer\xE1 activa y podr\xE1 ingresar al sistema autenticado\n      autom\xE1ticamente.\n    </p>\n  </div>\n  <button mat-stroked-button color="primary" (click)="cancelRecovery()">\n    No cambiar clave\n  </button>\n</div>\n', styles: ["/* src/app/modules/auth/pages/reset-password/reset-pasword-component.component.scss */\n:host {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  margin-top: 2rem;\n}\n.container-reset {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  background-color: rgba(207, 210, 210, 0.5);\n  border-radius: 1.7rem;\n  padding: 2rem;\n  margin: 0 2rem;\n  width: 100%;\n  max-width: 500px;\n}\n@media (max-width: 768px) {\n  .container-reset {\n    margin: 1rem;\n    padding: 1rem;\n    border-radius: 1rem;\n  }\n}\n.wid-100 {\n  width: 100%;\n}\n@media (max-width: 768px) {\n  .wid-100 ::ng-deep .mat-mdc-form-field {\n    font-size: 14px;\n  }\n  .wid-100 input {\n    font-size: 14px;\n  }\n}\n.non-space {\n  padding: 0;\n  margin: 0;\n}\n.mar-05rem {\n  margin: 0.8rem;\n}\n@media (max-width: 768px) {\n  .mar-05rem {\n    margin: 0.5rem;\n    width: 100%;\n  }\n}\n.main-color {\n  color: #2d5f00;\n}\n.password-requirements {\n  width: 100%;\n  max-width: 300px;\n  margin: 1rem auto;\n  padding: 0 1rem;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n.password-requirements .requirements-title {\n  color: rgba(0, 0, 0, 0.6);\n  font-size: 0.9rem;\n  margin-bottom: 0.5rem;\n  text-align: center;\n}\n.password-requirements ul {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n  width: fit-content;\n}\n.password-requirements ul li {\n  display: flex;\n  align-items: center;\n  color: rgba(0, 0, 0, 0.6);\n  font-size: 0.9rem;\n  margin-bottom: 0.3rem;\n}\n.password-requirements ul li mat-icon {\n  font-size: 1rem;\n  height: 1rem;\n  width: 1rem;\n  margin-right: 0.5rem;\n}\n.password-requirements ul li.valid {\n  color: #2d5f00;\n}\n.password-requirements ul li.valid mat-icon {\n  color: #2d5f00;\n}\n@media (max-width: 768px) {\n  .password-requirements {\n    padding: 0 0.5rem;\n  }\n  .password-requirements .requirements-title {\n    font-size: 0.8rem;\n  }\n  .password-requirements ul li {\n    font-size: 0.8rem;\n  }\n  .password-requirements ul li mat-icon {\n    font-size: 0.9rem;\n    height: 0.9rem;\n    width: 0.9rem;\n  }\n}\n::-ms-reveal {\n  display: none;\n}\ninput::-webkit-credentials-auto-fill-button {\n  visibility: hidden;\n  position: absolute;\n  right: 0;\n}\ninput[type=password]::-ms-reveal,\ninput[type=password]::-ms-clear {\n  display: none;\n}\n/*# sourceMappingURL=reset-pasword-component.component.css.map */\n"] }]
  }], null, { passwordFormComponent: [{
    type: ViewChild,
    args: [PasswordFormComponent]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ResetPaswordComponentComponent, { className: "ResetPaswordComponentComponent", filePath: "src/app/modules/auth/pages/reset-password/reset-pasword-component.component.ts", lineNumber: 36 });
})();

// src/app/modules/auth/components/recuperar-cuenta/recuperar-cuenta.component.ts
function RecuperarCuentaComponent_Conditional_13_mat_error_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-error");
    \u0275\u0275text(1, " El correo es obligatorio ");
    \u0275\u0275elementEnd();
  }
}
function RecuperarCuentaComponent_Conditional_13_mat_error_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-error");
    \u0275\u0275text(1, " Ingresa un correo v\xE1lido ");
    \u0275\u0275elementEnd();
  }
}
function RecuperarCuentaComponent_Conditional_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, RecuperarCuentaComponent_Conditional_13_mat_error_0_Template, 2, 0, "mat-error", 7)(1, RecuperarCuentaComponent_Conditional_13_mat_error_1_Template, 2, 0, "mat-error", 7);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r0.emailControl.hasError("required"));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.emailControl.hasError("email"));
  }
}
var RecuperarCuentaComponent = class _RecuperarCuentaComponent {
  auth = inject(AuthService);
  router = inject(Router);
  //control validator del email de recuperar cuenta
  emailControl = new FormControl("", [Validators.required, Validators.email]);
  recuperarCuentaClickeado = false;
  recuperarCuenta() {
    this.emailControl.markAsUntouched();
    if (this.emailControl.valid) {
      this.auth.sendPasswordReset(this.emailControl.value).then(({ error }) => {
        if (error)
          return;
        this.router.navigate(["/auth/comprobar-codigo"], {
          state: { email: this.emailControl.value },
          queryParams: { email: this.emailControl.value, origin: "reset" }
        });
      });
    }
  }
  cerrarModal() {
    this.router.navigate(["/auth/"]);
  }
  static \u0275fac = function RecuperarCuentaComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RecuperarCuentaComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _RecuperarCuentaComponent, selectors: [["app-recuperar-cuenta"]], decls: 19, vars: 3, consts: [["appearance", "outlined", 1, "modal-card", "modal-overlay"], ["appearance", "fill"], ["matPrefix", "", 1, "prefix-icon"], ["matInput", "", "placeholder", "Ingresa tu correo", 3, "formControl"], [1, "botones-acciones"], ["mat-stroked-button", "", 3, "click"], ["mat-flat-button", "", 3, "click", "disabled"], [4, "ngIf"]], template: function RecuperarCuentaComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "mat-card", 0)(1, "mat-card-header")(2, "mat-card-title");
      \u0275\u0275text(3, " Recuperar contrase\xF1a");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, "mat-card-content")(5, "p");
      \u0275\u0275text(6, "Ingrese los siguientes datos para crear una nueva contrase\xF1a");
      \u0275\u0275elementEnd()()();
      \u0275\u0275elementStart(7, "mat-form-field", 1)(8, "mat-label");
      \u0275\u0275text(9, "Correo electr\xF3nico");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(10, "mat-icon", 2);
      \u0275\u0275text(11, "person");
      \u0275\u0275elementEnd();
      \u0275\u0275element(12, "input", 3);
      \u0275\u0275template(13, RecuperarCuentaComponent_Conditional_13_Template, 2, 2);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(14, "mat-card-actions", 4)(15, "button", 5);
      \u0275\u0275listener("click", function RecuperarCuentaComponent_Template_button_click_15_listener() {
        return ctx.cerrarModal();
      });
      \u0275\u0275text(16, "Cancelar");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(17, "button", 6);
      \u0275\u0275listener("click", function RecuperarCuentaComponent_Template_button_click_17_listener() {
        return ctx.recuperarCuenta();
      });
      \u0275\u0275text(18, " Restablecer contrase\xF1a ");
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275advance(12);
      \u0275\u0275property("formControl", ctx.emailControl);
      \u0275\u0275advance();
      \u0275\u0275conditional(ctx.emailControl.invalid && ctx.emailControl.touched ? 13 : -1);
      \u0275\u0275advance(4);
      \u0275\u0275property("disabled", ctx.emailControl.invalid);
    }
  }, dependencies: [
    MatCardModule,
    MatCard,
    MatCardActions,
    MatCardContent,
    MatCardHeader,
    MatCardTitle,
    ReactiveFormsModule,
    DefaultValueAccessor,
    NgControlStatus,
    FormControlDirective,
    FormsModule,
    MatFormFieldModule,
    MatFormField,
    MatLabel,
    MatError,
    MatPrefix,
    MatInput,
    MatButton,
    MatIcon
  ], styles: ["\n\n.modal-card[_ngcontent-%COMP%] {\n  display: flex;\n  padding: 1rem 2rem;\n  margin: 2rem;\n  flex-direction: column;\n}\n.modal-card[_ngcontent-%COMP%]   p[_ngcontent-%COMP%] {\n  margin: 0;\n}\n.mat-mdc-card-header[_ngcontent-%COMP%] {\n  flex-direction: column;\n}\n.mat-mdc-card-content[_ngcontent-%COMP%]:last-child {\n  padding: 1rem 0;\n}\n.botones-acciones[_ngcontent-%COMP%] {\n  display: flex;\n  justify-content: center;\n  gap: 12px;\n  padding-top: 16px;\n}\n.botones-acciones[_ngcontent-%COMP%]   button[_ngcontent-%COMP%] {\n  min-width: 140px;\n}\n/*# sourceMappingURL=recuperar-cuenta.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RecuperarCuentaComponent, [{
    type: Component,
    args: [{ selector: "app-recuperar-cuenta", imports: [
      MatCardModule,
      ReactiveFormsModule,
      FormsModule,
      MatFormFieldModule,
      MatLabel,
      MatInput,
      MatButton,
      MatCard,
      MatIcon,
      MatError
    ], template: `<mat-card class="modal-card modal-overlay" appearance="outlined">
  <mat-card-header>
    <mat-card-title> Recuperar contrase\xF1a</mat-card-title>
    <mat-card-content>
      <p>Ingrese los siguientes datos para crear una nueva contrase\xF1a</p>
    </mat-card-content>
  </mat-card-header>

  <mat-form-field appearance="fill">
    <mat-label>Correo electr\xF3nico</mat-label>
    <mat-icon matPrefix class="prefix-icon">person</mat-icon>
    <input
      matInput
      placeholder="Ingresa tu correo"
      [formControl]="emailControl"
    />
    @if (emailControl.invalid && emailControl.touched) {
    <mat-error *ngIf="emailControl.hasError('required')">
      El correo es obligatorio
    </mat-error>
    <mat-error *ngIf="emailControl.hasError('email')">
      Ingresa un correo v\xE1lido
    </mat-error>
    }
  </mat-form-field>

  <mat-card-actions class="botones-acciones">
    <button mat-stroked-button (click)="cerrarModal()">Cancelar</button>
    <button
      mat-flat-button
      [disabled]="emailControl.invalid"
      (click)="recuperarCuenta()"
    >
      Restablecer contrase\xF1a
    </button>
  </mat-card-actions>
</mat-card>
`, styles: ["/* src/app/modules/auth/components/recuperar-cuenta/recuperar-cuenta.component.scss */\n.modal-card {\n  display: flex;\n  padding: 1rem 2rem;\n  margin: 2rem;\n  flex-direction: column;\n}\n.modal-card p {\n  margin: 0;\n}\n.mat-mdc-card-header {\n  flex-direction: column;\n}\n.mat-mdc-card-content:last-child {\n  padding: 1rem 0;\n}\n.botones-acciones {\n  display: flex;\n  justify-content: center;\n  gap: 12px;\n  padding-top: 16px;\n}\n.botones-acciones button {\n  min-width: 140px;\n}\n/*# sourceMappingURL=recuperar-cuenta.component.css.map */\n"] }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(RecuperarCuentaComponent, { className: "RecuperarCuentaComponent", filePath: "src/app/modules/auth/components/recuperar-cuenta/recuperar-cuenta.component.ts", lineNumber: 34 });
})();

// src/app/modules/auth/components/container-auth/container-auth.component.ts
var _c05 = ["*"];
var ContainerAuthComponent = class _ContainerAuthComponent {
  //injectamos las dependencias
  route = inject(ActivatedRoute);
  router = inject(Router);
  emailUser = signal("");
  documentoUser = signal(null);
  comprobarCodigoP = true;
  ngOnInit() {
    this.route.queryParams.subscribe((params) => {
      this.emailUser.set(params["email"] || "");
      this.documentoUser.set(parseInt(params["documento"]) || null);
    });
    console.log("Email recibido en crear-usuario:", this.emailUser(), this.documentoUser());
  }
  volver() {
    this.router.navigate(["/auth"]);
  }
  verificarCodigoValido(mostrarComprobarCodigo) {
    this.comprobarCodigoP = mostrarComprobarCodigo;
  }
  static \u0275fac = function ContainerAuthComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContainerAuthComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ContainerAuthComponent, selectors: [["app-container-auth"]], ngContentSelectors: _c05, decls: 6, vars: 0, consts: [[1, "mat-card-container"], ["src", "assets/img/banco_info_perfiles.svg", 1, "img-perfiles"]], template: function ContainerAuthComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "div")(1, "mat-card", 0);
      \u0275\u0275element(2, "img", 1);
      \u0275\u0275elementStart(3, "div");
      \u0275\u0275element(4, "br");
      \u0275\u0275projection(5);
      \u0275\u0275elementEnd()()();
    }
  }, dependencies: [MatCard, MatButtonModule], styles: ["\n\n.mat-card-container[_ngcontent-%COMP%] {\n  margin-top: 2rem;\n  padding: 2rem;\n  background-color: #eeeeee;\n  border-radius: 1.7rem;\n  max-width: 860px;\n}\n.img-perfiles[_ngcontent-%COMP%] {\n  border-radius: 1.7rem 1.7rem 0rem;\n  width: 100%;\n}\n/*# sourceMappingURL=container-auth.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContainerAuthComponent, [{
    type: Component,
    args: [{ selector: "app-container-auth", imports: [MatCard, MatButtonModule], template: '<div>\n    <mat-card class="mat-card-container">\n        <img src="assets/img/banco_info_perfiles.svg" class="img-perfiles" />\n        <div>\n            <br>\n            <!-- contenido aqui, ojito con el height porque esta a la\n            <br> fuerza y no depende del tama\xF1o de los componentes que van a qui adentro xd -->\n            <!-- @if (comprobarCodigoP) {\n                <button mat-button (click)="volver()">\n                    <mat-icon>arrow_back</mat-icon>\n                    volver</button>\n                <app-comprobar-codigo [email]="emailUser()"  (next)="verificarCodigoValido($event)"> </app-comprobar-codigo>\n\n            }\n            @else{\n                <app-crear-clave></app-crear-clave>\n            } -->\n            <ng-content></ng-content>\n        </div>\n    </mat-card>\n</div>\n', styles: ["/* src/app/modules/auth/components/container-auth/container-auth.component.scss */\n.mat-card-container {\n  margin-top: 2rem;\n  padding: 2rem;\n  background-color: #eeeeee;\n  border-radius: 1.7rem;\n  max-width: 860px;\n}\n.img-perfiles {\n  border-radius: 1.7rem 1.7rem 0rem;\n  width: 100%;\n}\n/*# sourceMappingURL=container-auth.component.css.map */\n"] }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ContainerAuthComponent, { className: "ContainerAuthComponent", filePath: "src/app/modules/auth/components/container-auth/container-auth.component.ts", lineNumber: 12 });
})();

// src/app/modules/auth/components/comprobar-codigo/comprobar-codigo.component.ts
function ComprobarCodigoComponent_For_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-form-field", 3)(1, "input", 6);
    \u0275\u0275listener("input", function ComprobarCodigoComponent_For_7_Template_input_input_1_listener($event) {
      const $index_r2 = \u0275\u0275restoreView(_r1).$index;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onInputChange($event, $index_r2));
    })("keydown", function ComprobarCodigoComponent_For_7_Template_input_keydown_1_listener($event) {
      const $index_r2 = \u0275\u0275restoreView(_r1).$index;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onKeyDown($event, $index_r2));
    })("paste", function ComprobarCodigoComponent_For_7_Template_input_paste_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onPaste($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const control_i_r4 = ctx.$implicit;
    const $index_r2 = ctx.$index;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("formControl", ctx_r2.toFormControl(control_i_r4))("id", "input" + $index_r2);
  }
}
function ComprobarCodigoComponent_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "mat-error");
    \u0275\u0275text(2, "El campo num\xE9rico es obligatorio ");
    \u0275\u0275elementEnd()();
  }
}
var ComprobarCodigoComponent = class _ComprobarCodigoComponent {
  fb;
  route;
  router;
  authServ;
  email = input("");
  origin = "create";
  // form:FormControl=new form
  formCode;
  // Estado derivado para mensajes y navegación
  currentOrigin = "create";
  emailText = "";
  constructor(fb, route, router, authServ) {
    this.fb = fb;
    this.route = route;
    this.router = router;
    this.authServ = authServ;
    this.formCode = this.fb.group({
      digitsGroup: this.fb.array([
        this.fb.control("", [Validators.required, Validators.pattern(/^\d$/)]),
        this.fb.control("", [Validators.required, Validators.pattern(/^\d$/)]),
        new FormControl("", [Validators.required, Validators.pattern(/^\d$/)]),
        new FormControl("", [Validators.required, Validators.pattern(/^\d$/)]),
        new FormControl("", [Validators.required, Validators.pattern(/^\d$/)]),
        new FormControl("", [Validators.required, Validators.pattern(/^\d$/)])
      ])
    });
    const qp = this.route.snapshot.queryParamMap;
    this.currentOrigin = qp.get("origin") ?? this.origin;
    this.emailText = qp.get("email") ?? this.email();
  }
  //este get accede a la informacion del controler digitGroup del formulario formcode
  get digitGroup() {
    return this.formCode.get("digitsGroup");
  }
  verificarCodigo() {
    if (this.formCode.valid) {
      const codigoIngresadoH = this.digitGroup.value.join("");
      console.log("el codigo ingresado es: ", codigoIngresadoH, "?");
      const originParam = this.currentOrigin;
      const email = this.emailText;
      if (originParam === "reset") {
        this.authServ.verifyRecoveryCode(email, codigoIngresadoH).then((res) => {
          if (res.error || !res.verified)
            return;
          this.router.navigate(["/auth/reset-password"], {
            queryParams: { email }
          });
        });
      } else {
        this.authServ.verifyEmailCode(email, codigoIngresadoH).then((response) => {
          if (response.error) {
            console.error("Error al verificar el c\xF3digo:", response.error.message);
            return;
          }
          this.router.navigate(["/auth/crear-clave"], {
            queryParams: { email }
          });
        });
      }
    }
  }
  // Copys dinámicos
  get heading() {
    return this.currentOrigin === "reset" ? "C\xF3digo de recuperaci\xF3n" : "C\xF3digo de verificaci\xF3n";
  }
  get description() {
    const email = this.emailText;
    return this.currentOrigin === "reset" ? `Si el correo est\xE1 asociado a un usuario, ingresa el c\xF3digo de recuperaci\xF3n que enviamos a <strong>${email}</strong> para restablecer su contrase\xF1a.` : `Ingresa el c\xF3digo de verificaci\xF3n que enviamos a tu <strong>${email}</strong> para continuar con el registro.`;
  }
  toFormControl(item) {
    return item;
  }
  /**
   * Maneja el cambio de input para auto-avanzar al siguiente campo
   * @param event - Evento del input
   * @param index - Índice del input actual
   */
  onInputChange(event, index) {
    const value = event.target.value;
    if (value && !/^\d$/.test(value)) {
      event.target.value = "";
      this.digitGroup.controls[index].setValue("");
      return;
    }
    if (value && index < this.digitGroup.controls.length - 1) {
      this.focusNextInput(index + 1);
    }
  }
  /**
   * Maneja las teclas especiales como Backspace y flechas
   * @param event - Evento del teclado
   * @param index - Índice del input actual
   */
  onKeyDown(event, index) {
    if (event.key === "Backspace" && !this.digitGroup.controls[index].value && index > 0) {
      this.focusPreviousInput(index - 1);
    }
    if (event.key === "ArrowRight" && index < this.digitGroup.controls.length - 1) {
      this.focusNextInput(index + 1);
    }
    if (event.key === "ArrowLeft" && index > 0) {
      this.focusPreviousInput(index - 1);
    }
    const allowedKeys = [
      "Backspace",
      "Delete",
      "ArrowLeft",
      "ArrowRight",
      "Tab"
    ];
    if (!allowedKeys.includes(event.key) && !/^\d$/.test(event.key)) {
      event.preventDefault();
    }
  }
  /**
   * Maneja el pegado de códigos completos
   * @param event - Evento de pegado
   */
  onPaste(event) {
    event.preventDefault();
    const pastedData = event.clipboardData?.getData("text") || "";
    if (/^\d{6}$/.test(pastedData)) {
      const digits = pastedData.split("");
      digits.forEach((digit, index) => {
        if (index < this.digitGroup.controls.length) {
          this.digitGroup.controls[index].setValue(digit);
        }
      });
      this.focusNextInput(5);
    }
  }
  /**
   * Enfoca el siguiente input
   * @param index - Índice del input a enfocar
   */
  focusNextInput(index) {
    const nextInput = document.querySelector(`#input${index}`);
    if (nextInput) {
      nextInput.focus();
      nextInput.select();
    }
  }
  /**
   * Enfoca el input anterior
   * @param index - Índice del input a enfocar
   */
  focusPreviousInput(index) {
    const prevInput = document.querySelector(`#input${index}`);
    if (prevInput) {
      prevInput.focus();
      prevInput.select();
    }
  }
  static \u0275fac = function ComprobarCodigoComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ComprobarCodigoComponent)(\u0275\u0275directiveInject(FormBuilder), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(AuthService));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ComprobarCodigoComponent, selectors: [["app-comprobar-codigo"]], inputs: { email: [1, "email"], origin: "origin" }, decls: 14, vars: 4, consts: [["appearance", "outlined", 1, "card-container"], [1, "container-code"], [1, "squares-for-code"], ["appearance", "outline", 1, "squares"], [3, "innerHTML"], ["mat-stroked-button", "", 3, "click", "disabled"], ["matInput", "", "maxlength", "1", 2, "text-align", "center", 3, "input", "keydown", "paste", "formControl", "id"]], template: function ComprobarCodigoComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "app-container-auth")(1, "mat-card", 0)(2, "h3");
      \u0275\u0275text(3);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, "div", 1)(5, "div", 2);
      \u0275\u0275repeaterCreate(6, ComprobarCodigoComponent_For_7_Template, 2, 2, "mat-form-field", 3, \u0275\u0275repeaterTrackByIndex);
      \u0275\u0275elementEnd();
      \u0275\u0275template(8, ComprobarCodigoComponent_Conditional_8_Template, 3, 0, "div");
      \u0275\u0275element(9, "br");
      \u0275\u0275elementEnd();
      \u0275\u0275element(10, "span", 4)(11, "br");
      \u0275\u0275elementStart(12, "button", 5);
      \u0275\u0275listener("click", function ComprobarCodigoComponent_Template_button_click_12_listener() {
        return ctx.verificarCodigo();
      });
      \u0275\u0275text(13, " Continuar ");
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(ctx.heading);
      \u0275\u0275advance(3);
      \u0275\u0275repeater(ctx.digitGroup.controls);
      \u0275\u0275advance(2);
      \u0275\u0275conditional(ctx.formCode.invalid && ctx.formCode.touched ? 8 : -1);
      \u0275\u0275advance(2);
      \u0275\u0275property("innerHTML", ctx.description, \u0275\u0275sanitizeHtml);
      \u0275\u0275advance(2);
      \u0275\u0275property("disabled", ctx.formCode.invalid);
    }
  }, dependencies: [
    MatCard,
    MatInputModule,
    MatInput,
    MatFormField,
    MatError,
    MatButtonModule,
    MatButton,
    MatFormFieldModule,
    ReactiveFormsModule,
    DefaultValueAccessor,
    NgControlStatus,
    MaxLengthValidator,
    FormControlDirective,
    ContainerAuthComponent
  ], styles: ["\n\n[_nghost-%COMP%] {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n}\n.card-container[_ngcontent-%COMP%] {\n  display: flex;\n  align-items: center;\n  padding: 2rem;\n}\n.squares-for-code[_ngcontent-%COMP%] {\n  display: flex;\n  gap: 8px;\n}\n.squares-for-code[_ngcontent-%COMP%]   .squares[_ngcontent-%COMP%] {\n  width: 2.5rem;\n}\n.squares-for-code[_ngcontent-%COMP%]   .squares[_ngcontent-%COMP%]     .mat-mdc-text-field-wrapper {\n  height: 2.5rem;\n}\n.container-code[_ngcontent-%COMP%] {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n/*# sourceMappingURL=comprobar-codigo.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComprobarCodigoComponent, [{
    type: Component,
    args: [{ selector: "app-comprobar-codigo", imports: [
      MatCard,
      MatInputModule,
      MatButtonModule,
      MatFormFieldModule,
      ReactiveFormsModule,
      ContainerAuthComponent
    ], template: `<app-container-auth>
<mat-card class="card-container" appearance="outlined">
  <h3>{{ heading }}</h3>
  <div class="container-code">
    <div class="squares-for-code">
      @for(control_i of digitGroup.controls; track $index){
      <mat-form-field appearance="outline" class="squares">
        <input
          matInput
          maxlength="1"
          [formControl]="toFormControl(control_i)"
          style="text-align: center"
          (input)="onInputChange($event, $index)"
          (keydown)="onKeyDown($event, $index)"
          (paste)="onPaste($event)"
          [id]="'input' + $index"
        />

        <!-- condicionales para acaparar los errores de los matformFields --------------------------------------------------------
              se accede por medio del get digitGrouo debido a que molesta si se accede a los controls directamente por problema de
              tipado de que si se accede directamente lo toma como AbstractControl -->
        <!-- <div class="ayuda">
              
              @if (digitGroup.controls[$index].hasError('required')) {
                  <mat-error> El campo es <strong>obligatorio</strong></mat-error>
              }
              Si el usuario entra al input y se sale del mismo a otro campo o fuera del input 
              @else if (digitGroup.controls[$index].hasError('pattern')) {
                  <mat-error>Ingresa un n\xFAmero de documento v\xE1lido </mat-error>
              } 
          </div> -->
      </mat-form-field>
      }
    </div>
    @if(formCode.invalid && formCode.touched){
    <div>
      <mat-error>El campo num\xE9rico es obligatorio </mat-error>
    </div>
    }
    <!-- ------------------------------------------------------------------------------------------------------------------------------- -->
    <br />
  </div>
  <span [innerHTML]="description"></span>
  <br />

  <!-- Bot\xF3n continuar que navega seg\xFAn el origen -->
  <button
    mat-stroked-button
    (click)="verificarCodigo()"
    [disabled]="formCode.invalid"
  >
    Continuar
  </button>
</mat-card>
</app-container-auth>
`, styles: ["/* src/app/modules/auth/components/comprobar-codigo/comprobar-codigo.component.scss */\n:host {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n}\n.card-container {\n  display: flex;\n  align-items: center;\n  padding: 2rem;\n}\n.squares-for-code {\n  display: flex;\n  gap: 8px;\n}\n.squares-for-code .squares {\n  width: 2.5rem;\n}\n.squares-for-code .squares ::ng-deep .mat-mdc-text-field-wrapper {\n  height: 2.5rem;\n}\n.container-code {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n/*# sourceMappingURL=comprobar-codigo.component.css.map */\n"] }]
  }], () => [{ type: FormBuilder }, { type: ActivatedRoute }, { type: Router }, { type: AuthService }], { origin: [{
    type: Input
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ComprobarCodigoComponent, { className: "ComprobarCodigoComponent", filePath: "src/app/modules/auth/components/comprobar-codigo/comprobar-codigo.component.ts", lineNumber: 38 });
})();

// src/app/modules/auth/pages/crear-clave/crear-clave.component.ts
function CrearClaveComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1, "Crear usuario");
    \u0275\u0275elementEnd();
  }
}
function CrearClaveComponent_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1, "Creando usuario...");
    \u0275\u0275elementEnd();
  }
}
var CrearClaveComponent = class _CrearClaveComponent {
  authService = inject(AuthService);
  router = inject(Router);
  infoService = inject(InformacionPersonalService);
  isSubmitting = false;
  passwordFormComponent;
  get codeForm() {
    return this.passwordFormComponent?.form;
  }
  crearUsuario() {
    if (this.codeForm.valid && !this.isSubmitting) {
      this.isSubmitting = true;
      this.authService.createUserAccount(this.codeForm.value.password).then(() => __async(this, null, function* () {
        console.log("Usuario creado exitosamente");
        const numeroDocumento = this.authService.session?.user?.user_metadata?.numeroDocumento;
        if (numeroDocumento) {
          try {
            const migrado = yield firstValueFrom(this.infoService.migrarUsuarioPorNumeroDocumento(numeroDocumento));
            if (migrado) {
              yield this.authService.reloadUser();
            }
          } catch (e) {
            console.warn("Migraci\xF3n no completada:", e.message);
          }
        }
        this.router.navigate(["/hoja-de-vida"], { replaceUrl: true });
      })).catch((error) => {
        console.error("Error al crear el usuario:", error);
      }).finally(() => {
        this.isSubmitting = false;
      });
    }
  }
  static \u0275fac = function CrearClaveComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CrearClaveComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _CrearClaveComponent, selectors: [["app-crear-clave"]], viewQuery: function CrearClaveComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(PasswordFormComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.passwordFormComponent = _t.first);
    }
  }, decls: 9, vars: 3, consts: [["appearance", "outlined", 1, "mat-card-edited"], [1, "key-form"], ["mat-flat-button", "", 3, "click", "disabled"]], template: function CrearClaveComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "app-container-auth")(1, "mat-card", 0)(2, "section", 1)(3, "h2");
      \u0275\u0275text(4, "Crear contrase\xF1a");
      \u0275\u0275elementEnd();
      \u0275\u0275element(5, "app-password-form");
      \u0275\u0275elementStart(6, "button", 2);
      \u0275\u0275listener("click", function CrearClaveComponent_Template_button_click_6_listener() {
        return ctx.crearUsuario();
      });
      \u0275\u0275template(7, CrearClaveComponent_Conditional_7_Template, 2, 0, "span")(8, CrearClaveComponent_Conditional_8_Template, 2, 0, "span");
      \u0275\u0275elementEnd()()()();
    }
    if (rf & 2) {
      \u0275\u0275advance(6);
      \u0275\u0275property("disabled", !(ctx.codeForm == null ? null : ctx.codeForm.valid) || ctx.isSubmitting);
      \u0275\u0275advance();
      \u0275\u0275conditional(!ctx.isSubmitting ? 7 : -1);
      \u0275\u0275advance();
      \u0275\u0275conditional(ctx.isSubmitting ? 8 : -1);
    }
  }, dependencies: [
    MatInputModule,
    MatIconModule,
    MatButtonModule,
    MatButton,
    MatFormFieldModule,
    RouterModule,
    MatCard,
    ReactiveFormsModule,
    ContainerAuthComponent,
    PasswordFormComponent
  ], styles: ["\n\n[_nghost-%COMP%] {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.key-form[_ngcontent-%COMP%] {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  height: 100%;\n}\n.wid-100[_ngcontent-%COMP%] {\n  width: 70%;\n}\n.mat-card-edited[_ngcontent-%COMP%] {\n  padding: 0.5rem;\n  box-shadow: none;\n  width: 100%;\n  background-color: rgba(238, 238, 238, 0);\n}\n.password-requirements[_ngcontent-%COMP%] {\n  width: 100%;\n  max-width: 300px;\n  margin: 1rem auto;\n  padding: 0 1rem;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n.password-requirements[_ngcontent-%COMP%]   .requirements-title[_ngcontent-%COMP%] {\n  color: rgba(0, 0, 0, 0.6);\n  font-size: 0.9rem;\n  margin-bottom: 0.5rem;\n  text-align: center;\n}\n.password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%] {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n  width: fit-content;\n}\n.password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%] {\n  display: flex;\n  align-items: center;\n  color: rgba(0, 0, 0, 0.6);\n  font-size: 0.9rem;\n  margin-bottom: 0.3rem;\n}\n.password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%] {\n  font-size: 1rem;\n  height: 1rem;\n  width: 1rem;\n  margin-right: 0.5rem;\n}\n.password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li.valid[_ngcontent-%COMP%] {\n  color: #2d5f00;\n}\n.password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li.valid[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%] {\n  color: #2d5f00;\n}\n@media (max-width: 768px) {\n  .password-requirements[_ngcontent-%COMP%] {\n    padding: 0 0.5rem;\n  }\n  .password-requirements[_ngcontent-%COMP%]   .requirements-title[_ngcontent-%COMP%] {\n    font-size: 0.8rem;\n  }\n  .password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%] {\n    font-size: 0.8rem;\n  }\n  .password-requirements[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%] {\n    font-size: 0.9rem;\n    height: 0.9rem;\n    width: 0.9rem;\n  }\n}\n/*# sourceMappingURL=crear-clave.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CrearClaveComponent, [{
    type: Component,
    args: [{ selector: "app-crear-clave", imports: [
      MatInputModule,
      MatIconModule,
      MatButtonModule,
      MatFormFieldModule,
      RouterModule,
      MatCard,
      ReactiveFormsModule,
      ContainerAuthComponent,
      PasswordFormComponent
    ], template: '<!-- @if () {} if pendiente para que aparezca cuando el input esta siendo tocado -->\n<app-container-auth>\n  <mat-card class="mat-card-edited" appearance="outlined">\n    <section class="key-form">\n      <h2>Crear contrase\xF1a</h2>\n\n      <app-password-form></app-password-form>\n\n      <button\n        mat-flat-button\n        [disabled]="!codeForm?.valid || isSubmitting"\n        (click)="crearUsuario()"\n      >\n        @if (!isSubmitting) {\n        <span>Crear usuario</span>\n        } @if (isSubmitting) {\n        <span>Creando usuario...</span>\n        }\n      </button>\n    </section>\n  </mat-card>\n</app-container-auth>\n', styles: ["/* src/app/modules/auth/pages/crear-clave/crear-clave.component.scss */\n:host {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.key-form {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  height: 100%;\n}\n.wid-100 {\n  width: 70%;\n}\n.mat-card-edited {\n  padding: 0.5rem;\n  box-shadow: none;\n  width: 100%;\n  background-color: rgba(238, 238, 238, 0);\n}\n.password-requirements {\n  width: 100%;\n  max-width: 300px;\n  margin: 1rem auto;\n  padding: 0 1rem;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n.password-requirements .requirements-title {\n  color: rgba(0, 0, 0, 0.6);\n  font-size: 0.9rem;\n  margin-bottom: 0.5rem;\n  text-align: center;\n}\n.password-requirements ul {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n  width: fit-content;\n}\n.password-requirements ul li {\n  display: flex;\n  align-items: center;\n  color: rgba(0, 0, 0, 0.6);\n  font-size: 0.9rem;\n  margin-bottom: 0.3rem;\n}\n.password-requirements ul li mat-icon {\n  font-size: 1rem;\n  height: 1rem;\n  width: 1rem;\n  margin-right: 0.5rem;\n}\n.password-requirements ul li.valid {\n  color: #2d5f00;\n}\n.password-requirements ul li.valid mat-icon {\n  color: #2d5f00;\n}\n@media (max-width: 768px) {\n  .password-requirements {\n    padding: 0 0.5rem;\n  }\n  .password-requirements .requirements-title {\n    font-size: 0.8rem;\n  }\n  .password-requirements ul li {\n    font-size: 0.8rem;\n  }\n  .password-requirements ul li mat-icon {\n    font-size: 0.9rem;\n    height: 0.9rem;\n    width: 0.9rem;\n  }\n}\n/*# sourceMappingURL=crear-clave.component.css.map */\n"] }]
  }], null, { passwordFormComponent: [{
    type: ViewChild,
    args: [PasswordFormComponent]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(CrearClaveComponent, { className: "CrearClaveComponent", filePath: "src/app/modules/auth/pages/crear-clave/crear-clave.component.ts", lineNumber: 38 });
})();

// src/app/app.routes.ts
var routes = [
  {
    path: "",
    redirectTo: "auth",
    pathMatch: "full"
  },
  {
    path: "terminos-condiciones",
    data: {
      backButton: true
    },
    loadComponent: () => import("./chunk-CYJYMGV7.js").then((m) => m.TerminosCondicionesComponent)
  },
  {
    path: "auth",
    canActivate: [userRedirectAutenticated],
    component: AuthenticationComponent,
    children: [
      {
        path: "",
        component: FullContainerAuthComponent
      },
      {
        path: "recuperar-contrasena",
        component: RecuperarCuentaComponent
      },
      {
        path: "reset-password",
        component: ResetPaswordComponentComponent
      },
      {
        path: "comprobar-codigo",
        component: ComprobarCodigoComponent
      },
      {
        path: "crear-clave",
        component: CrearClaveComponent
      }
    ]
  },
  {
    path: "hoja-de-vida",
    component: LayoutComponent,
    canActivateChild: [hojaDeVidaCanActivateChild],
    loadChildren: () => import("./chunk-W2UI2SSW.js").then((m) => m.HOJA_DE_VIDA_ROUTES)
  }
];

// node_modules/.pnpm/@ngx-translate+core@16.0.4_@angular+common@19.2.14_@angular+core@19.2.14_rxjs@7.8.2_zon_300112abf40b1f3f15d500b4a191c465/node_modules/@ngx-translate/core/fesm2022/ngx-translate-core.mjs
var TranslateLoader = class {
};
var TranslateFakeLoader = class _TranslateFakeLoader extends TranslateLoader {
  getTranslation(lang) {
    void lang;
    return of({});
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275TranslateFakeLoader_BaseFactory;
    return function TranslateFakeLoader_Factory(__ngFactoryType__) {
      return (\u0275TranslateFakeLoader_BaseFactory || (\u0275TranslateFakeLoader_BaseFactory = \u0275\u0275getInheritedFactory(_TranslateFakeLoader)))(__ngFactoryType__ || _TranslateFakeLoader);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _TranslateFakeLoader,
    factory: _TranslateFakeLoader.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TranslateFakeLoader, [{
    type: Injectable
  }], null, null);
})();
var MissingTranslationHandler = class {
};
var FakeMissingTranslationHandler = class _FakeMissingTranslationHandler {
  handle(params) {
    return params.key;
  }
  static \u0275fac = function FakeMissingTranslationHandler_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FakeMissingTranslationHandler)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _FakeMissingTranslationHandler,
    factory: _FakeMissingTranslationHandler.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FakeMissingTranslationHandler, [{
    type: Injectable
  }], null, null);
})();
function equals(o1, o2) {
  if (o1 === o2) return true;
  if (o1 === null || o2 === null) return false;
  if (o1 !== o1 && o2 !== o2) return true;
  const t1 = typeof o1, t2 = typeof o2;
  let length, key, keySet;
  if (t1 == t2 && t1 == "object") {
    if (Array.isArray(o1)) {
      if (!Array.isArray(o2)) return false;
      if ((length = o1.length) == o2.length) {
        for (key = 0; key < length; key++) {
          if (!equals(o1[key], o2[key])) return false;
        }
        return true;
      }
    } else {
      if (Array.isArray(o2)) {
        return false;
      }
      keySet = /* @__PURE__ */ Object.create(null);
      for (key in o1) {
        if (!equals(o1[key], o2[key])) {
          return false;
        }
        keySet[key] = true;
      }
      for (key in o2) {
        if (!(key in keySet) && typeof o2[key] !== "undefined") {
          return false;
        }
      }
      return true;
    }
  }
  return false;
}
function isDefined(value) {
  return typeof value !== "undefined" && value !== null;
}
function isDict(value) {
  return isObject(value) && !isArray(value) && value !== null;
}
function isObject(value) {
  return typeof value === "object";
}
function isArray(value) {
  return Array.isArray(value);
}
function isString(value) {
  return typeof value === "string";
}
function isFunction2(value) {
  return typeof value === "function";
}
function mergeDeep(target, source) {
  const output = Object.assign({}, target);
  if (!isObject(target)) {
    return mergeDeep({}, source);
  }
  if (isObject(target) && isObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isDict(source[key])) {
        if (key in target) {
          output[key] = mergeDeep(target[key], source[key]);
        } else {
          Object.assign(output, {
            [key]: source[key]
          });
        }
      } else {
        Object.assign(output, {
          [key]: source[key]
        });
      }
    });
  }
  return output;
}
function getValue(target, key) {
  const keys = key.split(".");
  key = "";
  do {
    key += keys.shift();
    if (isDefined(target) && isDefined(target[key]) && (isDict(target[key]) || isArray(target[key]) || !keys.length)) {
      target = target[key];
      key = "";
    } else if (!keys.length) {
      target = void 0;
    } else {
      key += ".";
    }
  } while (keys.length);
  return target;
}
function setValue(target, key, value) {
  const keys = key.split(".");
  let current = target;
  for (let i = 0; i < keys.length; i++) {
    const key2 = keys[i];
    if (i === keys.length - 1) {
      current[key2] = value;
    } else {
      if (!current[key2] || !isDict(current[key2])) {
        current[key2] = {};
      }
      current = current[key2];
    }
  }
}
var TranslateParser = class {
};
var TranslateDefaultParser = class _TranslateDefaultParser extends TranslateParser {
  templateMatcher = /{{\s?([^{}\s]*)\s?}}/g;
  interpolate(expr, params) {
    if (isString(expr)) {
      return this.interpolateString(expr, params);
    } else if (isFunction2(expr)) {
      return this.interpolateFunction(expr, params);
    }
    return void 0;
  }
  interpolateFunction(fn, params) {
    return fn(params);
  }
  interpolateString(expr, params) {
    if (!params) {
      return expr;
    }
    return expr.replace(this.templateMatcher, (substring, b) => {
      const r = getValue(params, b);
      return isDefined(r) ? r : substring;
    });
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275TranslateDefaultParser_BaseFactory;
    return function TranslateDefaultParser_Factory(__ngFactoryType__) {
      return (\u0275TranslateDefaultParser_BaseFactory || (\u0275TranslateDefaultParser_BaseFactory = \u0275\u0275getInheritedFactory(_TranslateDefaultParser)))(__ngFactoryType__ || _TranslateDefaultParser);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _TranslateDefaultParser,
    factory: _TranslateDefaultParser.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TranslateDefaultParser, [{
    type: Injectable
  }], null, null);
})();
var TranslateCompiler = class {
};
var TranslateFakeCompiler = class _TranslateFakeCompiler extends TranslateCompiler {
  compile(value, lang) {
    void lang;
    return value;
  }
  compileTranslations(translations, lang) {
    void lang;
    return translations;
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275TranslateFakeCompiler_BaseFactory;
    return function TranslateFakeCompiler_Factory(__ngFactoryType__) {
      return (\u0275TranslateFakeCompiler_BaseFactory || (\u0275TranslateFakeCompiler_BaseFactory = \u0275\u0275getInheritedFactory(_TranslateFakeCompiler)))(__ngFactoryType__ || _TranslateFakeCompiler);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _TranslateFakeCompiler,
    factory: _TranslateFakeCompiler.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TranslateFakeCompiler, [{
    type: Injectable
  }], null, null);
})();
var TranslateStore = class {
  /**
   * The default lang to fallback when translations are missing on the current lang
   */
  defaultLang;
  /**
   * The lang currently used
   */
  currentLang = this.defaultLang;
  /**
   * a list of translations per lang
   */
  translations = {};
  /**
   * an array of langs
   */
  langs = [];
  /**
   * An EventEmitter to listen to translation change events
   * onTranslationChange.subscribe((params: TranslationChangeEvent) => {
     *     // do something
     * });
   */
  onTranslationChange = new EventEmitter();
  /**
   * An EventEmitter to listen to lang change events
   * onLangChange.subscribe((params: LangChangeEvent) => {
     *     // do something
     * });
   */
  onLangChange = new EventEmitter();
  /**
   * An EventEmitter to listen to default lang change events
   * onDefaultLangChange.subscribe((params: DefaultLangChangeEvent) => {
     *     // do something
     * });
   */
  onDefaultLangChange = new EventEmitter();
};
var ISOLATE_TRANSLATE_SERVICE = new InjectionToken("ISOLATE_TRANSLATE_SERVICE");
var USE_DEFAULT_LANG = new InjectionToken("USE_DEFAULT_LANG");
var DEFAULT_LANGUAGE = new InjectionToken("DEFAULT_LANGUAGE");
var USE_EXTEND = new InjectionToken("USE_EXTEND");
var makeObservable = (value) => {
  return isObservable(value) ? value : of(value);
};
var TranslateService = class _TranslateService {
  store;
  currentLoader;
  compiler;
  parser;
  missingTranslationHandler;
  useDefaultLang;
  extend;
  loadingTranslations;
  pending = false;
  _translationRequests = {};
  lastUseLanguage = null;
  /**
   * An EventEmitter to listen to translation change events
   * onTranslationChange.subscribe((params: TranslationChangeEvent) => {
     *     // do something
     * });
   */
  get onTranslationChange() {
    return this.store.onTranslationChange;
  }
  /**
   * An EventEmitter to listen to lang change events
   * onLangChange.subscribe((params: LangChangeEvent) => {
     *     // do something
     * });
   */
  get onLangChange() {
    return this.store.onLangChange;
  }
  /**
   * An EventEmitter to listen to default lang change events
   * onDefaultLangChange.subscribe((params: DefaultLangChangeEvent) => {
     *     // do something
     * });
   */
  get onDefaultLangChange() {
    return this.store.onDefaultLangChange;
  }
  /**
   * The default lang to fallback when translations are missing on the current lang
   */
  get defaultLang() {
    return this.store.defaultLang;
  }
  set defaultLang(defaultLang) {
    this.store.defaultLang = defaultLang;
  }
  /**
   * The lang currently used
   */
  get currentLang() {
    return this.store.currentLang;
  }
  set currentLang(currentLang) {
    this.store.currentLang = currentLang;
  }
  /**
   * an array of langs
   */
  get langs() {
    return this.store.langs;
  }
  set langs(langs) {
    this.store.langs = langs;
  }
  /**
   * a list of translations per lang
   */
  get translations() {
    return this.store.translations;
  }
  set translations(translations) {
    this.store.translations = translations;
  }
  /**
   *
   * @param store an instance of the store (that is supposed to be unique)
   * @param currentLoader An instance of the loader currently used
   * @param compiler An instance of the compiler currently used
   * @param parser An instance of the parser currently used
   * @param missingTranslationHandler A handler for missing translations.
   * @param useDefaultLang whether we should use default language translation when current language translation is missing.
   * @param isolate whether this service should use the store or not
   * @param extend To make a child module extend (and use) translations from parent modules.
   * @param defaultLanguage Set the default language using configuration
   */
  constructor(store, currentLoader, compiler, parser, missingTranslationHandler, useDefaultLang = true, isolate = false, extend = false, defaultLanguage) {
    this.store = store;
    this.currentLoader = currentLoader;
    this.compiler = compiler;
    this.parser = parser;
    this.missingTranslationHandler = missingTranslationHandler;
    this.useDefaultLang = useDefaultLang;
    this.extend = extend;
    if (isolate) {
      this.store = new TranslateStore();
    }
    if (defaultLanguage) {
      this.setDefaultLang(defaultLanguage);
    }
  }
  /**
   * Sets the default language to use as a fallback
   */
  setDefaultLang(lang) {
    if (lang === this.defaultLang) {
      return;
    }
    const pending = this.retrieveTranslations(lang);
    if (typeof pending !== "undefined") {
      if (this.defaultLang == null) {
        this.defaultLang = lang;
      }
      pending.pipe(take(1)).subscribe(() => {
        this.changeDefaultLang(lang);
      });
    } else {
      this.changeDefaultLang(lang);
    }
  }
  /**
   * Gets the default language used
   */
  getDefaultLang() {
    return this.defaultLang;
  }
  /**
   * Changes the lang currently used
   */
  use(lang) {
    this.lastUseLanguage = lang;
    if (lang === this.currentLang) {
      return of(this.translations[lang]);
    }
    if (!this.currentLang) {
      this.currentLang = lang;
    }
    const pending = this.retrieveTranslations(lang);
    if (isObservable(pending)) {
      pending.pipe(take(1)).subscribe(() => {
        this.changeLang(lang);
      });
      return pending;
    } else {
      this.changeLang(lang);
      return of(this.translations[lang]);
    }
  }
  /**
   * Changes the current lang
   */
  changeLang(lang) {
    if (lang !== this.lastUseLanguage) {
      return;
    }
    this.currentLang = lang;
    this.onLangChange.emit({
      lang,
      translations: this.translations[lang]
    });
    if (this.defaultLang == null) {
      this.changeDefaultLang(lang);
    }
  }
  /**
   * Retrieves the given translations
   */
  retrieveTranslations(lang) {
    if (typeof this.translations[lang] === "undefined" || this.extend) {
      this._translationRequests[lang] = this._translationRequests[lang] || this.loadAndCompileTranslations(lang);
      return this._translationRequests[lang];
    }
    return void 0;
  }
  /**
   * Gets an object of translations for a given language with the current loader
   * and passes it through the compiler
   *
   * @deprecated This function is meant for internal use. There should
   * be no reason to use outside this service. You can plug into this
   * functionality by using a customer TranslateLoader or TranslateCompiler.
   * To load a new language use setDefaultLang() and/or use()
   */
  getTranslation(lang) {
    return this.loadAndCompileTranslations(lang);
  }
  loadAndCompileTranslations(lang) {
    this.pending = true;
    const loadingTranslations = this.currentLoader.getTranslation(lang).pipe(shareReplay(1), take(1));
    this.loadingTranslations = loadingTranslations.pipe(map((res) => this.compiler.compileTranslations(res, lang)), shareReplay(1), take(1));
    this.loadingTranslations.subscribe({
      next: (res) => {
        this.translations[lang] = this.extend && this.translations[lang] ? __spreadValues(__spreadValues({}, res), this.translations[lang]) : res;
        this.updateLangs();
        this.pending = false;
      },
      error: (err) => {
        void err;
        this.pending = false;
      }
    });
    return loadingTranslations;
  }
  /**
   * Manually sets an object of translations for a given language
   * after passing it through the compiler
   */
  setTranslation(lang, translations, shouldMerge = false) {
    const interpolatableTranslations = this.compiler.compileTranslations(translations, lang);
    if ((shouldMerge || this.extend) && this.translations[lang]) {
      this.translations[lang] = mergeDeep(this.translations[lang], interpolatableTranslations);
    } else {
      this.translations[lang] = interpolatableTranslations;
    }
    this.updateLangs();
    this.onTranslationChange.emit({
      lang,
      translations: this.translations[lang]
    });
  }
  /**
   * Returns an array of currently available langs
   */
  getLangs() {
    return this.langs;
  }
  /**
   * Add available languages
   */
  addLangs(langs) {
    const newLangs = langs.filter((lang) => !this.langs.includes(lang));
    if (newLangs.length > 0) {
      this.langs = [...this.langs, ...newLangs];
    }
  }
  /**
   * Update the list of available languages
   */
  updateLangs() {
    this.addLangs(Object.keys(this.translations));
  }
  getParsedResultForKey(translations, key, interpolateParams) {
    let res;
    if (translations) {
      res = this.runInterpolation(getValue(translations, key), interpolateParams);
    }
    if (res === void 0 && this.defaultLang != null && this.defaultLang !== this.currentLang && this.useDefaultLang) {
      res = this.runInterpolation(getValue(this.translations[this.defaultLang], key), interpolateParams);
    }
    if (res === void 0) {
      const params = {
        key,
        translateService: this
      };
      if (typeof interpolateParams !== "undefined") {
        params.interpolateParams = interpolateParams;
      }
      res = this.missingTranslationHandler.handle(params);
    }
    return res !== void 0 ? res : key;
  }
  runInterpolation(translations, interpolateParams) {
    if (isArray(translations)) {
      return translations.map((translation) => this.runInterpolation(translation, interpolateParams));
    } else if (isDict(translations)) {
      const result = {};
      for (const key in translations) {
        const res = this.runInterpolation(translations[key], interpolateParams);
        if (res !== void 0) {
          result[key] = res;
        }
      }
      return result;
    } else {
      return this.parser.interpolate(translations, interpolateParams);
    }
  }
  /**
   * Returns the parsed result of the translations
   */
  getParsedResult(translations, key, interpolateParams) {
    if (key instanceof Array) {
      const result = {};
      let observables = false;
      for (const k of key) {
        result[k] = this.getParsedResultForKey(translations, k, interpolateParams);
        observables = observables || isObservable(result[k]);
      }
      if (!observables) {
        return result;
      }
      const sources = key.map((k) => makeObservable(result[k]));
      return forkJoin(sources).pipe(map((arr) => {
        const obj = {};
        arr.forEach((value, index) => {
          obj[key[index]] = value;
        });
        return obj;
      }));
    }
    return this.getParsedResultForKey(translations, key, interpolateParams);
  }
  /**
   * Gets the translated value of a key (or an array of keys)
   * @returns the translated key, or an object of translated keys
   */
  get(key, interpolateParams) {
    if (!isDefined(key) || !key.length) {
      throw new Error(`Parameter "key" is required and cannot be empty`);
    }
    if (this.pending) {
      return this.loadingTranslations.pipe(concatMap((res) => {
        return makeObservable(this.getParsedResult(res, key, interpolateParams));
      }));
    }
    return makeObservable(this.getParsedResult(this.translations[this.currentLang], key, interpolateParams));
  }
  /**
   * Returns a stream of translated values of a key (or an array of keys) which updates
   * whenever the translation changes.
   * @returns A stream of the translated key, or an object of translated keys
   */
  getStreamOnTranslationChange(key, interpolateParams) {
    if (!isDefined(key) || !key.length) {
      throw new Error(`Parameter "key" is required and cannot be empty`);
    }
    return concat(defer(() => this.get(key, interpolateParams)), this.onTranslationChange.pipe(switchMap((event) => {
      const res = this.getParsedResult(event.translations, key, interpolateParams);
      return makeObservable(res);
    })));
  }
  /**
   * Returns a stream of translated values of a key (or an array of keys) which updates
   * whenever the language changes.
   * @returns A stream of the translated key, or an object of translated keys
   */
  stream(key, interpolateParams) {
    if (!isDefined(key) || !key.length) {
      throw new Error(`Parameter "key" required`);
    }
    return concat(defer(() => this.get(key, interpolateParams)), this.onLangChange.pipe(switchMap((event) => {
      const res = this.getParsedResult(event.translations, key, interpolateParams);
      return makeObservable(res);
    })));
  }
  /**
   * Returns a translation instantly from the internal state of loaded translation.
   * All rules regarding the current language, the preferred language of even fallback languages
   * will be used except any promise handling.
   */
  instant(key, interpolateParams) {
    if (!isDefined(key) || key.length === 0) {
      throw new Error('Parameter "key" is required and cannot be empty');
    }
    const result = this.getParsedResult(this.translations[this.currentLang], key, interpolateParams);
    if (isObservable(result)) {
      if (Array.isArray(key)) {
        return key.reduce((acc, currKey) => {
          acc[currKey] = currKey;
          return acc;
        }, {});
      }
      return key;
    }
    return result;
  }
  /**
   * Sets the translated value of a key, after compiling it
   */
  set(key, translation, lang = this.currentLang) {
    setValue(this.translations[lang], key, isString(translation) ? this.compiler.compile(translation, lang) : this.compiler.compileTranslations(translation, lang));
    this.updateLangs();
    this.onTranslationChange.emit({
      lang,
      translations: this.translations[lang]
    });
  }
  /**
   * Changes the default lang
   */
  changeDefaultLang(lang) {
    this.defaultLang = lang;
    this.onDefaultLangChange.emit({
      lang,
      translations: this.translations[lang]
    });
  }
  /**
   * Allows to reload the lang file from the file
   */
  reloadLang(lang) {
    this.resetLang(lang);
    return this.loadAndCompileTranslations(lang);
  }
  /**
   * Deletes inner translation
   */
  resetLang(lang) {
    delete this._translationRequests[lang];
    delete this.translations[lang];
  }
  /**
   * Returns the language code name from the browser, e.g. "de"
   */
  getBrowserLang() {
    if (typeof window === "undefined" || !window.navigator) {
      return void 0;
    }
    const browserLang = this.getBrowserCultureLang();
    return browserLang ? browserLang.split(/[-_]/)[0] : void 0;
  }
  /**
   * Returns the culture language code name from the browser, e.g. "de-DE"
   */
  getBrowserCultureLang() {
    if (typeof window === "undefined" || typeof window.navigator === "undefined") {
      return void 0;
    }
    return window.navigator.languages ? window.navigator.languages[0] : window.navigator.language || window.navigator.browserLanguage || window.navigator.userLanguage;
  }
  static \u0275fac = function TranslateService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TranslateService)(\u0275\u0275inject(TranslateStore), \u0275\u0275inject(TranslateLoader), \u0275\u0275inject(TranslateCompiler), \u0275\u0275inject(TranslateParser), \u0275\u0275inject(MissingTranslationHandler), \u0275\u0275inject(USE_DEFAULT_LANG), \u0275\u0275inject(ISOLATE_TRANSLATE_SERVICE), \u0275\u0275inject(USE_EXTEND), \u0275\u0275inject(DEFAULT_LANGUAGE));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _TranslateService,
    factory: _TranslateService.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TranslateService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: TranslateStore
  }, {
    type: TranslateLoader
  }, {
    type: TranslateCompiler
  }, {
    type: TranslateParser
  }, {
    type: MissingTranslationHandler
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [USE_DEFAULT_LANG]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [ISOLATE_TRANSLATE_SERVICE]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [USE_EXTEND]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DEFAULT_LANGUAGE]
    }]
  }], null);
})();
var TranslateDirective = class _TranslateDirective {
  translateService;
  element;
  _ref;
  key;
  lastParams;
  currentParams;
  onLangChangeSub;
  onDefaultLangChangeSub;
  onTranslationChangeSub;
  set translate(key) {
    if (key) {
      this.key = key;
      this.checkNodes();
    }
  }
  set translateParams(params) {
    if (!equals(this.currentParams, params)) {
      this.currentParams = params;
      this.checkNodes(true);
    }
  }
  constructor(translateService, element, _ref) {
    this.translateService = translateService;
    this.element = element;
    this._ref = _ref;
    if (!this.onTranslationChangeSub) {
      this.onTranslationChangeSub = this.translateService.onTranslationChange.subscribe((event) => {
        if (event.lang === this.translateService.currentLang) {
          this.checkNodes(true, event.translations);
        }
      });
    }
    if (!this.onLangChangeSub) {
      this.onLangChangeSub = this.translateService.onLangChange.subscribe((event) => {
        this.checkNodes(true, event.translations);
      });
    }
    if (!this.onDefaultLangChangeSub) {
      this.onDefaultLangChangeSub = this.translateService.onDefaultLangChange.subscribe((event) => {
        void event;
        this.checkNodes(true);
      });
    }
  }
  ngAfterViewChecked() {
    this.checkNodes();
  }
  checkNodes(forceUpdate = false, translations) {
    let nodes = this.element.nativeElement.childNodes;
    if (!nodes.length) {
      this.setContent(this.element.nativeElement, this.key);
      nodes = this.element.nativeElement.childNodes;
    }
    nodes.forEach((n) => {
      const node = n;
      if (node.nodeType === 3) {
        let key;
        if (forceUpdate) {
          node.lastKey = null;
        }
        if (isDefined(node.lookupKey)) {
          key = node.lookupKey;
        } else if (this.key) {
          key = this.key;
        } else {
          const content = this.getContent(node);
          const trimmedContent = content.trim();
          if (trimmedContent.length) {
            node.lookupKey = trimmedContent;
            if (content !== node.currentValue) {
              key = trimmedContent;
              node.originalContent = content || node.originalContent;
            } else if (node.originalContent) {
              key = node.originalContent.trim();
            }
          }
        }
        this.updateValue(key, node, translations);
      }
    });
  }
  updateValue(key, node, translations) {
    if (key) {
      if (node.lastKey === key && this.lastParams === this.currentParams) {
        return;
      }
      this.lastParams = this.currentParams;
      const onTranslation = (res) => {
        if (res !== key || !node.lastKey) {
          node.lastKey = key;
        }
        if (!node.originalContent) {
          node.originalContent = this.getContent(node);
        }
        node.currentValue = isDefined(res) ? res : node.originalContent || key;
        this.setContent(node, this.key ? node.currentValue : node.originalContent.replace(key, node.currentValue));
        this._ref.markForCheck();
      };
      if (isDefined(translations)) {
        const res = this.translateService.getParsedResult(translations, key, this.currentParams);
        if (isObservable(res)) {
          res.subscribe({
            next: onTranslation
          });
        } else {
          onTranslation(res);
        }
      } else {
        this.translateService.get(key, this.currentParams).subscribe(onTranslation);
      }
    }
  }
  getContent(node) {
    return isDefined(node.textContent) ? node.textContent : node.data;
  }
  setContent(node, content) {
    if (isDefined(node.textContent)) {
      node.textContent = content;
    } else {
      node.data = content;
    }
  }
  ngOnDestroy() {
    if (this.onLangChangeSub) {
      this.onLangChangeSub.unsubscribe();
    }
    if (this.onDefaultLangChangeSub) {
      this.onDefaultLangChangeSub.unsubscribe();
    }
    if (this.onTranslationChangeSub) {
      this.onTranslationChangeSub.unsubscribe();
    }
  }
  static \u0275fac = function TranslateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TranslateDirective)(\u0275\u0275directiveInject(TranslateService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _TranslateDirective,
    selectors: [["", "translate", ""], ["", "ngx-translate", ""]],
    inputs: {
      translate: "translate",
      translateParams: "translateParams"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TranslateDirective, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "[translate],[ngx-translate]",
      standalone: true
    }]
  }], () => [{
    type: TranslateService
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    translate: [{
      type: Input
    }],
    translateParams: [{
      type: Input
    }]
  });
})();
var TranslatePipe = class _TranslatePipe {
  translate;
  _ref;
  value = "";
  lastKey = null;
  lastParams = [];
  onTranslationChange;
  onLangChange;
  onDefaultLangChange;
  constructor(translate, _ref) {
    this.translate = translate;
    this._ref = _ref;
  }
  updateValue(key, interpolateParams, translations) {
    const onTranslation = (res) => {
      this.value = res !== void 0 ? res : key;
      this.lastKey = key;
      this._ref.markForCheck();
    };
    if (translations) {
      const res = this.translate.getParsedResult(translations, key, interpolateParams);
      if (isObservable(res)) {
        res.subscribe(onTranslation);
      } else {
        onTranslation(res);
      }
    }
    this.translate.get(key, interpolateParams).subscribe(onTranslation);
  }
  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
  transform(query, ...args) {
    if (!query || !query.length) {
      return query;
    }
    if (equals(query, this.lastKey) && equals(args, this.lastParams)) {
      return this.value;
    }
    let interpolateParams = void 0;
    if (isDefined(args[0]) && args.length) {
      if (isString(args[0]) && args[0].length) {
        const validArgs = args[0].replace(/(')?([a-zA-Z0-9_]+)(')?(\s)?:/g, '"$2":').replace(/:(\s)?(')(.*?)(')/g, ':"$3"');
        try {
          interpolateParams = JSON.parse(validArgs);
        } catch (e) {
          void e;
          throw new SyntaxError(`Wrong parameter in TranslatePipe. Expected a valid Object, received: ${args[0]}`);
        }
      } else if (isDict(args[0])) {
        interpolateParams = args[0];
      }
    }
    this.lastKey = query;
    this.lastParams = args;
    this.updateValue(query, interpolateParams);
    this._dispose();
    if (!this.onTranslationChange) {
      this.onTranslationChange = this.translate.onTranslationChange.subscribe((event) => {
        if (this.lastKey && event.lang === this.translate.currentLang) {
          this.lastKey = null;
          this.updateValue(query, interpolateParams, event.translations);
        }
      });
    }
    if (!this.onLangChange) {
      this.onLangChange = this.translate.onLangChange.subscribe((event) => {
        if (this.lastKey) {
          this.lastKey = null;
          this.updateValue(query, interpolateParams, event.translations);
        }
      });
    }
    if (!this.onDefaultLangChange) {
      this.onDefaultLangChange = this.translate.onDefaultLangChange.subscribe(() => {
        if (this.lastKey) {
          this.lastKey = null;
          this.updateValue(query, interpolateParams);
        }
      });
    }
    return this.value;
  }
  /**
   * Clean any existing subscription to change events
   */
  _dispose() {
    if (typeof this.onTranslationChange !== "undefined") {
      this.onTranslationChange.unsubscribe();
      this.onTranslationChange = void 0;
    }
    if (typeof this.onLangChange !== "undefined") {
      this.onLangChange.unsubscribe();
      this.onLangChange = void 0;
    }
    if (typeof this.onDefaultLangChange !== "undefined") {
      this.onDefaultLangChange.unsubscribe();
      this.onDefaultLangChange = void 0;
    }
  }
  ngOnDestroy() {
    this._dispose();
  }
  static \u0275fac = function TranslatePipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TranslatePipe)(\u0275\u0275directiveInject(TranslateService, 16), \u0275\u0275directiveInject(ChangeDetectorRef, 16));
  };
  static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
    name: "translate",
    type: _TranslatePipe,
    pure: false
  });
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _TranslatePipe,
    factory: _TranslatePipe.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TranslatePipe, [{
    type: Injectable
  }, {
    type: Pipe,
    args: [{
      name: "translate",
      standalone: true,
      pure: false
      // required to update the value when the promise is resolved
    }]
  }], () => [{
    type: TranslateService
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var TranslateModule = class _TranslateModule {
  /**
   * Use this method in your root module to provide the TranslateService
   */
  static forRoot(config = {}) {
    return {
      ngModule: _TranslateModule,
      providers: [config.loader || {
        provide: TranslateLoader,
        useClass: TranslateFakeLoader
      }, config.compiler || {
        provide: TranslateCompiler,
        useClass: TranslateFakeCompiler
      }, config.parser || {
        provide: TranslateParser,
        useClass: TranslateDefaultParser
      }, config.missingTranslationHandler || {
        provide: MissingTranslationHandler,
        useClass: FakeMissingTranslationHandler
      }, TranslateStore, {
        provide: ISOLATE_TRANSLATE_SERVICE,
        useValue: config.isolate
      }, {
        provide: USE_DEFAULT_LANG,
        useValue: config.useDefaultLang
      }, {
        provide: USE_EXTEND,
        useValue: config.extend
      }, {
        provide: DEFAULT_LANGUAGE,
        useValue: config.defaultLanguage
      }, TranslateService]
    };
  }
  /**
   * Use this method in your other (non-root) modules to import the directive/pipe
   */
  static forChild(config = {}) {
    return {
      ngModule: _TranslateModule,
      providers: [config.loader || {
        provide: TranslateLoader,
        useClass: TranslateFakeLoader
      }, config.compiler || {
        provide: TranslateCompiler,
        useClass: TranslateFakeCompiler
      }, config.parser || {
        provide: TranslateParser,
        useClass: TranslateDefaultParser
      }, config.missingTranslationHandler || {
        provide: MissingTranslationHandler,
        useClass: FakeMissingTranslationHandler
      }, {
        provide: ISOLATE_TRANSLATE_SERVICE,
        useValue: config.isolate
      }, {
        provide: USE_DEFAULT_LANG,
        useValue: config.useDefaultLang
      }, {
        provide: USE_EXTEND,
        useValue: config.extend
      }, {
        provide: DEFAULT_LANGUAGE,
        useValue: config.defaultLanguage
      }, TranslateService]
    };
  }
  static \u0275fac = function TranslateModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TranslateModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _TranslateModule,
    imports: [TranslatePipe, TranslateDirective],
    exports: [TranslatePipe, TranslateDirective]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TranslateModule, [{
    type: NgModule,
    args: [{
      imports: [TranslatePipe, TranslateDirective],
      exports: [TranslatePipe, TranslateDirective]
    }]
  }], null, null);
})();

// src/app/core/i18n/i18n.service.ts
var I18nService = class _I18nService {
  translateService;
  constructor(translateService) {
    this.translateService = translateService;
    this.initializeTranslation();
  }
  /**
   * Inicializa la configuración de traducción
   */
  initializeTranslation() {
    this.translateService.setDefaultLang("es");
    this.translateService.use("es");
  }
  /**
   * Obtiene una traducción de forma síncrona
   * @param key Clave de la traducción
   * @param params Parámetros para interpolación
   * @returns Texto traducido
   */
  translate(key, params) {
    return this.translateService.instant(key, params);
  }
  /**
   * Obtiene una traducción de forma asíncrona
   * @param key Clave de la traducción
   * @param params Parámetros para interpolación
   * @returns Observable con el texto traducido
   */
  translateAsync(key, params) {
    return this.translateService.get(key, params);
  }
  /**
   * Obtiene múltiples traducciones de forma asíncrona
   * @param keys Array de claves de traducción
   * @param params Parámetros para interpolación
   * @returns Observable con objeto de traducciones
   */
  translateMultiple(keys, params) {
    return this.translateService.get(keys, params);
  }
  /**
   * Cambia el idioma actual
   * @param lang Código del idioma
   */
  changeLanguage(lang) {
    this.translateService.use(lang);
  }
  /**
   * Obtiene el idioma actual
   * @returns Código del idioma actual
   */
  getCurrentLanguage() {
    return this.translateService.currentLang || this.translateService.getDefaultLang();
  }
  /**
   * Obtiene los idiomas disponibles
   * @returns Array de códigos de idiomas
   */
  getAvailableLanguages() {
    return this.translateService.getLangs();
  }
  /**
   * Verifica si existe una traducción para una clave
   * @param key Clave de la traducción
   * @returns true si existe la traducción
   */
  hasTranslation(key) {
    return this.translateService.instant(key) !== key;
  }
  /**
   * Recarga las traducciones
   * @param lang Idioma a recargar (opcional)
   */
  reloadTranslations(lang) {
    const currentLang = lang || this.getCurrentLanguage();
    this.translateService.reloadLang(currentLang);
  }
  static \u0275fac = function I18nService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _I18nService)(\u0275\u0275inject(TranslateService));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _I18nService, factory: _I18nService.\u0275fac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(I18nService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{ type: TranslateService }], null);
})();

// node_modules/.pnpm/@ngx-translate+http-loader@16.0.1_@angular+common@19.2.14_@angular+core@19.2.14_rxjs@7._2b9a449174edc53d0594c719da1518e4/node_modules/@ngx-translate/http-loader/fesm2022/ngx-translate-http-loader.mjs
var TranslateHttpLoader = class _TranslateHttpLoader {
  http;
  prefix;
  suffix;
  constructor(http, prefix = "/assets/i18n/", suffix = ".json") {
    this.http = http;
    this.prefix = prefix;
    this.suffix = suffix;
  }
  /**
   * Gets the translations from the server
   */
  getTranslation(lang) {
    return this.http.get(`${this.prefix}${lang}${this.suffix}`);
  }
  static \u0275fac = function TranslateHttpLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TranslateHttpLoader)(\u0275\u0275inject(HttpClient), \u0275\u0275inject(String), \u0275\u0275inject(String));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _TranslateHttpLoader,
    factory: _TranslateHttpLoader.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TranslateHttpLoader, [{
    type: Injectable
  }], () => [{
    type: HttpClient
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [String]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [String]
    }]
  }], null);
})();

// src/app/core/i18n/i18n.config.ts
function createTranslateLoader(http) {
  return new TranslateHttpLoader(http, "./assets/i18n/", ".json");
}
var I18N_PROVIDERS = [
  importProvidersFrom(TranslateModule.forRoot({
    loader: {
      provide: TranslateLoader,
      useFactory: createTranslateLoader,
      deps: [HttpClient]
    },
    defaultLanguage: "es",
    useDefaultLang: true,
    isolate: false
  }))
];
var SUPPORTED_LANGUAGES = [
  { code: "es", name: "Espa\xF1ol", flag: "\u{1F1EA}\u{1F1F8}" }
  // Agregar más idiomas según necesidades
  // { code: 'en', name: 'English', flag: '🇺🇸' },
  // { code: 'fr', name: 'Français', flag: '🇫🇷' }
];

// src/app/core/i18n/language-selector.component.ts
function LanguageSelectorComponent_div_8_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 8);
    \u0275\u0275listener("click", function LanguageSelectorComponent_div_8_button_1_Template_button_click_0_listener() {
      const lang_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.selectLanguage(lang_r3.code));
    });
    \u0275\u0275elementStart(1, "span", 2);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span", 3);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const lang_r3 = ctx.$implicit;
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("active", lang_r3.code === ctx_r3.currentLanguage);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(lang_r3.flag);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(lang_r3.name);
  }
}
function LanguageSelectorComponent_div_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 6);
    \u0275\u0275listener("click", function LanguageSelectorComponent_div_8_Template_div_click_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView($event.stopPropagation());
    });
    \u0275\u0275template(1, LanguageSelectorComponent_div_8_button_1_Template, 5, 4, "button", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r3.supportedLanguages);
  }
}
var LanguageSelectorComponent = class _LanguageSelectorComponent {
  i18nService;
  supportedLanguages = SUPPORTED_LANGUAGES;
  currentLanguage;
  isDropdownOpen = false;
  constructor(i18nService) {
    this.i18nService = i18nService;
    this.currentLanguage = this.i18nService.getCurrentLanguage();
    document.addEventListener("click", () => {
      this.isDropdownOpen = false;
    });
  }
  toggleDropdown() {
    this.isDropdownOpen = !this.isDropdownOpen;
  }
  selectLanguage(langCode) {
    this.i18nService.changeLanguage(langCode);
    this.currentLanguage = langCode;
    this.isDropdownOpen = false;
  }
  getCurrentLanguageFlag() {
    const currentLang = this.supportedLanguages.find((lang) => lang.code === this.currentLanguage);
    return currentLang?.flag || "\u{1F310}";
  }
  getCurrentLanguageName() {
    const currentLang = this.supportedLanguages.find((lang) => lang.code === this.currentLanguage);
    return currentLang?.name || "Idioma";
  }
  static \u0275fac = function LanguageSelectorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LanguageSelectorComponent)(\u0275\u0275directiveInject(I18nService));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _LanguageSelectorComponent, selectors: [["app-language-selector"]], decls: 9, vars: 6, consts: [[1, "language-selector"], [1, "current-language", 3, "click"], [1, "flag"], [1, "name"], [1, "arrow"], ["class", "dropdown", 3, "click", 4, "ngIf"], [1, "dropdown", 3, "click"], ["class", "language-option", 3, "active", "click", 4, "ngFor", "ngForOf"], [1, "language-option", 3, "click"]], template: function LanguageSelectorComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0)(1, "button", 1);
      \u0275\u0275listener("click", function LanguageSelectorComponent_Template_button_click_1_listener() {
        return ctx.toggleDropdown();
      });
      \u0275\u0275elementStart(2, "span", 2);
      \u0275\u0275text(3);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, "span", 3);
      \u0275\u0275text(5);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(6, "span", 4);
      \u0275\u0275text(7, "\u25BC");
      \u0275\u0275elementEnd()();
      \u0275\u0275template(8, LanguageSelectorComponent_div_8_Template, 2, 1, "div", 5);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275attribute("aria-expanded", ctx.isDropdownOpen);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate(ctx.getCurrentLanguageFlag());
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate(ctx.getCurrentLanguageName());
      \u0275\u0275advance();
      \u0275\u0275classProp("open", ctx.isDropdownOpen);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.isDropdownOpen);
    }
  }, dependencies: [CommonModule, NgForOf, NgIf], styles: ["\n\n.language-selector[_ngcontent-%COMP%] {\n  position: relative;\n  display: inline-block;\n}\n.current-language[_ngcontent-%COMP%] {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.5rem 1rem;\n  border: 1px solid #e0e0e0;\n  border-radius: 0.25rem;\n  background: white;\n  cursor: pointer;\n  transition: all 0.2s ease;\n}\n.current-language[_ngcontent-%COMP%]:hover {\n  border-color: #007bff;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n.arrow[_ngcontent-%COMP%] {\n  transition: transform 0.2s ease;\n  font-size: 0.8rem;\n}\n.arrow.open[_ngcontent-%COMP%] {\n  transform: rotate(180deg);\n}\n.dropdown[_ngcontent-%COMP%] {\n  position: absolute;\n  top: 100%;\n  left: 0;\n  right: 0;\n  background: white;\n  border: 1px solid #e0e0e0;\n  border-radius: 0.25rem;\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n  z-index: 1000;\n  margin-top: 0.25rem;\n}\n.language-option[_ngcontent-%COMP%] {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  width: 100%;\n  padding: 0.75rem 1rem;\n  border: none;\n  background: white;\n  cursor: pointer;\n  transition: background-color 0.2s ease;\n  text-align: left;\n}\n.language-option[_ngcontent-%COMP%]:hover {\n  background-color: #f8f9fa;\n}\n.language-option.active[_ngcontent-%COMP%] {\n  background-color: #e3f2fd;\n  color: #1976d2;\n}\n.flag[_ngcontent-%COMP%] {\n  font-size: 1.2rem;\n}\n.name[_ngcontent-%COMP%] {\n  font-weight: 500;\n}\n/*# sourceMappingURL=language-selector.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LanguageSelectorComponent, [{
    type: Component,
    args: [{ selector: "app-language-selector", standalone: true, imports: [CommonModule], template: `
    <div class="language-selector">
      <button 
        class="current-language" 
        (click)="toggleDropdown()"
        [attr.aria-expanded]="isDropdownOpen">
        <span class="flag">{{ getCurrentLanguageFlag() }}</span>
        <span class="name">{{ getCurrentLanguageName() }}</span>
        <span class="arrow" [class.open]="isDropdownOpen">\u25BC</span>
      </button>
      
      <div class="dropdown" *ngIf="isDropdownOpen" (click)="$event.stopPropagation()">
        <button 
          *ngFor="let lang of supportedLanguages"
          class="language-option"
          [class.active]="lang.code === currentLanguage"
          (click)="selectLanguage(lang.code)">
          <span class="flag">{{ lang.flag }}</span>
          <span class="name">{{ lang.name }}</span>
        </button>
      </div>
    </div>
  `, styles: ["/* angular:styles/component:scss;9a41a701cb2eaed8f8b7532b65792a923d15047702812a2fe4ce92e06340dc6f;/home/runner/work/bipal-front/bipal-front/src/app/core/i18n/language-selector.component.ts */\n.language-selector {\n  position: relative;\n  display: inline-block;\n}\n.current-language {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  padding: 0.5rem 1rem;\n  border: 1px solid #e0e0e0;\n  border-radius: 0.25rem;\n  background: white;\n  cursor: pointer;\n  transition: all 0.2s ease;\n}\n.current-language:hover {\n  border-color: #007bff;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n.arrow {\n  transition: transform 0.2s ease;\n  font-size: 0.8rem;\n}\n.arrow.open {\n  transform: rotate(180deg);\n}\n.dropdown {\n  position: absolute;\n  top: 100%;\n  left: 0;\n  right: 0;\n  background: white;\n  border: 1px solid #e0e0e0;\n  border-radius: 0.25rem;\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n  z-index: 1000;\n  margin-top: 0.25rem;\n}\n.language-option {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  width: 100%;\n  padding: 0.75rem 1rem;\n  border: none;\n  background: white;\n  cursor: pointer;\n  transition: background-color 0.2s ease;\n  text-align: left;\n}\n.language-option:hover {\n  background-color: #f8f9fa;\n}\n.language-option.active {\n  background-color: #e3f2fd;\n  color: #1976d2;\n}\n.flag {\n  font-size: 1.2rem;\n}\n.name {\n  font-weight: 500;\n}\n/*# sourceMappingURL=language-selector.component.css.map */\n"] }]
  }], () => [{ type: I18nService }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(LanguageSelectorComponent, { className: "LanguageSelectorComponent", filePath: "src/app/core/i18n/language-selector.component.ts", lineNumber: 109 });
})();

// src/app/core/interceptor/auth.interceptor.ts
var authInterceptor = (req, next) => {
  const loadingService = inject(LoadingService);
  const auth = inject(AuthService);
  const userId = auth.session?.user?.id;
  if (userId) {
    req = req.clone({
      setHeaders: {
        "user-id": userId,
        Authorization: `Bearer ${auth.session.access_token}`
      }
    });
  }
  if (req.method === "POST" || req.method === "PUT" || req.method === "DELETE") {
    loadingService.show();
    return next(req).pipe(finalize(() => {
      loadingService.hide();
    }));
  }
  return next(req);
};

// src/app/core/interceptor/loading.interceptor.ts
var getLoadingInterceptor = (req, next) => {
  if (req.method !== "GET" || req.headers.has("x-disable-get-loading")) {
    return next(req);
  }
  const svc = inject(HttpGetLoadingService);
  svc.show();
  return next(req).pipe(finalize(() => svc.hide()));
};

// src/app/core/date/custom-date-adapter.ts
var EsCoDateAdapter = class _EsCoDateAdapter extends NativeDateAdapter {
  parse(value) {
    if (typeof value === "string") {
      const parts = value.trim().split("/");
      if (parts.length === 3) {
        const day = Number(parts[0]);
        const month = Number(parts[1]) - 1;
        const year = Number(parts[2]);
        if (!isNaN(day) && !isNaN(month) && !isNaN(year)) {
          const date = new Date(year, month, day);
          if (date && date.getMonth() === month) {
            return date;
          }
        }
      }
    }
    return value instanceof Date ? value : null;
  }
  format(date, displayFormat) {
    if (!date)
      return "";
    const day = this._to2digit(date.getDate());
    const month = this._to2digit(date.getMonth() + 1);
    const year = date.getFullYear();
    return `${day}/${month}/${year}`;
  }
  _to2digit(n) {
    return ("00" + n).slice(-2);
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275EsCoDateAdapter_BaseFactory;
    return function EsCoDateAdapter_Factory(__ngFactoryType__) {
      return (\u0275EsCoDateAdapter_BaseFactory || (\u0275EsCoDateAdapter_BaseFactory = \u0275\u0275getInheritedFactory(_EsCoDateAdapter)))(__ngFactoryType__ || _EsCoDateAdapter);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _EsCoDateAdapter, factory: _EsCoDateAdapter.\u0275fac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EsCoDateAdapter, [{
    type: Injectable
  }], null, null);
})();

// src/app/core/date/date-formats.ts
var ES_CO_DATE_FORMATS = {
  parse: { dateInput: "DD/MM/YYYY" },
  display: {
    dateInput: "DD/MM/YYYY",
    monthYearLabel: "MMM YYYY",
    dateA11yLabel: "DD/MM/YYYY",
    monthYearA11yLabel: "MMMM YYYY"
  }
};

// src/app/app.config.ts
var appConfig = {
  providers: [
    provideZoneChangeDetection({ eventCoalescing: true }),
    provideRouter(routes),
    provideHttpClient(withInterceptors([authInterceptor, getLoadingInterceptor])),
    provideStore({}),
    provideEffects([]),
    provideStoreDevtools({ maxAge: 25, logOnly: false }),
    { provide: MAT_DATE_LOCALE, useValue: "es-CO" },
    { provide: DateAdapter, useClass: EsCoDateAdapter },
    { provide: MAT_DATE_FORMATS, useValue: ES_CO_DATE_FORMATS },
    ...I18N_PROVIDERS
  ]
};

// src/app/app.component.ts
var AppComponent = class _AppComponent {
  title = "bipal-front";
  matIconReg = inject(MatIconRegistry);
  ngOnInit() {
    this.matIconReg.setDefaultFontSetClass("material-symbols-rounded");
  }
  static \u0275fac = function AppComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AppComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AppComponent, selectors: [["app-root"]], decls: 3, vars: 0, template: function AppComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "app-top-get-loading-bar")(1, "router-outlet")(2, "app-loading");
    }
  }, dependencies: [RouterOutlet, LoadingComponent, TopGetLoadingBarComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppComponent, [{
    type: Component,
    args: [{ selector: "app-root", imports: [RouterOutlet, LoadingComponent, TopGetLoadingBarComponent], template: "<app-top-get-loading-bar />\n<router-outlet />\n<app-loading></app-loading>\n" }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AppComponent, { className: "AppComponent", filePath: "src/app/app.component.ts", lineNumber: 13 });
})();

// src/main.ts
bootstrapApplication(AppComponent, appConfig).catch((err) => console.error(err));
//# sourceMappingURL=main.js.map
